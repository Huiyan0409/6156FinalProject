{"signature": "def get_ca_certificates(self):", "body": "if self._cacerts is not None:<EOL><INDENT>return tuple(self._cacerts)<EOL><DEDENT>", "docstring": "Get the CA certificates in the PKCS #12 structure.\n\n:return: A tuple with the CA certificates in the chain, or\n    :py:const:`None` if there are none.\n:rtype: :py:class:`tuple` of :py:class:`X509` or :py:const:`None`", "id": "f4638:c15:m5"}
{"signature": "def get_metaclass(class_or_instance):", "body": "if isinstance(class_or_instance, Class):<EOL><INDENT>return class_or_instance.__metaclass__<EOL><DEDENT>elif issubclass(class_or_instance, Class):<EOL><INDENT>return class_or_instance.__metaclass__<EOL><DEDENT>raise MetaException(\"<STR_LIT>\")<EOL>", "docstring": "Get the metaclass for a *class_or_instance*.", "id": "f14739:m11"}
{"signature": "def fetch_items(self, category, **kwargs):", "body": "from_date = kwargs['<STR_LIT>']<EOL>logger.info(\"<STR_LIT>\",<EOL>self.url, self.project, str(from_date))<EOL>whole_pages = self.client.get_issues(from_date)<EOL>fields = json.loads(self.client.get_fields())<EOL>custom_fields = filter_custom_fields(fields)<EOL>for whole_page in whole_pages:<EOL><INDENT>issues = self.parse_issues(whole_page)<EOL>for issue in issues:<EOL><INDENT>mapping = map_custom_field(custom_fields, issue['<STR_LIT>'])<EOL>for k, v in mapping.items():<EOL><INDENT>issue['<STR_LIT>'][k] = v<EOL><DEDENT>comments_data = self.__get_issue_comments(issue['<STR_LIT:id>'])<EOL>issue['<STR_LIT>'] = comments_data<EOL>yield issue<EOL><DEDENT><DEDENT>", "docstring": "Fetch the issues\n\n        :param category: the category of items to fetch\n        :param kwargs: backend arguments\n\n        :returns: a generator of items", "id": "f13180:c0:m2"}
{"signature": "def __init__(self, val, dtype, vldMask, updateTime=-<NUM_LIT:1>):", "body": "self.val = val<EOL>self._dtype = dtype<EOL>self.vldMask = vldMask<EOL>self.updateTime = updateTime<EOL>", "docstring": ":param val: pythonic value representing this value\n:param dtype: data type object from which this value was derived from\n:param vldMask: validity mask for value\n:param updateTime: simulation time when this value vas created", "id": "f1263:c0:m0"}
{"signature": "def _get_source_address(self):", "body": "return self.__source_address<EOL>", "docstring": "Getter method for source_address, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/sessions/session/state/source_address (inet:ip-address)\n\nYANG Description: Origin address of RSVP session", "id": "f22307:c0:m5"}
{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ExpressRoutePortsLocationPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ExpressRoutePortsLocationPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves all ExpressRoutePort peering locations. Does not return\n        available bandwidths for each location. Available bandwidths can only\n        be obtained when retrieving a specific peering location.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ExpressRoutePortsLocation\n        :rtype:\n         ~azure.mgmt.network.v2019_02_01.models.ExpressRoutePortsLocationPaged[~azure.mgmt.network.v2019_02_01.models.ExpressRoutePortsLocation]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34922:c0:m1"}
{"signature": "def delete_role_instances(self, service_name, deployment_name,<EOL>role_instance_names):", "body": "_validate_not_none('<STR_LIT>', service_name)<EOL>_validate_not_none('<STR_LIT>', deployment_name)<EOL>_validate_not_none('<STR_LIT>', role_instance_names)<EOL>return self._perform_post(<EOL>self._get_deployment_path_using_name(<EOL>service_name, deployment_name) + '<STR_LIT>',<EOL>_XmlSerializer.role_instances_to_xml(role_instance_names),<EOL>as_async=True)<EOL>", "docstring": "Reinstalls the operating system on instances of web roles or worker\nroles and initializes the storage resources that are used by them. If\nyou do not want to initialize storage resources, you can use\nreimage_role_instance.\n\nservice_name:\n    Name of the hosted service.\ndeployment_name:\n    The name of the deployment.\nrole_instance_names:\n    List of role instance names.", "id": "f41502:c0:m29"}
{"signature": "def service(url, api_key, help_url = None):", "body": "def do_publish(func):<EOL><INDENT>return published(url, api_key, help_url, func, None)<EOL><DEDENT>return do_publish<EOL>", "docstring": "Marks a function as having been published and causes all invocations to go to the remote\noperationalized service.\n\n>>> @service(url, api_key)\n>>> def f(a, b):\n>>>     pass", "id": "f13019:m40"}
{"signature": "def visit_CallTrue(self, node: parsing.CallTrue) -> ast.expr:", "body": "return ast.Lambda(<EOL>ast.arguments([], None, None, [], None, None, [], []),<EOL>ast.BoolOp(<EOL>ast.Or(),<EOL>[<EOL>self.visit_Call(node),<EOL>ast.Name('<STR_LIT:True>', ast.Load())]))<EOL>", "docstring": "Generates python code calling the function and returning True.\n\n        lambda: fn(*args) or True", "id": "f4969:c0:m5"}
{"signature": "def delete(<EOL>self, resource_group_name, service_topology_name, service_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", service_topology_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", service_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes the service.\n\n        :param resource_group_name: The name of the resource group. The name\n         is case insensitive.\n        :type resource_group_name: str\n        :param service_topology_name: The name of the service topology .\n        :type service_topology_name: str\n        :param service_name: The name of the service resource.\n        :type service_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f41017:c0:m3"}
{"signature": "def delete_vacation(self, index, vacation):", "body": "body = {\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": self.thermostats[index]['<STR_LIT>']},<EOL>\"<STR_LIT>\": [{\"<STR_LIT:type>\": \"<STR_LIT>\", \"<STR_LIT>\": {<EOL>\"<STR_LIT:name>\": vacation<EOL>}}]}<EOL>log_msg_action = \"<STR_LIT>\"<EOL>return self.make_request(body, log_msg_action)<EOL>", "docstring": "Delete the vacation with name vacation", "id": "f322:c0:m15"}
{"signature": "def list_metrics(<EOL>self, resource_group_name, account_name, database_rid, collection_rid, filter, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_metrics.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:3>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", database_rid, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", collection_rid, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.MetricPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.MetricPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves the metrics determined by the given filter for the given\n        database account and collection.\n\n        :param resource_group_name: Name of an Azure resource group.\n        :type resource_group_name: str\n        :param account_name: Cosmos DB database account name.\n        :type account_name: str\n        :param database_rid: Cosmos DB database rid.\n        :type database_rid: str\n        :param collection_rid: Cosmos DB collection rid.\n        :type collection_rid: str\n        :param filter: An OData filter expression that describes a subset of\n         metrics to return. The parameters that can be filtered are name.value\n         (name of the metric, can have an or of multiple names), startTime,\n         endTime, and timeGrain. The supported operator is eq.\n        :type filter: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Metric\n        :rtype:\n         ~azure.mgmt.cosmosdb.models.MetricPaged[~azure.mgmt.cosmosdb.models.Metric]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f43929:c0:m1"}
{"signature": "def _get_priority_decrement(self):", "body": "return self.__priority_decrement<EOL>", "docstring": "Getter method for priority_decrement, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/interface_tracking/state/priority_decrement (uint8)\n\n    YANG Description: Set the value to subtract from priority when\nthe tracked interface goes down", "id": "f21985:c0:m5"}
{"signature": "def _get_use_multiple_paths(self):", "body": "return self.__use_multiple_paths<EOL>", "docstring": "Getter method for use_multiple_paths, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/use_multiple_paths (container)\n\n    YANG Description: Parameters related to the use of multiple paths for the\nsame NLRI", "id": "f23462:c0:m17"}
{"signature": "def create_or_update_at_management_group(<EOL>self, policy_definition_name, parameters, management_group_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_or_update_at_management_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", policy_definition_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", management_group_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.put(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Creates or updates a policy definition at management group level.\n\n        :param policy_definition_name: The name of the policy definition to\n         create.\n        :type policy_definition_name: str\n        :param parameters: The policy definition properties.\n        :type parameters:\n         ~azure.mgmt.resource.policy.v2016_12_01.models.PolicyDefinition\n        :param management_group_id: The ID of the management group.\n        :type management_group_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: PolicyDefinition or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.resource.policy.v2016_12_01.models.PolicyDefinition or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37403:c0:m5"}
{"signature": "def concat_list(in_list):", "body": "return list(itertools.chain(*in_list))<EOL>", "docstring": "Concatenate a list of list into a single list.\n\n    Args:\n        in_list (list): The list of list to be merged.\n\n    Returns:\n        list: The concatenated flat list.", "id": "f14501:m8"}
{"signature": "def lpc(y, order):", "body": "if not isinstance(order, int) or order < <NUM_LIT:1>:<EOL><INDENT>raise ParameterError(\"<STR_LIT>\")<EOL><DEDENT>util.valid_audio(y, mono=True)<EOL>return __lpc(y, order)<EOL>", "docstring": "Linear Prediction Coefficients via Burg's method\n\n    This function applies Burg's method to estimate coefficients of a linear\n    filter on `y` of order `order`.  Burg's method is an extension to the\n    Yule-Walker approach, which are both sometimes referred to as LPC parameter\n    estimation by autocorrelation.\n\n    It follows the description and implementation approach described in the\n    introduction in [1]_.  N.B. This paper describes a different method, which\n    is not implemented here, but has been chosen for its clear explanation of\n    Burg's technique in its introduction.\n\n    .. [1] Larry Marple\n           A New Autoregressive Spectrum Analysis Algorithm\n           IEEE Transactions on Accoustics, Speech, and Signal Processing\n           vol 28, no. 4, 1980\n\n    Parameters\n    ----------\n    y : np.ndarray\n        Time series to fit\n\n    order : int > 0\n        Order of the linear filter\n\n    Returns\n    -------\n    a : np.ndarray of length order + 1\n        LP prediction error coefficients, i.e. filter denominator polynomial\n\n    Raises\n    ------\n    ParameterError\n        - If y is not valid audio as per `util.valid_audio`\n        - If order < 1 or not integer\n    FloatingPointError\n        - If y is ill-conditioned\n\n    See also\n    --------\n    scipy.signal.lfilter\n\n    Examples\n    --------\n    Compute LP coefficients of y at order 16 on entire series\n\n    >>> y, sr = librosa.load(librosa.util.example_audio_file(), offset=30,\n    ...                      duration=10)\n    >>> librosa.lpc(y, 16)\n\n    Compute LP coefficients, and plot LP estimate of original series\n\n    >>> import matplotlib.pyplot as plt\n    >>> import scipy\n    >>> y, sr = librosa.load(librosa.util.example_audio_file(), offset=30,\n    ...                      duration=0.020)\n    >>> a = librosa.lpc(y, 2)\n    >>> y_hat = scipy.signal.lfilter([0] + -1*a[1:], [1], y)\n    >>> plt.figure()\n    >>> plt.plot(y)\n    >>> plt.plot(y_hat)\n    >>> plt.legend(['y', 'y_hat'])\n    >>> plt.title('LP Model Forward Prediction')", "id": "f18154:m6"}
{"signature": "@line_magic<EOL><INDENT>def quickref(self,arg):<DEDENT>", "body": "from IPython.core.usage import quick_reference<EOL>qr = quick_reference + self._magic_docs(brief=True)<EOL>page.page(qr)<EOL>", "docstring": "Show a quick reference sheet", "id": "f21428:c0:m10"}
{"signature": "def _set_reoptimize_timer(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=int, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}, int_size=<NUM_LIT:16><EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__reoptimize_timer = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for reoptimize_timer, mapped from YANG variable /network_instances/network_instance/mpls/te_global_attributes/te_lsp_timers/state/reoptimize_timer (uint16)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_reoptimize_timer is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_reoptimize_timer() directly.\n\n    YANG Description: frequency of reoptimization of\na traffic engineered LSP", "id": "f22189:c1:m9"}
{"signature": "def list_fields_by_module_and_type(<EOL>self, resource_group_name, automation_account_name, module_name, type_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_fields_by_module_and_type.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", automation_account_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", module_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", type_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.TypeFieldPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.TypeFieldPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieve a list of fields of a given type identified by module name.\n\n        :param resource_group_name: Name of an Azure Resource group.\n        :type resource_group_name: str\n        :param automation_account_name: The name of the automation account.\n        :type automation_account_name: str\n        :param module_name: The name of module.\n        :type module_name: str\n        :param type_name: The name of type.\n        :type type_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of TypeField\n        :rtype:\n         ~azure.mgmt.automation.models.TypeFieldPaged[~azure.mgmt.automation.models.TypeField]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.automation.models.ErrorResponseException>`", "id": "f43578:c0:m1"}
{"signature": "def _get_link_attributes(self):", "body": "return self.__link_attributes<EOL>", "docstring": "Getter method for link_attributes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/link_attributes (container)\n\nYANG Description: This container defines link-attributes.", "id": "f22592:c0:m38"}
{"signature": "def f_is_empty(self):", "body": "return len(self._dict) == <NUM_LIT:0><EOL>", "docstring": "Checks if annotations are empty", "id": "f4236:c0:m7"}
{"signature": "def get_thing(self, idx):", "body": "try:<EOL><INDENT>idx = int(idx)<EOL><DEDENT>except ValueError:<EOL><INDENT>return None<EOL><DEDENT>if idx < <NUM_LIT:0> or idx >= len(self.things):<EOL><INDENT>return None<EOL><DEDENT>return self.things[idx]<EOL>", "docstring": "Get the thing at the given index.\n\nidx -- the index", "id": "f478:c1:m1"}
{"signature": "def _set_maximum_paths(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>default=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>)(<EOL><NUM_LIT:1><EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__maximum_paths = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for maximum_paths, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/use_multiple_paths/ibgp/state/maximum_paths (uint32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_maximum_paths is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_maximum_paths() directly.\n\n    YANG Description: Maximum number of parallel paths to consider when using\niBGP multipath. The default is to use a single path", "id": "f23243:c0:m3"}
{"signature": "def _set_id(self, v, load=False):", "body": "parent = getattr(self, \"<STR_LIT>\", None)<EOL>if parent is not None and load is False:<EOL><INDENT>raise AttributeError(<EOL>\"<STR_LIT>\" + \"<STR_LIT>\"<EOL>)<EOL><DEDENT>if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:id>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>is_keyval=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__id = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/id (leafref)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_id is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_id() directly.\n\nYANG Description: A pointer to the identifier for the interface.", "id": "f23121:c1:m3"}
{"signature": "def _get_errors_received(self):", "body": "return self.__errors_received<EOL>", "docstring": "Getter method for errors_received, mapped from YANG variable /system/aaa/server_groups/server_group/servers/server/state/errors_received (yang:counter64)\n\nYANG Description: Number of error messages received from the server", "id": "f21897:c0:m32"}
{"signature": "def _set_l2vpn_evpn(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=l2vpn_evpn.l2vpn_evpn,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__l2vpn_evpn = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for l2vpn_evpn, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_l2vpn_evpn is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_l2vpn_evpn() directly.\n\nYANG Description: BGP EVPN configuration options", "id": "f23427:c0:m48"}
{"signature": "def get_year_commits(self, username='<STR_LIT>', password='<STR_LIT>', organization='<STR_LIT>', force=True):", "body": "date = str(datetime.date.today())<EOL>file_path =  ('<STR_LIT>')<EOL>if force or not os.path.isfile(file_path):<EOL><INDENT>my_github.login(username, password)<EOL>calls_beginning = self.logged_in_gh.ratelimit_remaining + <NUM_LIT:1><EOL>print('<STR_LIT>' + str(calls_beginning))<EOL>my_github.get_org(organization)<EOL>my_github.repos(building_stats=True)<EOL>print(\"<STR_LIT>\")<EOL>time.sleep(<NUM_LIT:30>)<EOL>print(\"<STR_LIT>\")<EOL>my_github.repos(building_stats=False)<EOL>my_github.calc_total_commits(starting_commits=<NUM_LIT>)<EOL>my_github.write_to_file()<EOL>calls_remaining = self.logged_in_gh.ratelimit_remaining<EOL>calls_used = calls_beginning - calls_remaining<EOL>print(('<STR_LIT>' + str(calls_remaining) + '<STR_LIT>'<EOL>+ str(calls_used) + '<STR_LIT>'))<EOL><DEDENT>", "docstring": "Does setup such as login, printing API info, and waiting for GitHub to\nbuild the commit statistics. Then gets the last year of commits and\nprints them to file.", "id": "f4699:c0:m1"}
{"signature": "def setUp(self):", "body": "node1 = DomainNode(name=\"<STR_LIT>\")<EOL>node2 = DomainNode(name=\"<STR_LIT>\")<EOL>edge1 = DomainEdge(source=node1, target=node2)<EOL>model = DomainModel(nodes=[node1, node2], edges=[edge1])<EOL>self.view_model = DomainViewModel(model=model)<EOL>", "docstring": "Prepares the test fixture before each test method is called.", "id": "f1978:c6:m0"}
{"signature": "def _travis(self):", "body": "if PyFunceble.CONFIGURATION[\"<STR_LIT>\"]:<EOL><INDENT>try:<EOL><INDENT>_ = PyFunceble.environ[\"<STR_LIT>\"]<EOL>time_autorisation = False<EOL>try:<EOL><INDENT>time_autorisation = int(PyFunceble.time()) >= int(<EOL>PyFunceble.INTERN[\"<STR_LIT:start>\"]<EOL>) + (int(PyFunceble.CONFIGURATION[\"<STR_LIT>\"]) * <NUM_LIT>)<EOL><DEDENT>except KeyError:<EOL><INDENT>if self.last and not self.bypass:<EOL><INDENT>raise Exception(<EOL>\"<STR_LIT>\"<EOL>)<EOL><DEDENT><DEDENT>if self.last or time_autorisation or self.bypass:<EOL><INDENT>Percentage().log()<EOL>self.travis_permissions()<EOL>command = '<STR_LIT>'<EOL>if self.last or self.bypass:<EOL><INDENT>if PyFunceble.CONFIGURATION[\"<STR_LIT>\"]:<EOL><INDENT>for line in Command(<EOL>PyFunceble.CONFIGURATION[\"<STR_LIT>\"]<EOL>).run():<EOL><INDENT>sys_stdout.write(\"<STR_LIT>\".format(line))<EOL><DEDENT>self.travis_permissions()<EOL><DEDENT>message = (<EOL>PyFunceble.CONFIGURATION[\"<STR_LIT>\"]<EOL>+ \"<STR_LIT>\"<EOL>)<EOL>Command(command % message).execute()<EOL><DEDENT>else:<EOL><INDENT>if PyFunceble.CONFIGURATION[\"<STR_LIT>\"]:<EOL><INDENT>for line in Command(<EOL>PyFunceble.CONFIGURATION[\"<STR_LIT>\"]<EOL>).run():<EOL><INDENT>sys_stdout.write(\"<STR_LIT>\".format(line))<EOL><DEDENT>self.travis_permissions()<EOL><DEDENT>Command(<EOL>command % PyFunceble.CONFIGURATION[\"<STR_LIT>\"]<EOL>).execute()<EOL><DEDENT>print(<EOL>Command(<EOL>\"<STR_LIT>\"<EOL>% PyFunceble.CONFIGURATION[\"<STR_LIT>\"]<EOL>).execute()<EOL>)<EOL>exit(<NUM_LIT:0>)<EOL><DEDENT><DEDENT>except KeyError:<EOL><INDENT>pass<EOL><DEDENT><DEDENT>", "docstring": "Logic behind autosave under Travis CI.", "id": "f8231:c0:m2"}
{"signature": "def _get_tag64(self):", "body": "return self.__tag64<EOL>", "docstring": "Getter method for tag64, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_ipv4_reachability/prefixes/prefix/subTLVs/subTLVs/tag64 (container)\n\nYANG Description: This container defines sub-TLV 2.", "id": "f22937:c1:m11"}
{"signature": "def get(<EOL>self, resource_group_name, application_security_group_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", application_security_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets information about the specified application security group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param application_security_group_name: The name of the application\n         security group.\n        :type application_security_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ApplicationSecurityGroup or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.ApplicationSecurityGroup or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32796:c0:m3"}
{"signature": "def _create_scheduled_query(self, query, change, scope_unit, scope_count):", "body": "query_data = {<EOL>'<STR_LIT>': {<EOL>'<STR_LIT:name>': '<STR_LIT>',<EOL>'<STR_LIT>': query,<EOL>'<STR_LIT>': '<STR_LIT:%>',<EOL>'<STR_LIT>': change,<EOL>'<STR_LIT>': scope_unit.title(),<EOL>'<STR_LIT>': scope_count,<EOL>}<EOL>}<EOL>query_url = '<STR_LIT>'<EOL>return self._api_post(<EOL>url=query_url.format(account_id=self.account_id),<EOL>data=json.dumps(query_data, sort_keys=True)<EOL>)<EOL>", "docstring": "Create the scheduled query", "id": "f8658:c4:m0"}
{"signature": "def delete(<EOL>self, resource_group_name, virtual_network_gateway_connection_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>virtual_network_gateway_connection_name=virtual_network_gateway_connection_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified virtual network Gateway connection.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_gateway_connection_name: The name of the\n         virtual network gateway connection.\n        :type virtual_network_gateway_connection_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33399:c0:m5"}
{"signature": "def _set_link_loss(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=link_loss.link_loss,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__link_loss = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for link_loss, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/link_loss (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_link_loss is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_link_loss() directly.\n\nYANG Description: This container defines unidirectional link loss delay.", "id": "f22845:c1:m66"}
{"signature": "def list_expression_traces(<EOL>self, resource_group_name, workflow_name, run_name, action_name, repetition_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_expression_traces.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", workflow_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", run_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", action_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", repetition_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ExpressionRootPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ExpressionRootPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists a workflow run expression trace.\n\n        :param resource_group_name: The resource group name.\n        :type resource_group_name: str\n        :param workflow_name: The workflow name.\n        :type workflow_name: str\n        :param run_name: The workflow run name.\n        :type run_name: str\n        :param action_name: The workflow action name.\n        :type action_name: str\n        :param repetition_name: The workflow repetition.\n        :type repetition_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ExpressionRoot\n        :rtype:\n         ~azure.mgmt.logic.models.ExpressionRootPaged[~azure.mgmt.logic.models.ExpressionRoot]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f39902:c0:m3"}
{"signature": "def matches_filters(self, node):", "body": "visible = self.visible<EOL>if self.options[\"<STR_LIT:text>\"]:<EOL><INDENT>if isregex(self.options[\"<STR_LIT:text>\"]):<EOL><INDENT>regex = self.options[\"<STR_LIT:text>\"]<EOL><DEDENT>elif self.exact_text is True:<EOL><INDENT>regex = re.compile(r\"<STR_LIT>\".format(re.escape(self.options[\"<STR_LIT:text>\"])))<EOL><DEDENT>else:<EOL><INDENT>regex = toregex(self.options[\"<STR_LIT:text>\"])<EOL><DEDENT>text = normalize_text(<EOL>node.all_text if visible == \"<STR_LIT:all>\" else node.visible_text)<EOL>if not regex.search(text):<EOL><INDENT>return False<EOL><DEDENT><DEDENT>if isinstance(self.exact_text, (bytes_, str_)):<EOL><INDENT>regex = re.compile(r\"<STR_LIT>\".format(re.escape(self.exact_text)))<EOL>text = normalize_text(<EOL>node.all_text if visible == \"<STR_LIT:all>\" else node.visible_text)<EOL>if not regex.search(text):<EOL><INDENT>return False<EOL><DEDENT><DEDENT>if visible == \"<STR_LIT>\":<EOL><INDENT>if not node.visible:<EOL><INDENT>return False<EOL><DEDENT><DEDENT>elif visible == \"<STR_LIT>\":<EOL><INDENT>if node.visible:<EOL><INDENT>return False<EOL><DEDENT><DEDENT>for name, node_filter in iter(self._node_filters.items()):<EOL><INDENT>if name in self.filter_options:<EOL><INDENT>if not node_filter.matches(node, self.filter_options[name]):<EOL><INDENT>return False<EOL><DEDENT><DEDENT>elif node_filter.has_default:<EOL><INDENT>if not node_filter.matches(node, node_filter.default):<EOL><INDENT>return False<EOL><DEDENT><DEDENT><DEDENT>if self.options[\"<STR_LIT>\"] and not self.options[\"<STR_LIT>\"](node):<EOL><INDENT>return False<EOL><DEDENT>return True<EOL>", "docstring": "Returns whether the given node matches all filters.\n\nArgs:\n    node (Element): The node to evaluate.\n\nReturns:\n    bool: Whether the given node matches.", "id": "f16652:c0:m13"}
{"signature": "def get_entry_info(dist, group, name):", "body": "return get_distribution(dist).get_entry_info(group, name)<EOL>", "docstring": "Return the EntryPoint object for `group`+`name`, or ``None``", "id": "f17242:m19"}
{"signature": "def _set_allow_multiple_as(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__allow_multiple_as = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for allow_multiple_as, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp/config/allow_multiple_as (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_allow_multiple_as is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_allow_multiple_as() directly.\n\n    YANG Description: Allow multipath to use paths from different neighbouring\nASes.  The default is to only consider multiple paths from\nthe same neighbouring AS.", "id": "f23425:c1:m3"}
{"signature": "@property<EOL><INDENT>def dim(self):<DEDENT>", "body": "return self._input_dim, self._output_dim<EOL>", "docstring": "Return tuple (input_shape, output_shape).", "id": "f10796:c0:m4"}
{"signature": "def _get_point_to_point_over_lan(self):", "body": "return self.__point_to_point_over_lan<EOL>", "docstring": "Getter method for point_to_point_over_lan, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information/tlvs/tlv/informational_capabilities/state/point_to_point_over_lan (boolean)\n\n    YANG Description: When this leaf is set to true, the advertising system supports treating\nLAN adjacencies as though they were point to point", "id": "f23071:c0:m14"}
{"signature": "def is_empty(self):", "body": "return len(self.patch2line) == <NUM_LIT:0><EOL>", "docstring": "Returns true if no patch is in the series", "id": "f14382:c2:m22"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix/tlvs/tlv/prefix_sid/state (container)\n\n    YANG Description: State parameters relating to the Prefix SID sub-TLV of the\nextended prefix LSA", "id": "f23021:c1:m2"}
{"signature": "def xminvsks(self, **kwargs):", "body": "pylab.plot(self._xmins,self._xmin_kstest,'<STR_LIT:.>')<EOL>pylab.plot(self._xmin,self._ks,'<STR_LIT:s>')<EOL>ax=pylab.gca()<EOL>ax.set_ylabel(\"<STR_LIT>\")<EOL>ax.set_xlabel(\"<STR_LIT>\")<EOL>pylab.draw()<EOL>return ax<EOL>", "docstring": "Plot xmin versus the ks value for derived alpha.  This plot can be used\nas a diagnostic of whether you have derived the 'best' fit: if there are\nmultiple local minima, your data set may be well suited to a broken\npowerlaw or a different function.", "id": "f13317:c0:m3"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/esh/state (container)\n\nYANG Description: Operational state relating to ESH PDUs", "id": "f22429:c0:m2"}
{"signature": "def suspend_partition_backup(<EOL>self, partition_id, timeout=<NUM_LIT>, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>url = self.suspend_partition_backup.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", partition_id, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>if timeout is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", timeout, '<STR_LIT>', maximum=<NUM_LIT>, minimum=<NUM_LIT:1>)<EOL><DEDENT>header_parameters = {}<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.FabricErrorException(self._deserialize, response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Suspends periodic backup for the specified partition.\n\n        The partition which is configured to take periodic backups, is\n        suspended for taking further backups till it is resumed again.\n\n        :param partition_id: The identity of the partition.\n        :type partition_id: str\n        :param timeout: The server timeout for performing the operation in\n         seconds. This timeout specifies the time duration that the client is\n         willing to wait for the requested operation to complete. The default\n         value for this parameter is 60 seconds.\n        :type timeout: long\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`FabricErrorException<azure.servicefabric.models.FabricErrorException>`", "id": "f27460:c1:m169"}
{"signature": "def _get_shutdown_threshold_pct(self):", "body": "return self.__shutdown_threshold_pct<EOL>", "docstring": "Getter method for shutdown_threshold_pct, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/state/shutdown_threshold_pct (oc-types:percentage)\n\n    YANG Description: Threshold on number of prefixes that can be received\nfrom a neighbour before generation of warning messages\nor log entries. Expressed as a percentage of\nmax-prefixes", "id": "f23324:c1:m8"}
{"signature": "def _set_bandwidth_reservation(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT>\",<EOL>bandwidth_reservation.bandwidth_reservation,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__bandwidth_reservation = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for bandwidth_reservation, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/bandwidth_reservations/bandwidth_reservation (list)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_bandwidth_reservation is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_bandwidth_reservation() directly.\n\n    YANG Description: Available and reserved bandwidth by priority on\nthe interface.", "id": "f22282:c1:m3"}
{"signature": "@property<EOL><INDENT>def level(self) -> int:<DEDENT>", "body": "m = HEADER_MATCH(self._shadow)<EOL>if m:<EOL><INDENT>return len(m.group(<NUM_LIT:1>))<EOL><DEDENT>return <NUM_LIT:0><EOL>", "docstring": "Return level of this section.\n\n        Level is in range(1,7) or 0 for the lead section.", "id": "f8135:c0:m0"}
{"signature": "def _get_native_vlan(self):", "body": "return self.__native_vlan<EOL>", "docstring": "Getter method for native_vlan, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/state/native_vlan (union)\n\n    YANG Description: Set the native VLAN id for untagged frames arriving on\na trunk interface.  This configuration is only valid on\na trunk interface.", "id": "f22002:c0:m5"}
{"signature": "def start_proc_insanity_check(p_string):", "body": "if FORK_TOKEN + FORK_TOKEN in p_string:<EOL><INDENT>raise SanityError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "This function checks if there is a starting process after the beginning of\neach fork. It checks for duplicated start tokens ['(('].\n\nParameters\n----------\np_string: str\n     String with the definition of the pipeline, e.g.::\n         'processA processB processC(ProcessD | ProcessE)'", "id": "f6630:m8"}
{"signature": "def check_libs2(self, lib_dirs, libs, opt_libs=[]):", "body": "exts = self.library_extensions()<EOL>info = self._check_libs(lib_dirs, libs, opt_libs, exts)<EOL>if not info:<EOL><INDENT>log.info('<STR_LIT>', '<STR_LIT:U+002C>'.join(libs),<EOL>lib_dirs)<EOL><DEDENT>return info<EOL>", "docstring": "If static or shared libraries are available then return\n        their info dictionary.\n\n        Checks each library for shared or static.", "id": "f19185:c11:m14"}
{"signature": "def process_result_value(self, value, dialect):", "body": "masks = list()<EOL>if value:<EOL><INDENT>for e in enums.CryptographicUsageMask:<EOL><INDENT>if e.value & value:<EOL><INDENT>masks.append(e)<EOL><DEDENT><DEDENT><DEDENT>return masks<EOL>", "docstring": "Returns a new list of enums.CryptographicUsageMask Enums. This converts\nthe integer value into the list of enums.\n\nArgs:\n    value(int): The integer value stored in the database that is used\n        to create the list of enums.CryptographicUsageMask Enums.\n    dialect(string): SQL dialect", "id": "f15065:c0:m1"}
{"signature": "def mean(self, binby=[], limits=None, shape=default_shape, selection=False, delay=False, progress=None):", "body": "kwargs = dict(locals())<EOL>del kwargs['<STR_LIT>']<EOL>kwargs['<STR_LIT>'] = self.expression<EOL>return self.ds.mean(**kwargs)<EOL>", "docstring": "Shortcut for ds.mean(expression, ...), see `Dataset.mean`", "id": "f6960:c4:m17"}
{"signature": "def get( self, station, interval ):", "body": "rec = station.fields['<STR_LIT>']<EOL>if rec:<EOL><INDENT>threshold = station.fields['<STR_LIT>'] + GUST_MPH_MIN<EOL>if rec['<STR_LIT>'] >= threshold:<EOL><INDENT>self.value = (rec['<STR_LIT>'],rec['<STR_LIT>'])<EOL>self.count = GUST_TTL * <NUM_LIT> / interval<EOL><DEDENT>else:<EOL><INDENT>self.value = self.NO_VALUE<EOL><DEDENT><DEDENT>if self.count:<EOL><INDENT>self.count -= <NUM_LIT:1><EOL><DEDENT>else:<EOL><INDENT>self.value = self.NO_VALUE<EOL><DEDENT>log.debug('<STR_LIT>'.format(*self.value))<EOL>return self.value<EOL>", "docstring": "return gust data, if above threshold value and current time is inside\nreporting window period", "id": "f2249:c1:m1"}
{"signature": "def list_by_step(<EOL>self, resource_group_name, server_name, job_agent_name, job_name, job_execution_id, step_name, create_time_min=None, create_time_max=None, end_time_min=None, end_time_max=None, is_active=None, skip=None, top=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_step.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", server_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", job_agent_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", job_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", job_execution_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", step_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if create_time_min is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", create_time_min, '<STR_LIT>')<EOL><DEDENT>if create_time_max is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", create_time_max, '<STR_LIT>')<EOL><DEDENT>if end_time_min is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", end_time_min, '<STR_LIT>')<EOL><DEDENT>if end_time_max is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", end_time_max, '<STR_LIT>')<EOL><DEDENT>if is_active is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", is_active, '<STR_LIT:bool>')<EOL><DEDENT>if skip is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", skip, '<STR_LIT:int>')<EOL><DEDENT>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.JobExecutionPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.JobExecutionPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists the target executions of a job step execution.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server.\n        :type server_name: str\n        :param job_agent_name: The name of the job agent.\n        :type job_agent_name: str\n        :param job_name: The name of the job to get.\n        :type job_name: str\n        :param job_execution_id: The id of the job execution\n        :type job_execution_id: str\n        :param step_name: The name of the step.\n        :type step_name: str\n        :param create_time_min: If specified, only job executions created at\n         or after the specified time are included.\n        :type create_time_min: datetime\n        :param create_time_max: If specified, only job executions created\n         before the specified time are included.\n        :type create_time_max: datetime\n        :param end_time_min: If specified, only job executions completed at or\n         after the specified time are included.\n        :type end_time_min: datetime\n        :param end_time_max: If specified, only job executions completed\n         before the specified time are included.\n        :type end_time_max: datetime\n        :param is_active: If specified, only active or only completed job\n         executions are included.\n        :type is_active: bool\n        :param skip: The number of elements in the collection to skip.\n        :type skip: int\n        :param top: The number of elements to return from the collection.\n        :type top: int\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of JobExecution\n        :rtype:\n         ~azure.mgmt.sql.models.JobExecutionPaged[~azure.mgmt.sql.models.JobExecution]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38412:c0:m2"}
{"signature": "def _set_prevent_teardown(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__prevent_teardown = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for prevent_teardown, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/config/prevent_teardown (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_prevent_teardown is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_prevent_teardown() directly.\n\n    YANG Description: Do not tear down the BGP session when the maximum\nprefix limit is exceeded, but rather only log a\nwarning. The default of this leaf is false, such\nthat when it is not specified, the session is torn\ndown.", "id": "f23304:c1:m6"}
{"signature": "def _new_conn(self):", "body": "self.num_connections += <NUM_LIT:1><EOL>log.info(\"<STR_LIT>\"<EOL>% (self.num_connections, self.host))<EOL>if not self.ConnectionCls or self.ConnectionCls is DummyConnection:<EOL><INDENT>raise SSLError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>actual_host = self.host<EOL>actual_port = self.port<EOL>if self.proxy is not None:<EOL><INDENT>actual_host = self.proxy.host<EOL>actual_port = self.proxy.port<EOL><DEDENT>conn = self.ConnectionCls(host=actual_host, port=actual_port,<EOL>timeout=self.timeout.connect_timeout,<EOL>strict=self.strict, **self.conn_kw)<EOL>return self._prepare_conn(conn)<EOL>", "docstring": "Return a fresh :class:`httplib.HTTPSConnection`.", "id": "f17247:c2:m2"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, vm_name, vm_extension_name, extension_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>vm_extension_name=vm_extension_name,<EOL>extension_parameters=extension_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "The operation to create or update the extension.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine where the extension\n         should be created or updated.\n        :type vm_name: str\n        :param vm_extension_name: The name of the virtual machine extension.\n        :type vm_extension_name: str\n        :param extension_parameters: Parameters supplied to the Create Virtual\n         Machine Extension operation.\n        :type extension_parameters:\n         ~azure.mgmt.compute.v2017_12_01.models.VirtualMachineExtension\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns VirtualMachineExtension\n         or ClientRawResponse<VirtualMachineExtension> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2017_12_01.models.VirtualMachineExtension]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2017_12_01.models.VirtualMachineExtension]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24371:c0:m2"}
{"signature": "def check_data_redundancy(self, file_path='<STR_LIT>', dict_to_check={}):", "body": "count = <NUM_LIT:0><EOL>exists = os.path.isfile(file_path)<EOL>previous_dates = {}<EOL>if exists:<EOL><INDENT>with open(file_path, '<STR_LIT:r>') as input:<EOL><INDENT>input.readline()<EOL>for row in csv.reader(input):<EOL><INDENT>timestamp = calendar.timegm(time.strptime(row[<NUM_LIT:0>],<EOL>'<STR_LIT>'))<EOL>if timestamp in dict_to_check:<EOL><INDENT>del dict_to_check[timestamp]<EOL><DEDENT>count += <NUM_LIT:1><EOL><DEDENT><DEDENT>input.close()<EOL><DEDENT>return count<EOL>", "docstring": "Checks the given csv file against the json data scraped for the given\ndict. It will remove all data retrieved that has already been recorded\nso we don't write redundant data to file. Returns count of rows from\nfile.", "id": "f4698:c0:m12"}
{"signature": "def parse_token_stream(stream, soft_delimiter, hard_delimiter):", "body": "return [<EOL>[sum(len(token) for token in sentence_it) <EOL>for sentence_it in split_at(block_it, soft_delimiter)]<EOL>for block_it in split_at(stream, hard_delimiter)]<EOL>", "docstring": "Parses a stream of tokens and splits it into sentences (using C{soft_delimiter} tokens) \n    and blocks (using C{hard_delimiter} tokens) for use with the L{align_texts} function.", "id": "f13495:m7"}
{"signature": "def loadPlugins(self):", "body": "from pkg_resources import iter_entry_points<EOL>loaded = {}<EOL>for entry_point, adapt in self.entry_points:<EOL><INDENT>for ep in iter_entry_points(entry_point):<EOL><INDENT>if ep.name in loaded:<EOL><INDENT>continue<EOL><DEDENT>loaded[ep.name] = True<EOL>log.debug('<STR_LIT>', self.__class__.__name__, ep)<EOL>try:<EOL><INDENT>plugcls = ep.load()<EOL><DEDENT>except KeyboardInterrupt:<EOL><INDENT>raise<EOL><DEDENT>except Exception as e:<EOL><INDENT>warn(\"<STR_LIT>\" % (ep, e),<EOL>RuntimeWarning)<EOL>continue<EOL><DEDENT>if adapt:<EOL><INDENT>plug = adapt(plugcls())<EOL><DEDENT>else:<EOL><INDENT>plug = plugcls()<EOL><DEDENT>self.addPlugin(plug)<EOL><DEDENT><DEDENT>super(EntryPointPluginManager, self).loadPlugins()<EOL>", "docstring": "Load plugins by iterating the `nose.plugins` entry point.", "id": "f21769:c4:m0"}
{"signature": "@abc.abstractmethod<EOL><INDENT>def iteritems(self):<DEDENT>", "body": "pass<EOL>", "docstring": "Should return iterator of tuples (key, value) for all entries for the given self.partition", "id": "f3996:c0:m5"}
{"signature": "def list(<EOL>self, resource_group_name, network_security_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", network_security_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.SecurityRulePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.SecurityRulePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all security rules in a network security group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_security_group_name: The name of the network security\n         group.\n        :type network_security_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of SecurityRule\n        :rtype:\n         ~azure.mgmt.network.v2017_06_01.models.SecurityRulePaged[~azure.mgmt.network.v2017_06_01.models.SecurityRule]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32295:c0:m6"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualMachinePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualMachinePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all of the virtual machines in the specified resource group. Use\n        the nextLink property in the response to get the next page of virtual\n        machines.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualMachine\n        :rtype:\n         ~azure.mgmt.compute.v2018_04_01.models.VirtualMachinePaged[~azure.mgmt.compute.v2018_04_01.models.VirtualMachine]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25735:c0:m17"}
{"signature": "def get(<EOL>self, resource_group_name, gallery_name, gallery_image_name, gallery_image_version_name, expand=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", gallery_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", gallery_image_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", gallery_image_version_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if expand is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", expand, '<STR_LIT:str>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves information about a gallery Image Version.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param gallery_name: The name of the Shared Image Gallery in which the\n         Image Definition resides.\n        :type gallery_name: str\n        :param gallery_image_name: The name of the gallery Image Definition in\n         which the Image Version resides.\n        :type gallery_image_name: str\n        :param gallery_image_version_name: The name of the gallery Image\n         Version to be retrieved.\n        :type gallery_image_version_name: str\n        :param expand: The expand expression to apply on the operation.\n         Possible values include: 'ReplicationStatus'\n        :type expand: str or\n         ~azure.mgmt.compute.v2019_03_01.models.ReplicationStatusTypes\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: GalleryImageVersion or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.compute.v2019_03_01.models.GalleryImageVersion or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25375:c0:m3"}
{"signature": "def has_metadata(name):", "body": "", "docstring": "Does the package's distribution contain the named metadata?", "id": "f16923:c9:m0"}
{"signature": "def clear(self):", "body": "try:<EOL><INDENT>for node in self.__map.itervalues():<EOL><INDENT>del node[:]<EOL><DEDENT>root = self.__root<EOL>root[:] = [root, root, None]<EOL>self.__map.clear()<EOL><DEDENT>except AttributeError:<EOL><INDENT>pass<EOL><DEDENT>dict.clear(self)<EOL>", "docstring": "od.clear() -> None.  Remove all items from od.", "id": "f16971:c0:m5"}
{"signature": "def _maybe_assert_valid_sample(self, x):", "body": "if not self.validate_args:<EOL><INDENT>return x<EOL><DEDENT>return distribution_util.with_dependencies([<EOL>assert_util.assert_positive(x, message=\"<STR_LIT>\"),<EOL>assert_util.assert_near(<EOL>tf.ones([], dtype=self.dtype),<EOL>tf.reduce_sum(input_tensor=x, axis=-<NUM_LIT:1>),<EOL>message=\"<STR_LIT>\"),<EOL>], x)<EOL>", "docstring": "Checks the validity of a sample.", "id": "f15740:c0:m20"}
{"signature": "def _get_ip(self):", "body": "return self.__ip<EOL>", "docstring": "Getter method for ip, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/neighbors/neighbor/ip (leafref)\n\nYANG Description: References the configured IP address", "id": "f21945:c0:m2"}
{"signature": "def _set_graceful_restart(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=graceful_restart.graceful_restart,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__graceful_restart = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for graceful_restart, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/graceful_restart (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_graceful_restart is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_graceful_restart() directly.\n\nYANG Description: This container defines ISIS Graceful Restart.", "id": "f22506:c1:m18"}
{"signature": "def remove(self, name):", "body": "self.events.append(('<STR_LIT>', name))<EOL>", "docstring": "Get a remove event", "id": "f136:c0:m2"}
{"signature": "def take(a, indices, axis=None, out=None, mode='<STR_LIT>'):", "body": "try:<EOL><INDENT>take = a.take<EOL><DEDENT>except AttributeError:<EOL><INDENT>return _wrapit(a, '<STR_LIT>', indices, axis, out, mode)<EOL><DEDENT>return take(indices, axis, out, mode)<EOL>", "docstring": "Take elements from an array along an axis.\n\nThis function does the same thing as \"fancy\" indexing (indexing arrays\nusing arrays); however, it can be easier to use if you need elements\nalong a given axis.\n\nParameters\n----------\na : array_like\n    The source array.\nindices : array_like\n    The indices of the values to extract.\n\n    .. versionadded:: 1.8.0\n\n    Also allow scalars for indices.\naxis : int, optional\n    The axis over which to select values. By default, the flattened\n    input array is used.\nout : ndarray, optional\n    If provided, the result will be placed in this array. It should\n    be of the appropriate shape and dtype.\nmode : {'raise', 'wrap', 'clip'}, optional\n    Specifies how out-of-bounds indices will behave.\n\n    * 'raise' -- raise an error (default)\n    * 'wrap' -- wrap around\n    * 'clip' -- clip to the range\n\n    'clip' mode means that all indices that are too large are replaced\n    by the index that addresses the last element along that axis. Note\n    that this disables indexing with negative numbers.\n\nReturns\n-------\nsubarray : ndarray\n    The returned array has the same type as `a`.\n\nSee Also\n--------\ncompress : Take elements using a boolean mask\nndarray.take : equivalent method\n\nExamples\n--------\n>>> a = [4, 3, 5, 7, 6, 8]\n>>> indices = [0, 1, 4]\n>>> np.take(a, indices)\narray([4, 3, 6])\n\nIn this example if `a` is an ndarray, \"fancy\" indexing can be used.\n\n>>> a = np.array(a)\n>>> a[indices]\narray([4, 3, 6])\n\nIf `indices` is not one dimensional, the output also has these dimensions.\n\n>>> np.take(a, [[0, 1], [2, 3]])\narray([[4, 3],\n       [5, 7]])", "id": "f19044:m1"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/config (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_config is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_config() directly.\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23289:c0:m3"}
{"signature": "@property<EOL><INDENT>def num_seasons(self):<DEDENT>", "body": "return self._num_seasons<EOL>", "docstring": "Number of seasons.", "id": "f15501:c2:m2"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/config (container)\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23194:c0:m2"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/ipv4_interface_address/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of sub-TLV 6.", "id": "f22752:c0:m3"}
{"signature": "def _apply_rel_filters(self, queryset):", "body": "queryset._add_hints(instance=self.instance)<EOL>if self._db:<EOL><INDENT>queryset = queryset.using(self._db)<EOL><DEDENT>queryset = queryset.filter(**self.core_filters)<EOL>return queryset<EOL>", "docstring": "Filter the queryset for the instance this manager is bound to.", "id": "f21176:c16:m0"}
{"signature": "@_to_bits(<NUM_LIT:1>)<EOL>@_op_expand(<NUM_LIT:1>)<EOL>def z(self, q):", "body": "return self.append(ZGate(), [q], [])<EOL>", "docstring": "Apply Z to q.", "id": "f10843:m0"}
{"signature": "def CALL_FUNCTION_VAR(self,pc,argc):", "body": "raise NotImplementedError<EOL>", "docstring": "Calls a function. argc is interpreted as in CALL_FUNCTION. The top element on the stack contains the variable argument list, followed by keyword and positional arguments.", "id": "f19667:c3:m104"}
{"signature": "def _set_shutdown_threshold_pct(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__shutdown_threshold_pct = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for shutdown_threshold_pct, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/state/shutdown_threshold_pct (oc-types:percentage)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_shutdown_threshold_pct is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_shutdown_threshold_pct() directly.\n\n    YANG Description: Threshold on number of prefixes that can be received\nfrom a neighbour before generation of warning messages\nor log entries. Expressed as a percentage of\nmax-prefixes", "id": "f23295:c0:m9"}
{"signature": "def _set_link_attributes(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=link_attributes.link_attributes,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__link_attributes = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for link_attributes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/link_attributes (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_link_attributes is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_link_attributes() directly.\n\nYANG Description: This container defines link-attributes.", "id": "f22592:c1:m39"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters relating to multipath", "id": "f23204:c0:m6"}
{"signature": "async def disarm(self, code, partition_list):", "body": "_LOGGER.info(\"<STR_LIT>\")<EOL>while len(code) < <NUM_LIT:16>:<EOL><INDENT>code += '<STR_LIT:F>'<EOL><DEDENT>code_bytes = bytearray.fromhex(code)<EOL>data = generate_query(b'<STR_LIT>' + code_bytes<EOL>+ partition_bytes(partition_list))<EOL>await self._send_data(data)<EOL>", "docstring": "Send command to disarm.", "id": "f7103:c1:m9"}
{"signature": "def make_response(self, args, result):", "body": "return dumps({<EOL>'<STR_LIT>': '<STR_LIT>',<EOL>'<STR_LIT:id>': args['<STR_LIT:id>'],<EOL>'<STR_LIT:result>': result,<EOL>})<EOL>", "docstring": "Create response body from given result.", "id": "f11234:c0:m6"}
{"signature": "def _session_key(self, key):", "body": "return '<STR_LIT>'.format(self.settings.prefix, self.name, key)<EOL>", "docstring": "Generates session key string.\n\n:param str key:\n    e.g. ``\"authomatic:facebook:key\"``", "id": "f5370:c0:m13"}
{"signature": "def to_matrix(self):", "body": "return numpy.array([[<NUM_LIT:1>, <NUM_LIT:1>],<EOL>[<NUM_LIT:1>, -<NUM_LIT:1>]], dtype=complex) / numpy.sqrt(<NUM_LIT:2>)<EOL>", "docstring": "Return a Numpy.array for the H gate.", "id": "f10824:c0:m3"}
{"signature": "@_with_ast_loc_deps<EOL>def __multi_arity_fn_to_py_ast(  <EOL>ctx: GeneratorContext,<EOL>node: Fn,<EOL>methods: Collection[FnMethod],<EOL>def_name: Optional[str] = None,<EOL>meta_node: Optional[MetaNode] = None,<EOL>) -> GeneratedPyAST:", "body": "assert node.op == NodeOp.FN<EOL>assert all([method.op == NodeOp.FN_METHOD for method in methods])<EOL>lisp_fn_name = node.local.name if node.local is not None else None<EOL>py_fn_name = __fn_name(lisp_fn_name) if def_name is None else munge(def_name)<EOL>py_fn_node = ast.AsyncFunctionDef if node.is_async else ast.FunctionDef<EOL>arity_to_name = {}<EOL>rest_arity_name: Optional[str] = None<EOL>fn_defs = []<EOL>for method in methods:<EOL><INDENT>arity_name = f\"<STR_LIT>\"<EOL>if method.is_variadic:<EOL><INDENT>rest_arity_name = arity_name<EOL><DEDENT>else:<EOL><INDENT>arity_to_name[method.fixed_arity] = arity_name<EOL><DEDENT>with ctx.new_symbol_table(arity_name), ctx.new_recur_point(<EOL>method.loop_id, RecurType.FN, is_variadic=node.is_variadic<EOL>):<EOL><INDENT>if lisp_fn_name is not None:<EOL><INDENT>ctx.symbol_table.new_symbol(<EOL>sym.symbol(lisp_fn_name), py_fn_name, LocalType.FN<EOL>)<EOL><DEDENT>fn_args, varg, fn_body_ast = __fn_args_to_py_ast(<EOL>ctx, method.params, method.body<EOL>)<EOL>fn_defs.append(<EOL>py_fn_node(<EOL>name=arity_name,<EOL>args=ast.arguments(<EOL>args=fn_args,<EOL>kwarg=None,<EOL>vararg=varg,<EOL>kwonlyargs=[],<EOL>defaults=[],<EOL>kw_defaults=[],<EOL>),<EOL>body=fn_body_ast,<EOL>decorator_list=[_TRAMPOLINE_FN_NAME]<EOL>if ctx.recur_point.has_recur<EOL>else [],<EOL>returns=None,<EOL>)<EOL>)<EOL><DEDENT><DEDENT>dispatch_fn_ast = __multi_arity_dispatch_fn(<EOL>ctx,<EOL>py_fn_name,<EOL>arity_to_name,<EOL>default_name=rest_arity_name,<EOL>max_fixed_arity=node.max_fixed_arity,<EOL>meta_node=meta_node,<EOL>is_async=node.is_async,<EOL>)<EOL>return GeneratedPyAST(<EOL>node=dispatch_fn_ast.node,<EOL>dependencies=list(chain(fn_defs, dispatch_fn_ast.dependencies)),<EOL>)<EOL>", "docstring": "Return a Python AST node for a function with multiple arities.", "id": "f1067:m26"}
{"signature": "def _set_import_policy(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(allowed_type=six.text_type),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__import_policy = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for import_policy, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/apply_policy/state/import_policy (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_import_policy is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_import_policy() directly.\n\n    YANG Description: list of policy names in sequence to be applied on\nreceiving a routing update in the current context, e.g.,\nfor the current peer group, neighbor, address family,\netc.", "id": "f23249:c0:m3"}
{"signature": "@contextmanager<EOL>def add_field(field, filters: List[str]):", "body": "model = define_fake_model()<EOL>project = migrations.state.ProjectState.from_apps(apps)<EOL>with connection.schema_editor() as schema_editor:<EOL><INDENT>execute_migration(schema_editor, [<EOL>migrations.CreateModel(<EOL>model.__name__,<EOL>fields=[]<EOL>)<EOL>], project)<EOL><DEDENT>with filtered_schema_editor(*filters) as (schema_editor, calls):<EOL><INDENT>execute_migration(schema_editor, [<EOL>migrations.AddField(<EOL>model.__name__,<EOL>'<STR_LIT:title>',<EOL>field<EOL>)<EOL>], project)<EOL><DEDENT>yield calls<EOL>", "docstring": "Adds the specified field to a model.\n\n    Arguments:\n        field:\n            The field to add to a model.\n\n        filters:\n            List of strings to filter\n            SQL statements on.", "id": "f338:m4"}
{"signature": "def _get_ipv4_interface_addresses(self):", "body": "return self.__ipv4_interface_addresses<EOL>", "docstring": "Getter method for ipv4_interface_addresses, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv4_interface_addresses/state/ipv4_interface_addresses (inet:ipv4-prefix)\n\n    YANG Description: IPv4 address(es) of the interface corresponding to the SNPA\nover which this PDU is to be transmitted.", "id": "f22901:c1:m5"}
{"signature": "def verify_md5(md5_expected, data, other_errors=None):", "body": "<EOL>)<EOL>!= %r = received md5' \\ d5_recv))<EOL>", "docstring": "return True if okay, raise Exception if not", "id": "f17978:m2"}
{"signature": "@staticmethod<EOL><INDENT>def should_analyze_file(modname, path, is_argument=False):<DEDENT>", "body": "if is_argument:<EOL><INDENT>return True<EOL><DEDENT>return path.endswith(\"<STR_LIT>\")<EOL>", "docstring": "Returns whether or not a module should be checked.\n\n        This implementation returns True for all python source file, indicating\n        that all files should be linted.\n\n        Subclasses may override this method to indicate that modules satisfying\n        certain conditions should not be linted.\n\n        :param str modname: The name of the module to be checked.\n        :param str path: The full path to the source code of the module.\n        :param bool is_argument: Whetter the file is an argument to pylint or not.\n                                 Files which respect this property are always\n                                 checked, since the user requested it explicitly.\n        :returns: True if the module should be checked.\n        :rtype: bool", "id": "f18861:c0:m20"}
{"signature": "def _get_safi_name(self):", "body": "return self.__safi_name<EOL>", "docstring": "Getter method for safi_name, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af/safi_name (leafref)\n\nYANG Description: Reference to subsequent address-family type", "id": "f22441:c0:m5"}
{"signature": "def write(self):", "body": "file = open(self.config_file, \"<STR_LIT>\")<EOL>file.write(yaml.dump(dict(self), default_flow_style=False))<EOL>file.close()<EOL>", "docstring": "Write config in configuration file.\nData must me a dict.", "id": "f2020:c0:m4"}
{"signature": "def get_arguments(self):", "body": "ApiCli.get_arguments(self)<EOL>if self.args.metricName is not None:<EOL><INDENT>self.metricName = self.args.metricName<EOL><DEDENT>if self.args.measurement is not None:<EOL><INDENT>self.measurement = self.args.measurement<EOL><DEDENT>if self.args.source is not None:<EOL><INDENT>self.source = self.args.source<EOL><DEDENT>else:<EOL><INDENT>self.source = socket.gethostname()<EOL><DEDENT>if self.args.timestamp is not None:<EOL><INDENT>self.timestamp = int(self.args.timestamp)<EOL><DEDENT>m = {'<STR_LIT>': self.metricName,<EOL>'<STR_LIT>': self.measurement}<EOL>if self.source is not None:<EOL><INDENT>m['<STR_LIT:source>'] = self.source<EOL><DEDENT>if self.timestamp is not None:<EOL><INDENT>m['<STR_LIT>'] = int(self.timestamp)<EOL><DEDENT>self._process_properties()<EOL>if self._properties is not None:<EOL><INDENT>m['<STR_LIT>'] = self._properties<EOL><DEDENT>self.data = json.dumps(m, sort_keys=True)<EOL>self.headers = {'<STR_LIT:Content-Type>': '<STR_LIT:application/json>', \"<STR_LIT>\": \"<STR_LIT:application/json>\"}<EOL>", "docstring": "Extracts the specific arguments of this CLI", "id": "f16239:c0:m3"}
{"signature": "@_to_bits(<NUM_LIT:1>)<EOL>@_op_expand(<NUM_LIT:1>)<EOL>def u2(self, phi, lam, q):", "body": "return self.append(U2Gate(phi, lam), [q], [])<EOL>", "docstring": "Apply u2 to q.", "id": "f10820:m0"}
{"signature": "def _check_convergence(simplex,<EOL>best_vertex,<EOL>best_objective,<EOL>worst_objective,<EOL>func_tolerance,<EOL>position_tolerance):", "body": "objective_convergence = tf.abs(worst_objective -<EOL>best_objective) < func_tolerance<EOL>simplex_degeneracy = tf.reduce_max(<EOL>input_tensor=tf.abs(simplex - best_vertex)) < position_tolerance<EOL>return objective_convergence | simplex_degeneracy<EOL>", "docstring": "Returns True if the simplex has converged.\n\n    If the simplex size is smaller than the `position_tolerance` or the variation\n    of the function value over the vertices of the simplex is smaller than the\n    `func_tolerance` return True else False.\n\n    Args:\n      simplex: `Tensor` of real dtype. The simplex to test for convergence. For\n        more details, see the docstring for `initial_simplex` argument\n        of `minimize`.\n      best_vertex: `Tensor` of real dtype and rank one less than `simplex`. The\n        vertex with the best (i.e. smallest) objective value.\n      best_objective: Scalar `Tensor` of real dtype. The best (i.e. smallest)\n        value of the objective function at a vertex.\n      worst_objective: Scalar `Tensor` of same dtype as `best_objective`. The\n        worst (i.e. largest) value of the objective function at a vertex.\n      func_tolerance: Scalar positive `Tensor`. The tolerance for the variation\n        of the objective function value over the simplex. If the variation over\n        the simplex vertices is below this threshold, convergence is True.\n      position_tolerance: Scalar positive `Tensor`. The algorithm stops if the\n        lengths (under the supremum norm) of edges connecting to the best vertex\n        are below this threshold.\n\n    Returns:\n      has_converged: A scalar boolean `Tensor` indicating whether the algorithm\n        is deemed to have converged.", "id": "f15567:m8"}
{"signature": "def _get_priority(self):", "body": "return self.__priority<EOL>", "docstring": "Getter method for priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/config/priority (uint8)\n\n    YANG Description: The local system's priority to become the designated\nrouter", "id": "f23111:c1:m8"}
{"signature": "def nop(self, expression, progress=False, delay=False):", "body": "expression = _ensure_string_from_expression(expression)<EOL>def map(ar):<EOL><INDENT>pass<EOL><DEDENT>def reduce(a, b):<EOL><INDENT>pass<EOL><DEDENT>return self.map_reduce(map, reduce, [expression], delay=delay, progress=progress, name='<STR_LIT>', to_numpy=False)<EOL>", "docstring": "Evaluates expression, and drop the result, usefull for benchmarking, since vaex is usually lazy", "id": "f6914:c0:m13"}
{"signature": "def _set_name(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:name>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:string>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:string>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__name = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for name, mapped from YANG variable /system/aaa/server_groups/server_group/state/name (string)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_name is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_name() directly.\n\nYANG Description: Name for the server group", "id": "f21894:c0:m3"}
{"signature": "def as_dict(self):", "body": "d = {}<EOL>for key, value in self._internal:<EOL><INDENT>d.setdefault(key, []).append(value)<EOL><DEDENT>return d<EOL>", "docstring": "Return a copy of the comment data in a real dict.", "id": "f2173:c4:m8"}
{"signature": "def _truncate_float(matchobj, format_str='<STR_LIT>'):", "body": "if matchobj.group(<NUM_LIT:0>):<EOL><INDENT>return format(float(matchobj.group(<NUM_LIT:0>)), format_str)<EOL><DEDENT>return '<STR_LIT>'<EOL>", "docstring": "Truncate long floats\n\n    Args:\n        matchobj (re.Match): contains original float\n        format_str (str): format specifier\n    Returns:\n       str: returns truncated float", "id": "f10887:m1"}
{"signature": "def getMeterAddress(self):", "body": "return self.m_meter_address<EOL>", "docstring": "Getter for meter object 12 character address.\n\n        Returns:\n            str: 12 character address on front of meter", "id": "f2325:c29:m17"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/state/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: When set to true, the functionality within which this leaf is\ndefined is enabled, when set to false it is explicitly disabled.", "id": "f22524:c1:m3"}
{"signature": "def get_filename_safe_string(string):", "body": "invalid_filename_chars = ['<STR_LIT:\\\\>', '<STR_LIT:/>', '<STR_LIT::>', '<STR_LIT:\">', '<STR_LIT:*>', '<STR_LIT:?>', '<STR_LIT:|>', '<STR_LIT:\\n>',<EOL>'<STR_LIT:\\r>']<EOL>if string is None:<EOL><INDENT>string = \"<STR_LIT:None>\"<EOL><DEDENT>for char in invalid_filename_chars:<EOL><INDENT>string = string.replace(char, \"<STR_LIT>\")<EOL><DEDENT>string = string.rstrip(\"<STR_LIT:.>\")<EOL>return string<EOL>", "docstring": "Converts a string to a string that is safe for a filename\nArgs:\n    string (str): A string to make safe for a filename\n\nReturns:\n    str: A string safe for a filename", "id": "f15289:m12"}
{"signature": "def _change_resource_record_sets(self, change_set, comment=None):", "body": "body = xml_generators.change_resource_record_set_writer(<EOL>connection=self,<EOL>change_set=change_set,<EOL>comment=comment<EOL>)<EOL>root = self._send_request(<EOL>path='<STR_LIT>' % change_set.hosted_zone_id,<EOL>data=body,<EOL>method='<STR_LIT:POST>',<EOL>)<EOL>e_change_info = root.find('<STR_LIT>')<EOL>if e_change_info is None:<EOL><INDENT>error = root.find('<STR_LIT>').find('<STR_LIT>').text<EOL>raise Route53Error(error)<EOL><DEDENT>return parse_change_info(e_change_info)<EOL>", "docstring": "Given a ChangeSet, POST it to the Route53 API.\n\n.. note:: You probably shouldn't be using this method directly,\n    as there are convenience methods on the ResourceRecordSet\n    sub-classes.\n\n:param change_set.ChangeSet change_set: The ChangeSet object to create\n    the XML doc from.\n:keyword str comment: An optional comment to go along with the request.\n:rtype: dict\n:returns: A dict of change info, which contains some details about\n    the request.", "id": "f2399:c0:m8"}
{"signature": "def _all_get_or_create_table(self, where, tablename, description, expectedrows=None):", "body": "where_node = self._hdf5file.get_node(where)<EOL>if not tablename in where_node:<EOL><INDENT>if not expectedrows is None:<EOL><INDENT>table = self._hdf5file.create_table(where=where_node, name=tablename,<EOL>description=description, title=tablename,<EOL>expectedrows=expectedrows,<EOL>filters=self._all_get_filters())<EOL><DEDENT>else:<EOL><INDENT>table = self._hdf5file.create_table(where=where_node, name=tablename,<EOL>description=description, title=tablename,<EOL>filters=self._all_get_filters())<EOL><DEDENT><DEDENT>else:<EOL><INDENT>table = where_node._f_get_child(tablename)<EOL><DEDENT>return table<EOL>", "docstring": "Creates a new table, or if the table already exists, returns it.", "id": "f4214:c5:m54"}
{"signature": "def _set_up_down(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__up_down = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for up_down, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv4_external_reachability/prefixes/prefixes/state/up_down (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_up_down is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_up_down() directly.\n\n    YANG Description: The up/down bit. Set if a prefix is advertised from a higher level to\na lower level (e.g., level 2 to level 1), indicating that the prefix\nhas traveled down the hierarchy. Prefixes that have the up/down bit\nset may only be advertised down the hierarchy, i.e., to lower levels.\nWhen a prefix is first injected into IS-IS, the bit is UNSET.", "id": "f22549:c1:m3"}
{"signature": "def _get_validator(name, schema=None, check_schema=True,<EOL>validator_class=None, **validator_kwargs):", "body": "if schema is None:<EOL><INDENT>try:<EOL><INDENT>schema = _SCHEMAS[name]<EOL><DEDENT>except KeyError:<EOL><INDENT>raise SchemaValidationError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT><DEDENT>if name not in _VALIDATORS:<EOL><INDENT>if validator_class is None:<EOL><INDENT>validator_class = jsonschema.validators.validator_for(schema)<EOL><DEDENT>_VALIDATORS[name] = validator_class(schema, **validator_kwargs)<EOL><DEDENT>validator = _VALIDATORS[name]<EOL>if check_schema:<EOL><INDENT>validator.check_schema(schema)<EOL><DEDENT>return validator<EOL>", "docstring": "Generate validator for JSON schema.\n\n    Args:\n        name (str): Name for validator. Will be validator key in\n            `_VALIDATORS` dict.\n        schema (dict): JSON schema `dict`. If not provided searches for schema\n            in `_SCHEMAS`.\n        check_schema (bool): Verify schema is valid.\n        validator_class (jsonschema.IValidator): jsonschema IValidator instance.\n            Default behavior is to determine this from the schema `$schema`\n            field.\n        **validator_kwargs (dict): Additional keyword arguments for validator.\n\n    Return:\n        jsonschema.IValidator: Validator for JSON schema.\n\n    Raises:\n        SchemaValidationError: Raised if validation fails.", "id": "f10967:m1"}
{"signature": "def _get_delay(self):", "body": "return self.__delay<EOL>", "docstring": "Getter method for delay, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/link_delay/state/delay (uint32)\n\n    YANG Description: Average link delay value (in microseconds) between two directly\nconnected IS-IS neighbors over a configurable interval.", "id": "f22807:c1:m8"}
{"signature": "def to_str(self):", "body": "return pformat(self.to_dict())<EOL>", "docstring": "Returns the string representation of the model", "id": "f16322:c0:m12"}
{"signature": "def create_job(self, project_id, job, use_existing_job_fn=None):", "body": "request = self._mlengine.projects().jobs().create(<EOL>parent='<STR_LIT>'.format(project_id),<EOL>body=job)<EOL>job_id = job['<STR_LIT>']<EOL>try:<EOL><INDENT>request.execute()<EOL><DEDENT>except HttpError as e:<EOL><INDENT>if e.resp.status == <NUM_LIT>:<EOL><INDENT>if use_existing_job_fn is not None:<EOL><INDENT>existing_job = self._get_job(project_id, job_id)<EOL>if not use_existing_job_fn(existing_job):<EOL><INDENT>self.log.error(<EOL>'<STR_LIT>'<EOL>'<STR_LIT>',<EOL>job_id, existing_job<EOL>)<EOL>raise<EOL><DEDENT><DEDENT>self.log.info(<EOL>'<STR_LIT>',<EOL>job_id<EOL>)<EOL><DEDENT>else:<EOL><INDENT>self.log.error('<STR_LIT>'.format(e))<EOL>raise<EOL><DEDENT><DEDENT>return self._wait_for_job_done(project_id, job_id)<EOL>", "docstring": "Launches a MLEngine job and wait for it to reach a terminal state.\n\n:param project_id: The Google Cloud project id within which MLEngine\n    job will be launched.\n:type project_id: str\n\n:param job: MLEngine Job object that should be provided to the MLEngine\n    API, such as: ::\n\n        {\n          'jobId': 'my_job_id',\n          'trainingInput': {\n            'scaleTier': 'STANDARD_1',\n            ...\n          }\n        }\n\n:type job: dict\n\n:param use_existing_job_fn: In case that a MLEngine job with the same\n    job_id already exist, this method (if provided) will decide whether\n    we should use this existing job, continue waiting for it to finish\n    and returning the job object. It should accepts a MLEngine job\n    object, and returns a boolean value indicating whether it is OK to\n    reuse the existing job. If 'use_existing_job_fn' is not provided,\n    we by default reuse the existing MLEngine job.\n:type use_existing_job_fn: function\n\n:return: The MLEngine job object if the job successfully reach a\n    terminal state (which might be FAILED or CANCELLED state).\n:rtype: dict", "id": "f9151:c0:m2"}
{"signature": "def get_page(self):", "body": "return self.page<EOL>", "docstring": "Returns reference to current page object.", "id": "f3454:c0:m9"}
{"signature": "def generateRandom(self, size=<NUM_LIT:16>):", "body": "low_rand = ckbytelist([<NUM_LIT:0>] * size)<EOL>rv = self.lib.C_GenerateRandom(self.session, low_rand)<EOL>if rv != CKR_OK:<EOL><INDENT>raise PyKCS11Error(rv)<EOL><DEDENT>return low_rand<EOL>", "docstring": "C_GenerateRandom\n\n:param size: number of random bytes to get\n:type size: integer\n\n:note: the returned value is an instance of :class:`ckbytelist`.\n  You can easly convert it to a binary string with:\n  ``bytes(random)``\n  or, for Python 2:\n  ``''.join(chr(i) for i in random)``", "id": "f13454:c14:m30"}
{"signature": "@staticmethod<EOL><INDENT>def _prm_get_longest_stringsize(string_list):<DEDENT>", "body": "maxlength = <NUM_LIT:1><EOL>for stringar in string_list:<EOL><INDENT>if isinstance(stringar, np.ndarray):<EOL><INDENT>if stringar.ndim > <NUM_LIT:0>:<EOL><INDENT>for string in stringar.ravel():<EOL><INDENT>maxlength = max(len(string), maxlength)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>maxlength = max(len(stringar.tolist()), maxlength)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>maxlength = max(len(stringar), maxlength)<EOL><DEDENT><DEDENT>return int(maxlength * <NUM_LIT>)<EOL>", "docstring": "Returns the longest string size for a string entry across data.", "id": "f4214:c5:m90"}
{"signature": "def covariance(self, name=\"<STR_LIT>\", **kwargs):", "body": "with self._name_scope(name):<EOL><INDENT>return self._covariance(**kwargs)<EOL><DEDENT>", "docstring": "Covariance.\n\n        Covariance is (possibly) defined only for non-scalar-event distributions.\n\n        For example, for a length-`k`, vector-valued distribution, it is calculated\n        as,\n\n        ```none\n        Cov[i, j] = Covariance(X_i, X_j) = E[(X_i - E[X_i]) (X_j - E[X_j])]\n        ```\n\n        where `Cov` is a (batch of) `k x k` matrix, `0 <= (i, j) < k`, and `E`\n        denotes expectation.\n\n        Alternatively, for non-vector, multivariate distributions (e.g.,\n        matrix-valued, Wishart), `Covariance` shall return a (batch of) matrices\n        under some vectorization of the events, i.e.,\n\n        ```none\n        Cov[i, j] = Covariance(Vec(X)_i, Vec(X)_j) = [as above]\n        ```\n\n        where `Cov` is a (batch of) `k' x k'` matrices,\n        `0 <= (i, j) < k' = reduce_prod(event_shape)`, and `Vec` is some function\n        mapping indices of this distribution's event dimensions to indices of a\n        length-`k'` vector.\n\n        Args:\n          name: Python `str` prepended to names of ops created by this function.\n          **kwargs: Named arguments forwarded to subclass implementation.\n\n        Returns:\n          covariance: Floating-point `Tensor` with shape `[B1, ..., Bn, k', k']`\n            where the first `n` dimensions are batch coordinates and\n            `k' = reduce_prod(self.event_shape)`.", "id": "f15721:c2:m53"}
{"signature": "def _set_session_name(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:string>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:string>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__session_name = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for session_name, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/sessions/session/state/session_name (string)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_session_name is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_session_name() directly.\n\nYANG Description: The signaled name of this RSVP session.", "id": "f22307:c0:m18"}
{"signature": "def _get_instance(self):", "body": "return self.__instance<EOL>", "docstring": "Getter method for instance, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/config/instance (string)\n\nYANG Description: ISIS Instance.", "id": "f22501:c0:m5"}
{"signature": "def expm_cond(A, check_finite=True):", "body": "if check_finite:<EOL><INDENT>A = np.asarray_chkfinite(A)<EOL><DEDENT>else:<EOL><INDENT>A = np.asarray(A)<EOL><DEDENT>if len(A.shape) != <NUM_LIT:2> or A.shape[<NUM_LIT:0>] != A.shape[<NUM_LIT:1>]:<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>X = scipy.linalg.expm(A)<EOL>K = expm_frechet_kronform(A, check_finite=False)<EOL>A_norm = scipy.linalg.norm(A, '<STR_LIT>')<EOL>X_norm = scipy.linalg.norm(X, '<STR_LIT>')<EOL>K_norm = scipy.linalg.norm(K, <NUM_LIT:2>)<EOL>kappa = (K_norm * A_norm) / X_norm<EOL>return kappa<EOL>", "docstring": "Relative condition number of the matrix exponential in the Frobenius norm.\n\nParameters\n----------\nA : 2d array-like\n    Square input matrix with shape (N, N).\ncheck_finite : boolean, optional\n    Whether to check that the input matrix contains only finite numbers.\n    Disabling may give a performance gain, but may result in problems\n    (crashes, non-termination) if the inputs do contain infinities or NaNs.\n\nReturns\n-------\nkappa : float\n    The relative condition number of the matrix exponential\n    in the Frobenius norm\n\nNotes\n-----\nA faster estimate for the condition number in the 1-norm\nhas been published but is not yet implemented in scipy.\n\n.. versionadded:: 0.14.0\n\nSee also\n--------\nexpm : Compute the exponential of a matrix.\nexpm_frechet : Compute the Frechet derivative of the matrix exponential.", "id": "f19308:m9"}
{"signature": "def delete(<EOL>self, resource_group_name, server_name, database_name, schema_name, table_name, column_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", server_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", database_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", schema_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", table_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", column_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.sensitivity_label_source, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes the sensitivity label of a given column.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server.\n        :type server_name: str\n        :param database_name: The name of the database.\n        :type database_name: str\n        :param schema_name: The name of the schema.\n        :type schema_name: str\n        :param table_name: The name of the table.\n        :type table_name: str\n        :param column_name: The name of the column.\n        :type column_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38401:c0:m5"}
{"signature": "def get_network_configuration_diagnostic(<EOL>self, resource_group_name, network_watcher_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._get_network_configuration_diagnostic_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_watcher_name=network_watcher_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT:location>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Get network configuration diagnostic.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the network watcher.\n        :type network_watcher_name: str\n        :param parameters: Parameters to get network configuration diagnostic.\n        :type parameters:\n         ~azure.mgmt.network.v2018_11_01.models.NetworkConfigurationDiagnosticParameters\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         NetworkConfigurationDiagnosticResponse or\n         ClientRawResponse<NetworkConfigurationDiagnosticResponse> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_11_01.models.NetworkConfigurationDiagnosticResponse]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_11_01.models.NetworkConfigurationDiagnosticResponse]]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.network.v2018_11_01.models.ErrorResponseException>`", "id": "f32810:c0:m30"}
{"signature": "def isregex(value):", "body": "if not value:<EOL><INDENT>return False<EOL><DEDENT>return any((isregex_expr(value), isinstance(value, retype)))<EOL>", "docstring": "Returns ``True`` if the input argument object is a native\nregular expression object, otherwise ``False``.\n\nArguments:\n    value (mixed): input value to test.\n\nReturns:\n    bool", "id": "f11908:m1"}
{"signature": "def unwrap_span(self, tag):", "body": "tag.unwrap()<EOL>", "docstring": "Remove span tags while preserving contents.", "id": "f4980:c0:m8"}
{"signature": "def _get_aggregate_sid_counter(self):", "body": "return self.__aggregate_sid_counter<EOL>", "docstring": "Getter method for aggregate_sid_counter, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/segment_routing/aggregate_sid_counters/aggregate_sid_counter (list)\n\n    YANG Description: Counters aggregated across all of the interfaces of the local\nsystem corresponding to traffic received or forwarded with a\nparticular SID", "id": "f22343:c1:m2"}
{"signature": "def dump(obj, fp):", "body": "fp.write(dumps(obj))<EOL>", "docstring": "Serializes a dictionary into Manifest data and writes it to a file.\n:param obj: A dictionary to serialize.\n:param fp: A file object.", "id": "f2858:m2"}
{"signature": "def _get_bandwidth_reservation(self):", "body": "return self.__bandwidth_reservation<EOL>", "docstring": "Getter method for bandwidth_reservation, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/bandwidth_reservations/bandwidth_reservation (list)\n\n    YANG Description: Available and reserved bandwidth by priority on\nthe interface.", "id": "f22282:c1:m2"}
{"signature": "def _make_association(self, *args, **kwargs):", "body": "for o in self:<EOL><INDENT>o._make_association(*args, **kwargs)<EOL><DEDENT>", "docstring": "Delegate _make_association on items\n\n:note: doc in :func:`~hwt.synthesizer.interfaceLevel.propDeclCollector._make_association`", "id": "f1349:c0:m3"}
{"signature": "def vgg13_bn(pretrained=False, **kwargs):", "body": "if pretrained:<EOL><INDENT>kwargs['<STR_LIT>'] = False<EOL><DEDENT>model = VGG(make_layers(cfg['<STR_LIT:B>'], batch_norm=True), **kwargs)<EOL>if pretrained:<EOL><INDENT>model.load_state_dict(model_zoo.load_url(model_urls['<STR_LIT>']))<EOL><DEDENT>return model<EOL>", "docstring": "VGG 13-layer model (configuration \"B\") with batch normalization\n\n    Args:\n        pretrained (bool): If True, returns a model pre-trained on ImageNet", "id": "f3381:m4"}
{"signature": "def __imul__(self, other):", "body": "m = getmask(other)<EOL>if self._mask is nomask:<EOL><INDENT>if m is not nomask and m.any():<EOL><INDENT>self._mask = make_mask_none(self.shape, self.dtype)<EOL>self._mask += m<EOL><DEDENT><DEDENT>elif m is not nomask:<EOL><INDENT>self._mask += m<EOL><DEDENT>ndarray.__imul__(self._data, np.where(self._mask, <NUM_LIT:1>, getdata(other)))<EOL>return self<EOL>", "docstring": "Multiply self by other in-place.", "id": "f18992:c13:m45"}
{"signature": "def _get_push_label(self):", "body": "return self.__push_label<EOL>", "docstring": "Getter method for push_label, mapped from YANG variable /network_instances/network_instance/mpls/lsps/static_lsps/static_lsp/egress/config/push_label (oc-mplst:mpls-label)\n\n    YANG Description: label value to push at the current hop for the\nLSP", "id": "f22219:c0:m8"}
{"signature": "def get(<EOL>self, resource_group_name, network_security_group_name, default_security_rule_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", network_security_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", default_security_rule_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get the specified default network security rule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_security_group_name: The name of the network security\n         group.\n        :type network_security_group_name: str\n        :param default_security_rule_name: The name of the default security\n         rule.\n        :type default_security_rule_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: SecurityRule or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_02_01.models.SecurityRule or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f35264:c0:m2"}
{"signature": "def list_by_resource_group(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_resource_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualHubPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualHubPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all the VirtualHubs in a resource group.\n\n        :param resource_group_name: The resource group name of the VirtualHub.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualHub\n        :rtype:\n         ~azure.mgmt.network.v2018_04_01.models.VirtualHubPaged[~azure.mgmt.network.v2018_04_01.models.VirtualHub]\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_04_01.models.ErrorException>`", "id": "f33798:c0:m8"}
{"signature": "def write_output_prompt(self):", "body": "self.msg['<STR_LIT:content>']['<STR_LIT>'] = self.prompt_count<EOL>", "docstring": "Write the output prompt.", "id": "f21357:c1:m2"}
{"signature": "def get_argument(self, name, default=_ARG_DEFAULT, strip=True):", "body": "args = self.get_arguments(name, strip=strip)<EOL>if not args:<EOL><INDENT>if default is self._ARG_DEFAULT:<EOL><INDENT>raise HTTPError(<NUM_LIT>, \"<STR_LIT>\" % name)<EOL><DEDENT>return default<EOL><DEDENT>return args[-<NUM_LIT:1>]<EOL>", "docstring": "Returns the value of the argument with the given name.\n\n        If default is not provided, the argument is considered to be\n        required, and we throw an HTTP 400 exception if it is missing.\n\n        If the argument appears in the url more than once, we return the\n        last value.\n\n        The returned value is always unicode.", "id": "f12679:c4:m3"}
{"signature": "def compute_output_shape(self, input_shape):", "body": "input_shape = tf.TensorShape(input_shape).as_list()<EOL>if self.data_format == '<STR_LIT>':<EOL><INDENT>space = input_shape[<NUM_LIT:1>:-<NUM_LIT:1>]<EOL>new_space = []<EOL>for i in range(len(space)):<EOL><INDENT>new_dim = tf_layers_util.conv_output_length(<EOL>space[i],<EOL>self.kernel_size[i],<EOL>padding=self.padding,<EOL>stride=self.strides[i],<EOL>dilation=self.dilation_rate[i])<EOL>new_space.append(new_dim)<EOL><DEDENT>return tf.TensorShape([input_shape[<NUM_LIT:0>]] + new_space + [self.filters])<EOL><DEDENT>else:<EOL><INDENT>space = input_shape[<NUM_LIT:2>:]<EOL>new_space = []<EOL>for i in range(len(space)):<EOL><INDENT>new_dim = tf_layers_util.conv_output_length(<EOL>space[i],<EOL>self.kernel_size[i],<EOL>padding=self.padding,<EOL>stride=self.strides[i],<EOL>dilation=self.dilation_rate[i])<EOL>new_space.append(new_dim)<EOL><DEDENT>return tf.TensorShape([input_shape[<NUM_LIT:0>], self.filters] + new_space)<EOL><DEDENT>", "docstring": "Computes the output shape of the layer.\n\n        Args:\n          input_shape: Shape tuple (tuple of integers) or list of shape tuples\n            (one per output tensor of the layer). Shape tuples can include None for\n            free dimensions, instead of an integer.\n\n        Returns:\n          output_shape: A tuple representing the output shape.", "id": "f15818:c0:m3"}
{"signature": "def _logm(A):", "body": "A = np.asarray(A)<EOL>if len(A.shape) != <NUM_LIT:2> or A.shape[<NUM_LIT:0>] != A.shape[<NUM_LIT:1>]:<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>n = A.shape[<NUM_LIT:0>]<EOL>if issubclass(A.dtype.type, np.integer):<EOL><INDENT>A = np.asarray(A, dtype=float)<EOL><DEDENT>keep_it_real = np.isrealobj(A)<EOL>try:<EOL><INDENT>if np.array_equal(A, np.triu(A)):<EOL><INDENT>A = _logm_force_nonsingular_triangular_matrix(A)<EOL>if np.min(np.diag(A)) < <NUM_LIT:0>:<EOL><INDENT>A = A.astype(complex)<EOL><DEDENT>return _logm_triu(A)<EOL><DEDENT>else:<EOL><INDENT>if keep_it_real:<EOL><INDENT>T, Z = schur(A)<EOL>if not np.array_equal(T, np.triu(T)):<EOL><INDENT>T, Z = rsf2csf(T,Z)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>T, Z = schur(A, output='<STR_LIT>')<EOL><DEDENT>T = _logm_force_nonsingular_triangular_matrix(T, inplace=True)<EOL>U = _logm_triu(T)<EOL>ZH = np.conjugate(Z).T<EOL>return Z.dot(U).dot(ZH)<EOL><DEDENT><DEDENT>except (SqrtmError, LogmError) as e:<EOL><INDENT>X = np.empty_like(A)<EOL>X.fill(np.nan)<EOL>return X<EOL><DEDENT>", "docstring": "Compute the matrix logarithm.\n\nSee the logm docstring in matfuncs.py for more info.\n\nNotes\n-----\nIn this function we look at triangular matrices that are similar\nto the input matrix.  If any diagonal entry of such a triangular matrix\nis exactly zero then the original matrix is singular.\nThe matrix logarithm does not exist for such matrices,\nbut in such cases we will pretend that the diagonal entries that are zero\nare actually slightly positive by an ad-hoc amount, in the interest\nof returning something more useful than NaN.  This will cause a warning.", "id": "f19285:m13"}
{"signature": "def _modifies_cart(func):", "body": "@functools.wraps(func)<EOL>def inner(self, *a, **k):<EOL><INDENT>self._fail_if_cart_is_not_active()<EOL>with transaction.atomic():<EOL><INDENT>with BatchController.batch(self.cart.user):<EOL><INDENT>memoised = self.for_user(self.cart.user)<EOL>memoised._modified_by_batch = True<EOL>return func(self, *a, **k)<EOL><DEDENT><DEDENT><DEDENT>return inner<EOL>", "docstring": "Decorator that makes the wrapped function raise ValidationError\n    if we're doing something that could modify the cart.\n\n    It also wraps the execution of this function in a database transaction,\n    and marks the boundaries of a cart operations batch.", "id": "f17917:m0"}
{"signature": "def _set_link_protection_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=link_protection_type.link_protection_type,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__link_protection_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for link_protection_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/link_protection_type (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_link_protection_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_link_protection_type() directly.\n\n    YANG Description: ISIS LSDB parameters relating to the type of link protection\noffered.", "id": "f22592:c0:m42"}
{"signature": "@abstractmethod<EOL><INDENT>def next(self):<DEDENT>", "body": "raise StopIteration<EOL>", "docstring": "Return the next item from the iterator. When exhausted, raise StopIteration", "id": "f17319:c2:m0"}
{"signature": "def _get_available_bandwidth(self):", "body": "return self.__available_bandwidth<EOL>", "docstring": "Getter method for available_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/available_bandwidth (container)\n\nYANG Description: This container defines unidirectional lavailable bandwidth.", "id": "f22592:c1:m71"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/dynamic_neighbor_prefixes/dynamic_neighbor_prefix/config (container)\n\n    YANG Description: Configuration parameters relating to the source prefix\nfor the dynamic BGP neighbor connections.", "id": "f23381:c0:m5"}
{"signature": "def list_by_agent(<EOL>self, resource_group_name, server_name, job_agent_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_agent.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", server_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", job_agent_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.JobCredentialPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.JobCredentialPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a list of jobs credentials.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server.\n        :type server_name: str\n        :param job_agent_name: The name of the job agent.\n        :type job_agent_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of JobCredential\n        :rtype:\n         ~azure.mgmt.sql.models.JobCredentialPaged[~azure.mgmt.sql.models.JobCredential]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38383:c0:m1"}
{"signature": "def _set_l3vpn_ipv4_unicast(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=l3vpn_ipv4_unicast.l3vpn_ipv4_unicast,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__l3vpn_ipv4_unicast = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for l3vpn_ipv4_unicast, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_l3vpn_ipv4_unicast is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_l3vpn_ipv4_unicast() directly.\n\nYANG Description: Unicast IPv4 L3VPN configuration options", "id": "f23322:c0:m30"}
{"signature": "def _get_retransmit(self):", "body": "return self.__retransmit<EOL>", "docstring": "Getter method for retransmit, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/ish/state/retransmit (yang:counter32)\n\n    YANG Description: The number of the specified type of PDU that that have been\nretransmitted by the local system on the interface.", "id": "f22434:c0:m14"}
{"signature": "def derived(self, name, relative_coords, formula):", "body": "relZ, relN = relative_coords<EOL>daughter_idx = [(x[<NUM_LIT:0>] + relZ, x[<NUM_LIT:1>] + relN) for x in self.df.index]<EOL>values = formula(self.df.values, self.df.loc[daughter_idx].values)<EOL>return Table(df=pd.Series(values, index=self.df.index, name=name + '<STR_LIT:(>' + self.name + '<STR_LIT:)>'))<EOL>", "docstring": "Helper function for derived quantities", "id": "f5263:c0:m38"}
{"signature": "def _set_index(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:index>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:string>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:string>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__index = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for index, mapped from YANG variable /network_instances/network_instance/protocols/protocol/static_routes/static/next_hops/next_hop/config/index (string)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_index is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_index() directly.\n\n    YANG Description: An user-specified identifier utilised to uniquely reference\nthe next-hop entry in the next-hop list. The value of this\nindex has no semantic meaning other than for referencing\nthe entry.", "id": "f22386:c0:m3"}
{"signature": "def _tags_encode(self, tokens: List[str], tags: List[str], mean: bool) -> Union[List[np.ndarray], np.ndarray]:", "body": "embedded_tokens = np.array(self.embedder([tokens]))[<NUM_LIT:0>, :, :]<EOL>tags_weights = np.array([self.tags_vocab.get(tag, <NUM_LIT:1.0>) for tag in tags])<EOL>detokenized_sample = self.tokenizer([tokens])[<NUM_LIT:0>]  <EOL>vectorized_sample = self.vectorizer([detokenized_sample])  <EOL>if self.vectorizer:<EOL><INDENT>weights = np.array([vectorized_sample[<NUM_LIT:0>, np.where(self.vocabulary == token)[<NUM_LIT:0>][<NUM_LIT:0>]]<EOL>if len(np.where(self.vocabulary == token)[<NUM_LIT:0>]) else <NUM_LIT:0.><EOL>for token in tokens])<EOL><DEDENT>else:<EOL><INDENT>weights = np.array([self.get_weight(max(self.counter_vocab.get(token, <NUM_LIT:0>), self.idf_base_count))<EOL>for token in tokens])<EOL><DEDENT>weights = np.multiply(weights, tags_weights)<EOL>if sum(weights) == <NUM_LIT:0>:<EOL><INDENT>weights = np.ones(len(tokens))<EOL><DEDENT>if mean is None:<EOL><INDENT>mean = self.mean<EOL><DEDENT>if mean:<EOL><INDENT>embedded_tokens = np.average(embedded_tokens, weights=weights, axis=<NUM_LIT:0>)<EOL><DEDENT>else:<EOL><INDENT>embedded_tokens = np.array([weights[i] * embedded_tokens[i] for i in range(len(tokens))])<EOL><DEDENT>return embedded_tokens<EOL>", "docstring": "Embed one text sample\n\nArgs:\n    tokens: tokenized text sample\n    tags: tokenized tags sample\n    mean: whether to return mean token embedding (does not depend on self.mean)\n\nReturns:\n    list of embedded tokens or array of mean values", "id": "f3114:c0:m7"}
{"signature": "def _get_auth_password(self):", "body": "return self.__auth_password<EOL>", "docstring": "Getter method for auth_password, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/authentication/key/state/auth_password (oc-types:routing-password)\n\nYANG Description: Authentication key string.", "id": "f22970:c1:m2"}
{"signature": "def _do_post(self):", "body": "return requests.post(self._url, data=self._data, headers=self._headers, auth=(self._email, self._api_token))<EOL>", "docstring": "HTTP Post Request", "id": "f16204:c0:m18"}
{"signature": "@property<EOL><INDENT>def is_alive(self):<DEDENT>", "body": "if self.has_kernel:<EOL><INDENT>if self.kernel.poll() is None:<EOL><INDENT>return True<EOL><DEDENT>else:<EOL><INDENT>return False<EOL><DEDENT><DEDENT>elif self._hb_channel is not None:<EOL><INDENT>return self._hb_channel.is_beating()<EOL><DEDENT>else:<EOL><INDENT>return True<EOL><DEDENT>", "docstring": "Is the kernel process still running?", "id": "f21336:c6:m17"}
{"signature": "@property<EOL><INDENT>def has_skip_if(self):<DEDENT>", "body": "return self.skip_if is not None<EOL>", "docstring": "bool: Whether this rule has a value for which it should be skipped.", "id": "f16554:c0:m2"}
{"signature": "def add_pizza_to_basket(self, item, variant=VARIANT.MEDIUM, quantity=<NUM_LIT:1>):", "body": "item_variant = item[variant]<EOL>ingredients = item_variant['<STR_LIT>'].update([<NUM_LIT>, <NUM_LIT>])<EOL>params = {<EOL>'<STR_LIT>': <NUM_LIT:0>,<EOL>'<STR_LIT>': quantity,<EOL>'<STR_LIT>': variant,<EOL>'<STR_LIT>': item.item_id,<EOL>'<STR_LIT>': ingredients,<EOL>'<STR_LIT>': <NUM_LIT:0>,<EOL>'<STR_LIT>': [],<EOL>'<STR_LIT>': <NUM_LIT:0><EOL>}<EOL>return self.__post('<STR_LIT>', json=params)<EOL>", "docstring": "Add a pizza to the current basket.\n\n:param Item item: Item from menu.\n:param int variant: Item SKU id. Some defaults are defined in the VARIANT enum.\n:param int quantity: The quantity of pizza to be added.\n:return: A response having added a pizza to the current basket.\n:rtype: requests.Response", "id": "f1129:c0:m9"}
{"signature": "def _get_length(self):", "body": "return self.__length<EOL>", "docstring": "Getter method for length, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/undefined_subtlvs/undefined_subtlv/state/length (uint8)\n\nYANG Description: TLV length.", "id": "f22758:c0:m5"}
{"signature": "@GoogleCloudBaseHook.catch_http_exception<EOL><INDENT>def update_transfer_job(self, job_name, body):<DEDENT>", "body": "body = self._inject_project_id(body, BODY, PROJECT_ID)<EOL>return (<EOL>self.get_conn()<EOL>.transferJobs()<EOL>.patch(jobName=job_name, body=body)<EOL>.execute(num_retries=self.num_retries)<EOL>)<EOL>", "docstring": "Updates a transfer job that runs periodically.\n\n:param job_name: (Required) Name of the job to be updated\n:type job_name: str\n:param body: A request body, as described in\n    https://cloud.google.com/storage-transfer/docs/reference/rest/v1/transferJobs/patch#request-body\n:type body: dict\n:return: If successful, TransferJob.\n:rtype: dict", "id": "f9144:c2:m5"}
{"signature": "def getBatchSize(self):", "body": "return self.getOrDefault(self.batchSize)<EOL>", "docstring": "Gets the value of batchSize or its default value.", "id": "f13241:c0:m2"}
{"signature": "def db_list(username=None, password=None, host=None, port=None):", "body": "conn = _connection(username=username, password=password, host=host, port=port)<EOL>cur = conn.cursor()<EOL>cur.execute('<STR_LIT>')<EOL>rows = cur.fetchall()<EOL>conn.close()<EOL>result = []<EOL>for row in rows:<EOL><INDENT>result.append(row[<NUM_LIT:0>])<EOL><DEDENT>return result<EOL>", "docstring": "returns a list of all databases on this server", "id": "f3494:m2"}
{"signature": "def update(<EOL>self, resource_group_name, server_name, database_name, retention_days=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_initial(<EOL>resource_group_name=resource_group_name,<EOL>server_name=server_name,<EOL>database_name=database_name,<EOL>retention_days=retention_days,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Updates a database's short term retention policy.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server.\n        :type server_name: str\n        :param database_name: The name of the database.\n        :type database_name: str\n        :param retention_days: The backup retention period in days. This is\n         how many days Point-in-Time Restore will be supported.\n        :type retention_days: int\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         BackupShortTermRetentionPolicy or\n         ClientRawResponse<BackupShortTermRetentionPolicy> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.sql.models.BackupShortTermRetentionPolicy]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.sql.models.BackupShortTermRetentionPolicy]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38374:c0:m5"}
{"signature": "def remove_member(self, member_id):", "body": "return self.fetch_json(<EOL>uri_path=self.base_uri + '<STR_LIT>' % member_id,<EOL>http_method='<STR_LIT>'<EOL>)<EOL>", "docstring": "Remove a member from the organisation.Returns JSON of all members if\nsuccessful or raises an Unauthorised exception if not.", "id": "f12588:c0:m5"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/state (container)\n\nYANG Description: This container describes IS MT neighbor attribute state.", "id": "f22887:c0:m2"}
{"signature": "def get_versions(self, id):", "body": "return self.request(id, \"<STR_LIT>\", method=\"<STR_LIT>\").json()<EOL>", "docstring": "This endpoint reads information about all versions of a job.\n\n           https://www.nomadproject.io/docs/http/job.html\n\n            arguments:\n              - id\n            returns: list of dicts\n            raises:\n              - nomad.api.exceptions.BaseNomadException\n              - nomad.api.exceptions.URLNotFoundNomadException", "id": "f3528:c0:m7"}
{"signature": "def _get_in_hello_messages(self):", "body": "return self.__in_hello_messages<EOL>", "docstring": "Getter method for in_hello_messages, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/state/counters/in_hello_messages (yang:counter64)\n\nYANG Description: Number of received RSVP hello messages", "id": "f22284:c0:m20"}
{"signature": "def _best_version(fields):", "body": "def _has_marker(keys, markers):<EOL><INDENT>for marker in markers:<EOL><INDENT>if marker in keys:<EOL><INDENT>return True<EOL><DEDENT><DEDENT>return False<EOL><DEDENT>keys = []<EOL>for key, value in fields.items():<EOL><INDENT>if value in ([], '<STR_LIT>', None):<EOL><INDENT>continue<EOL><DEDENT>keys.append(key)<EOL><DEDENT>possible_versions = ['<STR_LIT:1.0>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']<EOL>for key in keys:<EOL><INDENT>if key not in _241_FIELDS and '<STR_LIT:1.0>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT:1.0>')<EOL><DEDENT>if key not in _314_FIELDS and '<STR_LIT>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT>')<EOL><DEDENT>if key not in _345_FIELDS and '<STR_LIT>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT>')<EOL><DEDENT>if key not in _426_FIELDS and '<STR_LIT>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT>')<EOL><DEDENT><DEDENT>if len(possible_versions) == <NUM_LIT:1>:<EOL><INDENT>return possible_versions[<NUM_LIT:0>]   <EOL><DEDENT>elif len(possible_versions) == <NUM_LIT:0>:<EOL><INDENT>raise MetadataConflictError('<STR_LIT>')<EOL><DEDENT>is_1_1 = '<STR_LIT>' in possible_versions and _has_marker(keys, _314_MARKERS)<EOL>is_1_2 = '<STR_LIT>' in possible_versions and _has_marker(keys, _345_MARKERS)<EOL>is_2_0 = '<STR_LIT>' in possible_versions and _has_marker(keys, _426_MARKERS)<EOL>if int(is_1_1) + int(is_1_2) + int(is_2_0) > <NUM_LIT:1>:<EOL><INDENT>raise MetadataConflictError('<STR_LIT>')<EOL><DEDENT>if not is_1_1 and not is_1_2 and not is_2_0:<EOL><INDENT>if PKG_INFO_PREFERRED_VERSION in possible_versions:<EOL><INDENT>return PKG_INFO_PREFERRED_VERSION<EOL><DEDENT><DEDENT>if is_1_1:<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>if is_1_2:<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>return '<STR_LIT>'<EOL>", "docstring": "Detect the best version depending on the fields used.", "id": "f17276:m1"}
{"signature": "def _set_sent(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__sent = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for sent, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/cnsp/state/sent (yang:counter32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_sent is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_sent() directly.\n\n    YANG Description: The number of the specified type of PDU that have been sent by the\nlocal system on the interface.", "id": "f22436:c0:m12"}
{"signature": "def process_fidelity(channel1, channel2, require_cptp=True):", "body": "<EOL>is_cptp1 = None<EOL>is_cptp2 = None<EOL>if isinstance(channel1, (list, np.ndarray)):<EOL><INDENT>channel1 = Operator(channel1)<EOL>if require_cptp:<EOL><INDENT>is_cptp1 = channel1.is_unitary()<EOL><DEDENT><DEDENT>if isinstance(channel2, (list, np.ndarray)):<EOL><INDENT>channel2 = Operator(channel2)<EOL>if require_cptp:<EOL><INDENT>is_cptp2 = channel2.is_unitary()<EOL><DEDENT><DEDENT>s1 = SuperOp(channel1)<EOL>s2 = SuperOp(channel2)<EOL>if require_cptp:<EOL><INDENT>if is_cptp1 is None:<EOL><INDENT>is_cptp1 = s1.is_cptp()<EOL><DEDENT>if not is_cptp1:<EOL><INDENT>raise QiskitError('<STR_LIT>')<EOL><DEDENT>if is_cptp2 is None:<EOL><INDENT>is_cptp2 = s2.is_cptp()<EOL><DEDENT>if not is_cptp2:<EOL><INDENT>raise QiskitError('<STR_LIT>')<EOL><DEDENT><DEDENT>input_dim1, output_dim1 = s1.dim<EOL>input_dim2, output_dim2 = s2.dim<EOL>if input_dim1 != output_dim1 or input_dim2 != output_dim2:<EOL><INDENT>raise QiskitError('<STR_LIT>')<EOL><DEDENT>if input_dim1 != input_dim2:<EOL><INDENT>raise QiskitError('<STR_LIT>')<EOL><DEDENT>fidelity = np.trace(s1.compose(s2.adjoint()).data) / (input_dim1 ** <NUM_LIT:2>)<EOL>return fidelity<EOL>", "docstring": "Return the process fidelity between two quantum channels.\n\n    This is given by\n\n        F_p(E1, E2) = Tr[S2^dagger.S1])/dim^2\n\n    where S1 and S2 are the SuperOp matrices for channels E1 and E2,\n    and dim is the dimension of the input output statespace.\n\n    Args:\n        channel1 (QuantumChannel or matrix): a quantum channel or unitary matrix.\n        channel2 (QuantumChannel or matrix): a quantum channel or unitary matrix.\n        require_cptp (bool): require input channels to be CPTP [Default: True].\n\n    Returns:\n        array_like: The state fidelity F(state1, state2).\n\n    Raises:\n        QiskitError: if inputs channels do not have the same dimensions,\n        have different input and output dimensions, or are not CPTP with\n        `require_cptp=True`.", "id": "f10792:m0"}
{"signature": "def assertProcessed(self, model, results, orig, expected_annotations=()):", "body": "self.assertEqual(len(results), len(orig))<EOL>for index, item in enumerate(results):<EOL><INDENT>orig_item = orig[index]<EOL>for annotation in expected_annotations:<EOL><INDENT>setattr(orig_item, *annotation)<EOL><DEDENT>for field in model._meta.fields:<EOL><INDENT>self.assertEqual(<EOL>getattr(item, field.attname),<EOL>getattr(orig_item, field.attname)<EOL>)<EOL>self.assertEqual(<EOL>type(getattr(item, field.attname)),<EOL>type(getattr(orig_item, field.attname))<EOL>)<EOL><DEDENT><DEDENT>", "docstring": "Compare the results of a raw query against expected results", "id": "f20992:c0:m2"}
{"signature": "def _get_virtual_address(self):", "body": "return self.__virtual_address<EOL>", "docstring": "Getter method for virtual_address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/virtual_address (inet:ip-address)\n\n    YANG Description: Configure one or more virtual addresses for the\nVRRP group", "id": "f21982:c0:m5"}
{"signature": "def _set_in_reservation_error_messages(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:64>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__in_reservation_error_messages = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for in_reservation_error_messages, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/state/counters/in_reservation_error_messages (yang:counter64)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_in_reservation_error_messages is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_in_reservation_error_messages() directly.\n\nYANG Description: Number of received RSVP Resv Error messages", "id": "f22284:c1:m15"}
{"signature": "def _set_received(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__received = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for received, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/esh/state/received (yang:counter32)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_received is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_received() directly.\n\nYANG Description: The number of the specified type of PDU received on the interface.", "id": "f22428:c0:m3"}
{"signature": "def __init__(self, input_dict=None):", "body": "self._p2v = {}<EOL>self._v2p = {}<EOL>if input_dict is not None:<EOL><INDENT>if not isinstance(input_dict, dict):<EOL><INDENT>raise LayoutError(\"<STR_LIT>\")<EOL><DEDENT>self.from_dict(input_dict)<EOL><DEDENT>", "docstring": "construct a Layout from a bijective dictionary, mapping\n        virtual qubits to physical qubits", "id": "f10899:c0:m0"}
{"signature": "def _set_max_prefixes(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__max_prefixes = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for max_prefixes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/state/max_prefixes (uint32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_max_prefixes is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_max_prefixes() directly.\n\n    YANG Description: Maximum number of prefixes that will be accepted\nfrom the neighbour", "id": "f23338:c0:m3"}
{"signature": "def in1d(ar1, ar2, assume_unique=False, invert=False):", "body": "<EOL>ar1 = np.asarray(ar1).ravel()<EOL>ar2 = np.asarray(ar2).ravel()<EOL>if len(ar2) < <NUM_LIT:10> * len(ar1) ** <NUM_LIT>:<EOL><INDENT>if invert:<EOL><INDENT>mask = np.ones(len(ar1), dtype=np.bool)<EOL>for a in ar2:<EOL><INDENT>mask &= (ar1 != a)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>mask = np.zeros(len(ar1), dtype=np.bool)<EOL>for a in ar2:<EOL><INDENT>mask |= (ar1 == a)<EOL><DEDENT><DEDENT>return mask<EOL><DEDENT>if not assume_unique:<EOL><INDENT>ar1, rev_idx = np.unique(ar1, return_inverse=True)<EOL>ar2 = np.unique(ar2)<EOL><DEDENT>ar = np.concatenate((ar1, ar2))<EOL>order = ar.argsort(kind='<STR_LIT>')<EOL>sar = ar[order]<EOL>if invert:<EOL><INDENT>bool_ar = (sar[<NUM_LIT:1>:] != sar[:-<NUM_LIT:1>])<EOL><DEDENT>else:<EOL><INDENT>bool_ar = (sar[<NUM_LIT:1>:] == sar[:-<NUM_LIT:1>])<EOL><DEDENT>flag = np.concatenate((bool_ar, [invert]))<EOL>indx = order.argsort(kind='<STR_LIT>')[:len(ar1)]<EOL>if assume_unique:<EOL><INDENT>return flag[indx]<EOL><DEDENT>else:<EOL><INDENT>return flag[indx][rev_idx]<EOL><DEDENT>", "docstring": "Test whether each element of a 1-D array is also present in a second array.\n\nReturns a boolean array the same length as `ar1` that is True\nwhere an element of `ar1` is in `ar2` and False otherwise.\n\nParameters\n----------\nar1 : (M,) array_like\n    Input array.\nar2 : array_like\n    The values against which to test each value of `ar1`.\nassume_unique : bool, optional\n    If True, the input arrays are both assumed to be unique, which\n    can speed up the calculation.  Default is False.\ninvert : bool, optional\n    If True, the values in the returned array are inverted (that is,\n    False where an element of `ar1` is in `ar2` and True otherwise).\n    Default is False. ``np.in1d(a, b, invert=True)`` is equivalent\n    to (but is faster than) ``np.invert(in1d(a, b))``.\n\n    .. versionadded:: 1.8.0\n\nReturns\n-------\nin1d : (M,) ndarray, bool\n    The values `ar1[in1d]` are in `ar2`.\n\nSee Also\n--------\nnumpy.lib.arraysetops : Module with a number of other functions for\n                        performing set operations on arrays.\n\nNotes\n-----\n`in1d` can be considered as an element-wise function version of the\npython keyword `in`, for 1-D sequences. ``in1d(a, b)`` is roughly\nequivalent to ``np.array([item in b for item in a])``.\n\n.. versionadded:: 1.4.0\n\nExamples\n--------\n>>> test = np.array([0, 1, 2, 5, 0])\n>>> states = [0, 2]\n>>> mask = np.in1d(test, states)\n>>> mask\narray([ True, False,  True, False,  True], dtype=bool)\n>>> test[mask]\narray([0, 2, 0])\n>>> mask = np.in1d(test, states, invert=True)\n>>> mask\narray([False,  True, False,  True, False], dtype=bool)\n>>> test[mask]\narray([1, 5])", "id": "f19129:m4"}
{"signature": "def __getitem__(self, idx):", "body": "return self._value[idx]<EOL>", "docstring": "Retrieve an item from a ``ListVariable`` instance.\n\n:param idx: The index or index-like object (e.g., slice) to\n            retrieve.\n\n:returns: The value at the designated index.", "id": "f1150:c1:m0"}
{"signature": "def delete(<EOL>self, resource_group_name, deployment_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>deployment_name=deployment_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes a deployment from the deployment history.\n\n        A template deployment that is currently running cannot be deleted.\n        Deleting a template deployment removes the associated deployment\n        operations. Deleting a template deployment does not affect the state of\n        the resource group. This is an asynchronous operation that returns a\n        status of 202 until the template deployment is successfully deleted.\n        The Location response header contains the URI that is used to obtain\n        the status of the process. While the process is running, a call to the\n        URI in the Location header returns a status of 202. When the process\n        finishes, the URI in the Location header returns a status of 204 on\n        success. If the asynchronous request failed, the URI in the Location\n        header returns an error-level status code.\n\n        :param resource_group_name: The name of the resource group with the\n         deployment to delete. The name is case insensitive.\n        :type resource_group_name: str\n        :param deployment_name: The name of the deployment to delete.\n        :type deployment_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37818:c0:m12"}
{"signature": "def _collect_section(self, section):", "body": "kwargs = {}<EOL>try:<EOL><INDENT>if self.parser.has_section(section):<EOL><INDENT>options = self.parser.options(section)<EOL>for option in options:<EOL><INDENT>str_val = self.parser.get(section, option)<EOL>val = ast.literal_eval(str_val)<EOL>kwargs[option] = val<EOL><DEDENT><DEDENT>return kwargs<EOL><DEDENT>except:<EOL><INDENT>raise<EOL><DEDENT>", "docstring": "Collects all settings within a section", "id": "f4226:c0:m1"}
{"signature": "def __len__(self):", "body": "return len(self.__data)<EOL>", "docstring": "Return size of queue", "id": "f14799:c4:m3"}
{"signature": "def logpmf(self, k, *args, **kwds):", "body": "args, loc, _ = self._parse_args(*args, **kwds)<EOL>k, loc = map(asarray, (k, loc))<EOL>args = tuple(map(asarray, args))<EOL>k = asarray((k-loc))<EOL>cond0 = self._argcheck(*args)<EOL>cond1 = (k >= self.a) & (k <= self.b) & self._nonzero(k, *args)<EOL>cond = cond0 & cond1<EOL>output = empty(shape(cond), '<STR_LIT:d>')<EOL>output.fill(NINF)<EOL>place(output, (<NUM_LIT:1>-cond0) + np.isnan(k), self.badvalue)<EOL>if any(cond):<EOL><INDENT>goodargs = argsreduce(cond, *((k,)+args))<EOL>place(output, cond, self._logpmf(*goodargs))<EOL><DEDENT>if output.ndim == <NUM_LIT:0>:<EOL><INDENT>return output[()]<EOL><DEDENT>return output<EOL>", "docstring": "Log of the probability mass function at k of the given RV.\n\nParameters\n----------\nk : array_like\n    Quantiles.\narg1, arg2, arg3,... : array_like\n    The shape parameter(s) for the distribution (see docstring of the\n    instance object for more information).\nloc : array_like, optional\n    Location parameter. Default is 0.\n\nReturns\n-------\nlogpmf : array_like\n    Log of the probability mass function evaluated at k.", "id": "f19688:c3:m9"}
{"signature": "def list_containers(self):", "body": "results = []<EOL>for image in self._bucket.list_blobs():<EOL><INDENT>if image.metadata is not None:<EOL><INDENT>if \"<STR_LIT:type>\" in image.metadata:<EOL><INDENT>if image.metadata['<STR_LIT:type>'] == \"<STR_LIT>\":<EOL><INDENT>results.append(image)<EOL><DEDENT><DEDENT><DEDENT><DEDENT>if len(results) == <NUM_LIT:0>:<EOL><INDENT>bot.info(\"<STR_LIT>\")<EOL><DEDENT>return results<EOL>", "docstring": "return a list of containers, determined by finding the metadata field\n       \"type\" with value \"container.\" We alert the user to no containers \n       if results is empty, and exit\n\n       {'metadata': {'items': \n                              [\n                               {'key': 'type', 'value': 'container'}, ... \n                              ]\n                    }\n       }", "id": "f9973:m1"}
{"signature": "@property<EOL><INDENT>def type(self):<DEDENT>", "body": "return self._json_data.get('<STR_LIT:type>')<EOL>", "docstring": "The event type (`created`, `updated`, `deleted`).", "id": "f10514:c0:m2"}
{"signature": "def _get_hide_transit_only_networks(self):", "body": "return self.__hide_transit_only_networks<EOL>", "docstring": "Getter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/global/state/hide_transit_only_networks (boolean)\n\n    YANG Description: When this leaf is set to true, do not advertise prefixes\ninto OSPFv2 that correspond to transit interfaces, as per\nthe behaviour discussed in RFC6860.", "id": "f23136:c0:m14"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/use_multiple_paths/config/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: Whether the use of multiple paths for the same NLRI is\nenabled for the neighbor. This value is overridden by\nany more specific configuration value.", "id": "f23241:c0:m3"}
{"signature": "def _get_connection_points(self):", "body": "return self.__connection_points<EOL>", "docstring": "Getter method for connection_points, mapped from YANG variable /network_instances/network_instance/connection_points (container)\n\n    YANG Description: The set of connection points within a forwarding\ninstance", "id": "f22362:c0:m29"}
{"signature": "def __call__(self, outputs):", "body": "output = outputs[self.output_name]<EOL>k = output.shape[-<NUM_LIT:1>]<EOL>n = TT.prod(output.shape) // k<EOL>prob = output.reshape((n, k))[TT.arange(n), self._target.reshape((n, ))]<EOL>nlp = -TT.log(TT.clip(prob, <NUM_LIT>, <NUM_LIT:1>))<EOL>if self._weights is not None:<EOL><INDENT>return (self._weights.reshape((n, )) * nlp).sum() / self._weights.sum()<EOL><DEDENT>return nlp.mean()<EOL>", "docstring": "Construct the computation graph for this loss function.\n\n        Parameters\n        ----------\n        outputs : dict of Theano expressions\n            A dictionary mapping network output names to Theano expressions\n            representing the outputs of a computation graph.\n\n        Returns\n        -------\n        loss : Theano expression\n            The values of the loss given the network output.", "id": "f7181:c6:m1"}
{"signature": "def _get_connect_retry(self):", "body": "return self.__connect_retry<EOL>", "docstring": "Getter method for connect_retry, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/timers/config/connect_retry (decimal64)\n\n    YANG Description: Time interval in seconds between attempts to establish a\nsession with the peer.", "id": "f23234:c0:m2"}
{"signature": "def list_available_custom_prebuilt_domains_for_culture(<EOL>self, culture, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list_available_custom_prebuilt_domains_for_culture.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", culture, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the available prebuilt domains for a specific culture.\n\n        :param culture: Culture.\n        :type culture: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: list or ClientRawResponse if raw=true\n        :rtype:\n         list[~azure.cognitiveservices.language.luis.authoring.models.PrebuiltDomain]\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException>`", "id": "f43230:c0:m20"}
{"signature": "def _get_interface(self):", "body": "return self.__interface<EOL>", "docstring": "Getter method for interface, mapped from YANG variable /network_instances/network_instance/fdb/mac_table/entries/entry/interface/interface_ref/state/interface (leafref)\n\n    YANG Description: Reference to a base interface.  If a reference to a\nsubinterface is required, this leaf must be specified\nto indicate the base interface.", "id": "f22100:c0:m2"}
{"signature": "def clear(self):", "body": "self._subscribers.clear()<EOL>", "docstring": "Unsubscribe everything, leaving the Broker without subscribers/events.", "id": "f10712:c0:m4"}
{"signature": "def _set_allow_multiple_as(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__allow_multiple_as = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for allow_multiple_as, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp/state/allow_multiple_as (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_allow_multiple_as is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_allow_multiple_as() directly.\n\n    YANG Description: Allow multipath to use paths from different neighbouring\nASes.  The default is to only consider multiple paths from\nthe same neighbouring AS.", "id": "f23246:c1:m3"}
{"signature": "def tag_list(self, tags):", "body": "return [<EOL>(tag.name, \"<STR_LIT>\" if tag.name in tags else \"<STR_LIT>\")<EOL>for tag in self.model.objects.all()<EOL>]<EOL>", "docstring": "Generates a list of tags identifying those previously selected.\n\nReturns a list of tuples of the form (<tag name>, <CSS class name>).\n\nUses the string names rather than the tags themselves in order to work\nwith tag lists built from forms not fully submitted.", "id": "f2278:c0:m2"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv4_reachability/prefixes/prefix/subTLVs/subTLVs/tag/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of sub-TLV 1.", "id": "f22694:c0:m3"}
{"signature": "@utils.check_messages(\"<STR_LIT>\")<EOL><INDENT>def visit_call(self, node):<DEDENT>", "body": "try:<EOL><INDENT>for inferred in node.func.infer():<EOL><INDENT>self._check_inferred_class_is_abstract(inferred, node)<EOL><DEDENT><DEDENT>except astroid.InferenceError:<EOL><INDENT>return<EOL><DEDENT>", "docstring": "Check instantiating abstract class with\n        abc.ABCMeta as metaclass.", "id": "f18869:c7:m17"}
{"signature": "def residual_plots(df, rep_stats=None, els=['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']):", "body": "<EOL>As = []<EOL>Rs = []<EOL>analytes = [c for c in df.columns if ('<STR_LIT>' not in c) and ('<STR_LIT>' not in c)]<EOL>ratios = [c for c in df.columns if ('<STR_LIT>' in c)]<EOL>for e in els:<EOL><INDENT>if e == '<STR_LIT>':<EOL><INDENT>As.append('<STR_LIT>')<EOL><DEDENT>elif e == '<STR_LIT>':<EOL><INDENT>As.append('<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>As.append([a for a in analytes if e in a][<NUM_LIT:0>])<EOL><DEDENT>Rs.append([r for r in ratios if e in r][<NUM_LIT:0>][:-<NUM_LIT:2>])<EOL><DEDENT>fig, axs = plt.subplots(len(els), <NUM_LIT:3>, figsize=(<NUM_LIT>, len(els) * <NUM_LIT:2>))<EOL>for i, (e, a) in enumerate(zip(Rs, As)):<EOL><INDENT>if a == '<STR_LIT>':<EOL><INDENT>m = <NUM_LIT><EOL>u = '<STR_LIT>'<EOL><DEDENT>else:<EOL><INDENT>m = <NUM_LIT:1><EOL>u = '<STR_LIT>'<EOL><DEDENT>tax, lax, hax = axs[i]<EOL>x = df.loc[:, e + '<STR_LIT>'].values * m<EOL>yt = df.loc[:, e + '<STR_LIT>'].values * m<EOL>yl = df.loc[:, a].values * m<EOL>rt = yt - x<EOL>rl = yl - x<EOL>tax.scatter(x, rt, c=element_colour(a), s=<NUM_LIT:15>, lw=<NUM_LIT:0.5>, edgecolor='<STR_LIT:k>', alpha=<NUM_LIT:0.5>)<EOL>lax.scatter(x, rl, c=element_colour(a), s=<NUM_LIT:15>, lw=<NUM_LIT:0.5>, edgecolor='<STR_LIT:k>', alpha=<NUM_LIT:0.5>)<EOL>rt = rt[~np.isnan(rt)]<EOL>rl = rl[~np.isnan(rl)]<EOL>lims = np.percentile(np.hstack([rt, rl]), [<NUM_LIT>, <NUM_LIT:1>])<EOL>lims += lims.ptp() * np.array((-<NUM_LIT>, <NUM_LIT>))<EOL>bins = np.linspace(*lims, <NUM_LIT:100>)<EOL>kdt = stats.gaussian_kde(rt, <NUM_LIT>)<EOL>kdl = stats.gaussian_kde(rl, <NUM_LIT>)<EOL>hax.fill_betweenx(bins, kdl(bins), facecolor=element_colour(a), alpha=<NUM_LIT>, edgecolor='<STR_LIT:k>', lw=<NUM_LIT:0.5>, label='<STR_LIT>')<EOL>hax.fill_betweenx(bins, kdt(bins), facecolor=element_colour(a), alpha=<NUM_LIT>, edgecolor='<STR_LIT:k>', lw=<NUM_LIT:0.5>, label='<STR_LIT>')<EOL>hax.set_xlim([<NUM_LIT:0>, hax.get_xlim()[-<NUM_LIT:1>]])<EOL>tax.set_ylabel(e + '<STR_LIT>'+ u + '<STR_LIT:)>')<EOL>tax.text(<NUM_LIT>,<NUM_LIT>,fmt_RSS(rt), fontsize=<NUM_LIT:8>,<EOL>ha='<STR_LIT:left>', va='<STR_LIT>', transform=tax.transAxes)<EOL>lax.text(<NUM_LIT>,<NUM_LIT>,fmt_RSS(rl), fontsize=<NUM_LIT:8>,<EOL>ha='<STR_LIT:left>', va='<STR_LIT>', transform=lax.transAxes)<EOL>xlim = np.percentile(x[~np.isnan(x)], [<NUM_LIT:0>, <NUM_LIT>])<EOL>for ax in [tax, lax]:<EOL><INDENT>ax.set_xlim(xlim)<EOL><DEDENT>for ax in axs[i]:<EOL><INDENT>ax.set_ylim(lims)<EOL>ax.axhline(<NUM_LIT:0>, c='<STR_LIT:k>', ls='<STR_LIT>', alpha=<NUM_LIT>)<EOL>if rep_stats is not None:<EOL><INDENT>ax.axhspan(-rep_stats[e][<NUM_LIT:0>] * <NUM_LIT:2>, rep_stats[e][<NUM_LIT:0>] * <NUM_LIT:2>, color=(<NUM_LIT:0>,<NUM_LIT:0>,<NUM_LIT:0>,<NUM_LIT>), zorder=-<NUM_LIT:1>)<EOL><DEDENT>if not ax.is_first_col():<EOL><INDENT>ax.set_yticklabels([])<EOL><DEDENT>if ax.is_last_row():<EOL><INDENT>hax.set_xlabel('<STR_LIT>')<EOL>tax.set_xlabel('<STR_LIT>')<EOL>lax.set_xlabel('<STR_LIT>')<EOL><DEDENT>if ax.is_first_row():<EOL><INDENT>tax.set_title('<STR_LIT>', loc='<STR_LIT:left>')<EOL>lax.set_title('<STR_LIT>', loc='<STR_LIT:left>')<EOL><DEDENT><DEDENT><DEDENT>fig.tight_layout()<EOL>return fig, axs<EOL>", "docstring": "Function for plotting Test User and LAtools data comparison.\n\nParameters\n----------\ndf : pandas.DataFrame\n    A dataframe containing reference ('X/Ca_r'), test user \n    ('X/Ca_t') and LAtools ('X123') data.\nrep_stats : dict\n    Reproducibility stats of the reference data produced by\n    `pairwise_reproducibility`\nels : list\n    list of elements (names only) to plot.", "id": "f2452:m5"}
{"signature": "def make_osm_query(query):", "body": "osm_url = '<STR_LIT>'<EOL>req = requests.get(osm_url, params={'<STR_LIT:data>': query})<EOL>req.raise_for_status()<EOL>return req.json()<EOL>", "docstring": "Make a request to OSM and return the parsed JSON.\n\nParameters\n----------\nquery : str\n    A string in the Overpass QL format.\n\nReturns\n-------\ndata : dict", "id": "f3881:m2"}
{"signature": "def read(self, input_buffer, kmip_version=enums.KMIPVersion.KMIP_1_0):", "body": "super(CreateKeyPairRequestPayload, self).read(<EOL>input_buffer,<EOL>kmip_version=kmip_version<EOL>)<EOL>local_buffer = utils.BytearrayStream(input_buffer.read(self.length))<EOL>if kmip_version < enums.KMIPVersion.KMIP_2_0:<EOL><INDENT>if self.is_tag_next(<EOL>enums.Tags.COMMON_TEMPLATE_ATTRIBUTE,<EOL>local_buffer<EOL>):<EOL><INDENT>self._common_template_attribute = objects.TemplateAttribute(<EOL>tag=enums.Tags.COMMON_TEMPLATE_ATTRIBUTE<EOL>)<EOL>self._common_template_attribute.read(<EOL>local_buffer,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if self.is_tag_next(enums.Tags.COMMON_ATTRIBUTES, local_buffer):<EOL><INDENT>attributes = objects.Attributes(<EOL>tag=enums.Tags.COMMON_ATTRIBUTES<EOL>)<EOL>attributes.read(local_buffer, kmip_version=kmip_version)<EOL>self._common_template_attribute =objects.convert_attributes_to_template_attribute(<EOL>attributes<EOL>)<EOL><DEDENT><DEDENT>if kmip_version < enums.KMIPVersion.KMIP_2_0:<EOL><INDENT>if self.is_tag_next(<EOL>enums.Tags.PRIVATE_KEY_TEMPLATE_ATTRIBUTE,<EOL>local_buffer<EOL>):<EOL><INDENT>self._private_key_template_attribute =objects.TemplateAttribute(<EOL>tag=enums.Tags.PRIVATE_KEY_TEMPLATE_ATTRIBUTE<EOL>)<EOL>self._private_key_template_attribute.read(<EOL>local_buffer,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if self.is_tag_next(<EOL>enums.Tags.PRIVATE_KEY_ATTRIBUTES,<EOL>local_buffer<EOL>):<EOL><INDENT>attributes = objects.Attributes(<EOL>tag=enums.Tags.PRIVATE_KEY_ATTRIBUTES<EOL>)<EOL>attributes.read(local_buffer, kmip_version=kmip_version)<EOL>self._private_key_template_attribute =objects.convert_attributes_to_template_attribute(<EOL>attributes<EOL>)<EOL><DEDENT><DEDENT>if kmip_version < enums.KMIPVersion.KMIP_2_0:<EOL><INDENT>if self.is_tag_next(<EOL>enums.Tags.PUBLIC_KEY_TEMPLATE_ATTRIBUTE,<EOL>local_buffer<EOL>):<EOL><INDENT>self._public_key_template_attribute =objects.TemplateAttribute(<EOL>tag=enums.Tags.PUBLIC_KEY_TEMPLATE_ATTRIBUTE<EOL>)<EOL>self._public_key_template_attribute.read(<EOL>local_buffer,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if self.is_tag_next(<EOL>enums.Tags.PUBLIC_KEY_ATTRIBUTES,<EOL>local_buffer<EOL>):<EOL><INDENT>attributes = objects.Attributes(<EOL>tag=enums.Tags.PUBLIC_KEY_ATTRIBUTES<EOL>)<EOL>attributes.read(local_buffer, kmip_version=kmip_version)<EOL>self._public_key_template_attribute =objects.convert_attributes_to_template_attribute(<EOL>attributes<EOL>)<EOL><DEDENT><DEDENT>self.is_oversized(local_buffer)<EOL>", "docstring": "Read the data encoding the CreateKeyPair request payload and decode it\ninto its constituent parts.\n\nArgs:\n    input_buffer (stream): A data buffer containing encoded object\n        data, supporting a read method.\n    kmip_version (KMIPVersion): An enumeration defining the KMIP\n        version with which the object will be decoded. Optional,\n        defaults to KMIP 1.0.", "id": "f15112:c0:m7"}
{"signature": "def random_describer():", "body": "return choice(get_describers())<EOL>", "docstring": "Return a 2-tuple, matching a describer to 'prefix' or 'suffix'.", "id": "f15325:m3"}
{"signature": "def _call_prob(self, value, name, **kwargs):", "body": "with self._name_scope(name):<EOL><INDENT>value = _convert_to_tensor(<EOL>value, name=\"<STR_LIT:value>\", dtype_hint=self.dtype)<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>return self._prob(value, **kwargs)<EOL><DEDENT>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>return tf.exp(self._log_prob(value, **kwargs))<EOL><DEDENT>raise NotImplementedError(\"<STR_LIT>\".format(<EOL>type(self).__name__))<EOL><DEDENT>", "docstring": "Wrapper around _prob.", "id": "f15721:c2:m29"}
{"signature": "def _get_level1_to_level2(self):", "body": "return self.__level1_to_level2<EOL>", "docstring": "Getter method for level1_to_level2, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/inter_level_propagation_policies/level1_to_level2 (container)\n\n    YANG Description: Policies relating to prefixes to be propagated from\nLevel 1 to Level 2.", "id": "f22500:c0:m2"}
{"signature": "def get_value(self, item, source_name):", "body": "val = item.get(source_name.encode('<STR_LIT:utf-8>'), None)<EOL>if val is not None:<EOL><INDENT>val = convert_string(val)<EOL><DEDENT>return val<EOL>", "docstring": "This method receives an item from the source and a source name,\nand returns the text content for the `source_name` node.", "id": "f2980:c0:m3"}
{"signature": "def get_count(self):", "body": "return self.wx_obj.GetCount()<EOL>", "docstring": "Returns the number of items in the control.", "id": "f17377:c0:m17"}
{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.DdosProtectionPlanPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.DdosProtectionPlanPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all DDoS protection plans in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of DdosProtectionPlan\n        :rtype:\n         ~azure.mgmt.network.v2018_10_01.models.DdosProtectionPlanPaged[~azure.mgmt.network.v2018_10_01.models.DdosProtectionPlan]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30280:c0:m6"}
{"signature": "@_to_bits(<NUM_LIT:2>)<EOL>@_op_expand(<NUM_LIT:2>)<EOL>def ch(self, ctl, tgt):", "body": "return self.append(CHGate(), [ctl, tgt], [])<EOL>", "docstring": "Apply CH from ctl to tgt.", "id": "f10829:m0"}
{"signature": "def to_esri_wkt(self):", "body": "string = '<STR_LIT>' % (self.name, self.geogcs.to_esri_wkt(), self.proj.to_esri_wkt() )<EOL>string += \"<STR_LIT:U+002CU+0020>\".join(param.to_esri_wkt() for param in self.params)<EOL>string += '<STR_LIT>' % self.unit.to_esri_wkt()<EOL>string += '<STR_LIT>' % (self.twin_ax[<NUM_LIT:0>].esri_wkt, self.twin_ax[<NUM_LIT:1>].esri_wkt )<EOL>return string<EOL>", "docstring": "Returns the CS as a ESRI WKT formatted string.", "id": "f2844:c2:m3"}
{"signature": "@log_calls<EOL><INDENT>def get_files(self, source, target):<DEDENT>", "body": "pool = ThreadPool(ThreadUtil, self.opt)<EOL>source = self.source_expand(source)<EOL>if os.path.isdir(target):<EOL><INDENT>for src in source:<EOL><INDENT>self.get_single_file(pool, src, os.path.join(target, self.get_basename(S3URL(src).path)))<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if len(source) > <NUM_LIT:1>:<EOL><INDENT>raise Failure('<STR_LIT>' % target)<EOL><DEDENT>elif len(source) == <NUM_LIT:1>:<EOL><INDENT>self.get_single_file(pool, source[<NUM_LIT:0>], target)<EOL><DEDENT>else:<EOL><INDENT>pass<EOL><DEDENT><DEDENT>pool.join()<EOL>", "docstring": "Download files.\n           This function can handle multiple files if source S3 URL has wildcard\n           characters. It also handles recursive mode by download all files and\n           keep the directory structure.", "id": "f16741:c8:m18"}
{"signature": "def t_MINUS(self, t):", "body": "t.endlexpos = t.lexpos + len(t.value)<EOL>return t<EOL>", "docstring": "r\"\\-", "id": "f14752:c65:m33"}
{"signature": "def _get_break_loop_node(break_node):", "body": "loop_nodes = (astroid.For, astroid.While)<EOL>parent = break_node.parent<EOL>while not isinstance(parent, loop_nodes) or break_node in getattr(<EOL>parent, \"<STR_LIT>\", []<EOL>):<EOL><INDENT>break_node = parent<EOL>parent = parent.parent<EOL>if parent is None:<EOL><INDENT>break<EOL><DEDENT><DEDENT>return parent<EOL>", "docstring": "Returns the loop node that holds the break node in arguments.\n\nArgs:\n    break_node (astroid.Break): the break node of interest.\n\nReturns:\n    astroid.For or astroid.While: the loop node holding the break node.", "id": "f18869:m3"}
{"signature": "def _format(self, object, stream, indent, allowance, context, level):", "body": "try:<EOL><INDENT>PrettyPrinter._format(self, object, stream, indent, allowance, context, level)<EOL><DEDENT>except Exception as e:<EOL><INDENT>stream.write(_format_exception(e))<EOL><DEDENT>", "docstring": "Recursive part of the formatting", "id": "f7468:c1:m2"}
{"signature": "def hermder(c, m=<NUM_LIT:1>, scl=<NUM_LIT:1>, axis=<NUM_LIT:0>):", "body": "c = np.array(c, ndmin=<NUM_LIT:1>, copy=<NUM_LIT:1>)<EOL>if c.dtype.char in '<STR_LIT>':<EOL><INDENT>c = c.astype(np.double)<EOL><DEDENT>cnt, iaxis = [int(t) for t in [m, axis]]<EOL>if cnt != m:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>if cnt < <NUM_LIT:0>:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>if iaxis != axis:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>if not -c.ndim <= iaxis < c.ndim:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>if iaxis < <NUM_LIT:0>:<EOL><INDENT>iaxis += c.ndim<EOL><DEDENT>if cnt == <NUM_LIT:0>:<EOL><INDENT>return c<EOL><DEDENT>c = np.rollaxis(c, iaxis)<EOL>n = len(c)<EOL>if cnt >= n:<EOL><INDENT>c = c[:<NUM_LIT:1>]*<NUM_LIT:0><EOL><DEDENT>else:<EOL><INDENT>for i in range(cnt):<EOL><INDENT>n = n - <NUM_LIT:1><EOL>c *= scl<EOL>der = np.empty((n,) + c.shape[<NUM_LIT:1>:], dtype=c.dtype)<EOL>for j in range(n, <NUM_LIT:0>, -<NUM_LIT:1>):<EOL><INDENT>der[j - <NUM_LIT:1>] = (<NUM_LIT:2>*j)*c[j]<EOL><DEDENT>c = der<EOL><DEDENT><DEDENT>c = np.rollaxis(c, <NUM_LIT:0>, iaxis + <NUM_LIT:1>)<EOL>return c<EOL>", "docstring": "Differentiate a Hermite series.\n\nReturns the Hermite series coefficients `c` differentiated `m` times\nalong `axis`.  At each iteration the result is multiplied by `scl` (the\nscaling factor is for use in a linear change of variable). The argument\n`c` is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series ``1*H_0 + 2*H_1 + 3*H_2``\nwhile [[1,2],[1,2]] represents ``1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) +\n2*H_0(x)*H_1(y) + 2*H_1(x)*H_1(y)`` if axis=0 is ``x`` and axis=1 is\n``y``.\n\nParameters\n----------\nc : array_like\n    Array of Hermite series coefficients. If `c` is multidimensional the\n    different axis correspond to different variables with the degree in\n    each axis given by the corresponding index.\nm : int, optional\n    Number of derivatives taken, must be non-negative. (Default: 1)\nscl : scalar, optional\n    Each differentiation is multiplied by `scl`.  The end result is\n    multiplication by ``scl**m``.  This is for use in a linear change of\n    variable. (Default: 1)\naxis : int, optional\n    Axis over which the derivative is taken. (Default: 0).\n\n    .. versionadded:: 1.7.0\n\nReturns\n-------\nder : ndarray\n    Hermite series of the derivative.\n\nSee Also\n--------\nhermint\n\nNotes\n-----\nIn general, the result of differentiating a Hermite series does not\nresemble the same operation on a power series. Thus the result of this\nfunction may be \"unintuitive,\" albeit correct; see Examples section\nbelow.\n\nExamples\n--------\n>>> from numpy.polynomial.hermite import hermder\n>>> hermder([ 1. ,  0.5,  0.5,  0.5])\narray([ 1.,  2.,  3.])\n>>> hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)\narray([ 1.,  2.,  3.])", "id": "f18934:m10"}
{"signature": "@classmethod<EOL><INDENT>def lookup_relativedelta_parameter(cls, unit_string):<DEDENT>", "body": "try:<EOL><INDENT>return cls._rdp_map()[unit_string.lower()]<EOL><DEDENT>except KeyError:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": ">>> lrp = Schedule.lookup_relativedelta_parameter\n>>> lrp('Years')\n'years'\n>>> lrp('yr')\n'years'\n>>> lrp('s')\n'seconds'", "id": "f2370:c1:m14"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkInterfacePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkInterfacePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all network interfaces in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkInterface\n        :rtype:\n         ~azure.mgmt.network.v2018_04_01.models.NetworkInterfacePaged[~azure.mgmt.network.v2018_04_01.models.NetworkInterface]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33816:c0:m9"}
{"signature": "def cluster_meanshift(data, bandwidth=None, bin_seeding=False, **kwargs):", "body": "if bandwidth is None:<EOL><INDENT>bandwidth = cl.estimate_bandwidth(data)<EOL><DEDENT>ms = cl.MeanShift(bandwidth=bandwidth, bin_seeding=bin_seeding, **kwargs)<EOL>ms.fit(data)<EOL>labels = ms.labels_<EOL>return labels, [np.nan]<EOL>", "docstring": "Identify clusters using Meanshift algorithm.\n\nParameters\n----------\ndata : array_like\n    array of size [n_samples, n_features].\nbandwidth : float or None\n    If None, bandwidth is estimated automatically using\n    sklean.cluster.estimate_bandwidth\nbin_seeding : bool\n    Setting this option to True will speed up the algorithm.\n    See sklearn documentation for full description.\n\nReturns\n-------\ndict\n    boolean array for each identified cluster.", "id": "f2435:m0"}
{"signature": "def run(self, options, args):", "body": "shells = COMPLETION_SCRIPTS.keys()<EOL>shell_options = ['<STR_LIT>' + shell for shell in sorted(shells)]<EOL>if options.shell in shells:<EOL><INDENT>script = COMPLETION_SCRIPTS.get(options.shell, '<STR_LIT>')<EOL>print(BASE_COMPLETION % {'<STR_LIT>': script, '<STR_LIT>': options.shell})<EOL><DEDENT>else:<EOL><INDENT>sys.stderr.write(<EOL>'<STR_LIT>' % '<STR_LIT>'.join(shell_options)<EOL>)<EOL><DEDENT>", "docstring": "Prints the completion code of the given shell", "id": "f17182:c0:m1"}
{"signature": "@property<EOL><INDENT>def centroid(self):<DEDENT>", "body": "return self.min_x + self.width * <NUM_LIT:0.5>, self.min_y + self.height * <NUM_LIT:0.5><EOL>", "docstring": "Returns the envelope centroid as a (x, y) tuple.", "id": "f1742:c0:m9"}
{"signature": "def get_headers(self):", "body": "headers = copy.copy(self.default_headers or {})<EOL>headers.update(self.data.get('<STR_LIT>') or {})<EOL>return headers<EOL>", "docstring": "Get HTTP Headers to send. By default default_headers\n\n        :return: HTTP Headers\n        :rtype: dict", "id": "f2823:c3:m4"}
{"signature": "def destroy(self):", "body": "", "docstring": "Destroy the transport", "id": "f14802:c1:m17"}
{"signature": "def in_method(var):", "body": "var = nomoreknown  <EOL>assert var<EOL>", "docstring": "method doc", "id": "f18386:m0"}
{"signature": "def score_function(self, x, W):<EOL>", "body": "score = self.theta(np.inner(x, W))<EOL>return score<EOL>", "docstring": "Score function to calculate score", "id": "f10097:c0:m6"}
{"signature": "def __getattr__(self, item):", "body": "if item == '<STR_LIT:data>':<EOL><INDENT>return self.f_get()<EOL><DEDENT>elif item == '<STR_LIT:default>':<EOL><INDENT>return self.f_get_default()<EOL><DEDENT>else:<EOL><INDENT>raise AttributeError('<STR_LIT>' % (self.f_get_class_name(),<EOL>item))<EOL><DEDENT>", "docstring": "Allows to query for `.data` as an attribute", "id": "f4239:c2:m6"}
{"signature": "def _get_default_metric(self):", "body": "return self.__default_metric<EOL>", "docstring": "Getter method for default_metric, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv4_external_reachability/prefixes/prefixes/default_metric (container)\n\nYANG Description: This container defines ISIS Default Metric.", "id": "f22554:c0:m5"}
{"signature": "def _set_current_priority(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=int, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}, int_size=<NUM_LIT:8><EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__current_priority = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for current_priority, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/addresses/address/vrrp/vrrp_group/state/current_priority (uint8)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_current_priority is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_current_priority() directly.\n\n    YANG Description: Operational value of the priority for the\ninterface in the VRRP group", "id": "f21982:c0:m24"}
{"signature": "@property<EOL><INDENT>def input_name(self):<DEDENT>", "body": "if len(self._input_shapes) != <NUM_LIT:1>:<EOL><INDENT>raise util.ConfigurationError(<EOL>'<STR_LIT>'<EOL>.format(self.name, self._input_shapes))<EOL><DEDENT>return list(self._input_shapes)[<NUM_LIT:0>]<EOL>", "docstring": "Name of layer input (for layers with one input).", "id": "f7173:c0:m2"}
{"signature": "def output_stream_passthrough(plugin, stream):", "body": "global output<EOL>title = create_title(plugin)<EOL>filename = '<STR_LIT>'.format(stream_to_url(stream))<EOL>output = PlayerOutput(args.player, args=args.player_args,<EOL>filename=filename, call=True,<EOL>quiet=not args.verbose_player,<EOL>title=title)<EOL>try:<EOL><INDENT>log.info(\"<STR_LIT>\", args.player)<EOL>output.open()<EOL><DEDENT>except OSError as err:<EOL><INDENT>console.exit(\"<STR_LIT>\", args.player, err)<EOL>return False<EOL><DEDENT>return True<EOL>", "docstring": "Prepares a filename to be passed to the player.", "id": "f8069:m6"}
{"signature": "def post(self, path='<STR_LIT>', **params):", "body": "params = jsonify_parameters(params)<EOL>url = ensure_trailing_slash(self.url + path.lstrip('<STR_LIT:/>'))<EOL>return self._json_request('<STR_LIT>', url, data=params)<EOL>", "docstring": "Make a POST request to the given path, and return the JSON-decoded\nresult.\n\nKeyword parameters will be converted to form values, sent in the body\nof the POST.\n\nPOST requests are requests that cause a change on the server,\nespecially those that ask to create and return an object of some kind.", "id": "f7061:c0:m8"}
{"signature": "def readlines(self, sizehint=None, keepends=True):", "body": "data = self.read()<EOL>return data.splitlines(keepends)<EOL>", "docstring": "Read all lines available on the input stream\n            and return them as list of lines.\n\n            Line breaks are implemented using the codec's decoder\n            method and are included in the list entries.\n\n            sizehint, if given, is ignored since there is no efficient\n            way to finding the true end-of-line.", "id": "f16912:c7:m4"}
{"signature": "def get_field(self, field_name, args, kwargs):", "body": "try:<EOL><INDENT>s = super(CustomFormatter, self)<EOL>return s.get_field(field_name, args, kwargs)<EOL><DEDENT>except KeyError:    <EOL><INDENT>return (\"<STR_LIT:_>\", field_name)<EOL><DEDENT>except IndexError:  <EOL><INDENT>return (\"<STR_LIT:_>\", field_name)<EOL><DEDENT>", "docstring": "Return an underscore if the attribute is absent.\nNot all components have the same attributes.", "id": "f7580:c0:m1"}
{"signature": "def path(self, *names):", "body": "path = [self]<EOL>for name in names:<EOL><INDENT>path.append(path[-<NUM_LIT:1>][name, ])<EOL><DEDENT>return path[<NUM_LIT:1>:]<EOL>", "docstring": "Look up and return the complete path of an atom.\n\n        For example, atoms.path('moov', 'udta', 'meta') will return a\n        list of three atoms, corresponding to the moov, udta, and meta\n        atoms.", "id": "f2193:c7:m1"}
{"signature": "def _get_area_address(self):", "body": "return self.__area_address<EOL>", "docstring": "Getter method for area_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area_address (oc-isis-types:area-address)\n\nYANG Description: List of ISIS area-address(es).", "id": "f22419:c0:m56"}
{"signature": "def advance(self):", "body": "self.current += self.step<EOL>", "docstring": "Advances the generator without creating a key.", "id": "f11419:c1:m3"}
{"signature": "async def set_repeat(self, state, *, device: Optional[SomeDevice] = None):", "body": "await self._user.http.repeat_playback(state, device_id=str(device))<EOL>", "docstring": "Set the repeat mode for the user\u2019s playback.\n\n        Parameters\n        ----------\n        state : str\n            Options are repeat-track, repeat-context, and off\n        device : Optional[:obj:`SomeDevice`]\n            The Device object or id of the device this command is targeting.\n            If not supplied, the user\u2019s currently active device is the target.", "id": "f13362:c0:m6"}
{"signature": "def class_name(obj):", "body": "return type(obj).__name__<EOL>", "docstring": "Returns the class name of the object.", "id": "f1256:m0"}
{"signature": "def _get_max_prefixes(self):", "body": "return self.__max_prefixes<EOL>", "docstring": "Getter method for max_prefixes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/state/max_prefixes (uint32)\n\n    YANG Description: Maximum number of prefixes that will be accepted\nfrom the neighbour", "id": "f23224:c0:m2"}
{"signature": "def _get_secondary_path(self):", "body": "return self.__secondary_path<EOL>", "docstring": "Getter method for secondary_path, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_primary_path/p2p_primary_path/candidate_secondary_paths/candidate_secondary_path/state/secondary_path (leafref)\n\n    YANG Description: A reference to the secondary path that should be utilised\nwhen the containing primary path option is in use", "id": "f22265:c0:m2"}
{"signature": "def _compute_peaks_or_valleys_of_first_derivative(s, do_peaks=True):", "body": "<EOL>gradient = np.nan_to_num(np.apply_along_axis(np.gradient, <NUM_LIT:1>, s), copy=False)<EOL>threshold = np.squeeze(np.nanmean(gradient, axis=<NUM_LIT:1>) + np.nanstd(gradient, axis=<NUM_LIT:1>))<EOL>half_window = <NUM_LIT:4><EOL>if do_peaks:<EOL><INDENT>indexes = [signal.argrelextrema(gradient[i, :], np.greater, order=half_window)[<NUM_LIT:0>] for i in range(gradient.shape[<NUM_LIT:0>])]<EOL><DEDENT>else:<EOL><INDENT>indexes = [signal.argrelextrema(gradient[i, :], np.less, order=half_window)[<NUM_LIT:0>] for i in range(gradient.shape[<NUM_LIT:0>])]<EOL><DEDENT>extrema = np.zeros(s.shape)<EOL>for row_index, index_array in enumerate(indexes):<EOL><INDENT>for col_index in index_array:<EOL><INDENT>if do_peaks and (gradient[row_index, col_index] > threshold[row_index]):<EOL><INDENT>extrema[row_index, col_index] = <NUM_LIT:1><EOL><DEDENT>elif not do_peaks:<EOL><INDENT>extrema[row_index, col_index] = <NUM_LIT:1><EOL><DEDENT><DEDENT><DEDENT>return extrema, gradient<EOL>", "docstring": "Takes a spectrogram and returns a 2D array of the form:\n\n0 0 0 1 0 0 1 0 0 0 1   <-- Frequency 0\n0 0 1 0 0 0 0 0 0 1 0   <-- Frequency 1\n0 0 0 0 0 0 1 0 1 0 0   <-- Frequency 2\n*** Time axis *******\n\nWhere a 1 means that the value in that time bin in the spectrogram corresponds to\na peak/valley in the first derivative.\n\nThis function is used as part of the ASA algorithm and is not meant to be used publicly.", "id": "f6457:m6"}
{"signature": "def _get_origin(self):", "body": "return self.__origin<EOL>", "docstring": "Getter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/neighbors/neighbor/state/origin (neighbor-origin)\n\nYANG Description: The origin of this neighbor entry, static or dynamic.", "id": "f22006:c0:m8"}
{"signature": "def issue(self, issue_id):", "body": "path = urijoin(\"<STR_LIT>\", str(issue_id))<EOL>url_issue = self.__get_url(path)<EOL>raw_text = self.__send_request(url_issue)<EOL>return raw_text<EOL>", "docstring": "Get the issue data by its ID", "id": "f13178:c1:m4"}
{"signature": "@property<EOL><INDENT>def v_standard_leaf(self):<DEDENT>", "body": "return self._standard_leaf<EOL>", "docstring": "The standard constructor used if you add a generic leaf.\n\n        The constructor is only used if you do not add items under the usual four subtrees\n        (`parameters`, `derived_parameters`, `config`, `results`).", "id": "f4238:c0:m94"}
{"signature": "def schedule(self, schedule_time, *messages):", "body": "for message in messages:<EOL><INDENT>if not self.session_id and not message.properties.group_id:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT><DEDENT>return super(SessionSender, self).schedule(schedule_time, *messages)<EOL>", "docstring": "Send one or more messages to be enqueued at a specific time.\n\n        Returns a list of the sequence numbers of the enqueued messages.\n\n        :param schedule_time: The date and time to enqueue the messages.\n        :type schedule_time: ~datetime.datetime\n        :param messages: The messages to schedule.\n        :type messages: ~azure.servicebus.common.message.Message\n        :rtype: list[int]\n\n        Example:\n            .. literalinclude:: ../examples/test_examples.py\n                :start-after: [START scheduling_messages]\n                :end-before: [END scheduling_messages]\n                :language: python\n                :dedent: 4\n                :caption: Schedule a message to be sent in future", "id": "f39504:c1:m2"}
{"signature": "def create(<EOL>self, resource_group_name, network_watcher_name, packet_capture_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_watcher_name=network_watcher_name,<EOL>packet_capture_name=packet_capture_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Create and start a packet capture on the specified VM.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the network watcher.\n        :type network_watcher_name: str\n        :param packet_capture_name: The name of the packet capture session.\n        :type packet_capture_name: str\n        :param parameters: Parameters that define the create packet capture\n         operation.\n        :type parameters: ~azure.mgmt.network.v2017_03_01.models.PacketCapture\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns PacketCaptureResult or\n         ClientRawResponse<PacketCaptureResult> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_03_01.models.PacketCaptureResult]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_03_01.models.PacketCaptureResult]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31194:c0:m2"}
{"signature": "def _get_endpoint_id(self):", "body": "return self.__endpoint_id<EOL>", "docstring": "Getter method for endpoint_id, mapped from YANG variable /network_instances/network_instance/connection_points/connection_point/endpoints/endpoint/endpoint_id (leafref)\n\n    YANG Description: A pointer to the configured identifier for the\nendpoint", "id": "f22352:c1:m2"}
{"signature": "def t_address(self, s):", "body": "pos = self.pos<EOL>self.add_token('<STR_LIT>', s)<EOL>self.pos = pos + len(s)<EOL>", "docstring": "r'[*]\\d+", "id": "f7413:c1:m12"}
{"signature": "def get_state_exitcode_details(self, resource_group, name):", "body": "current_state = self._get_instance_view(resource_group, name).current_state<EOL>return (current_state.state,<EOL>current_state.exit_code,<EOL>current_state.detail_status)<EOL>", "docstring": "Get the state and exitcode of a container group\n\n:param resource_group: the name of the resource group\n:type resource_group: str\n:param name: the name of the container group\n:type name: str\n:return: A tuple with the state, exitcode, and details.\n    If the exitcode is unknown 0 is returned.\n:rtype: tuple(state,exitcode,details)", "id": "f9188:c0:m3"}
{"signature": "def list(<EOL>self, resource_group_name, network_watcher_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", network_watcher_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ConnectionMonitorResultPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ConnectionMonitorResultPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all connection monitors for the specified Network Watcher.\n\n        :param resource_group_name: The name of the resource group containing\n         Network Watcher.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the Network Watcher resource.\n        :type network_watcher_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ConnectionMonitorResult\n        :rtype:\n         ~azure.mgmt.network.v2018_02_01.models.ConnectionMonitorResultPaged[~azure.mgmt.network.v2018_02_01.models.ConnectionMonitorResult]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f35262:c0:m12"}
{"signature": "def report(self, morfs, outfile=None):", "body": "self.find_code_units(morfs)<EOL>max_name = max([len(cu.name) for cu in self.code_units] + [<NUM_LIT:5>])<EOL>fmt_name = \"<STR_LIT>\" % max_name<EOL>fmt_err = \"<STR_LIT>\"<EOL>header = (fmt_name % \"<STR_LIT:Name>\") + \"<STR_LIT>\"<EOL>fmt_coverage = fmt_name + \"<STR_LIT>\"<EOL>if self.branches:<EOL><INDENT>header += \"<STR_LIT>\"<EOL>fmt_coverage += \"<STR_LIT>\"<EOL><DEDENT>width100 = Numbers.pc_str_width()<EOL>header += \"<STR_LIT>\" % (width100+<NUM_LIT:4>, \"<STR_LIT>\")<EOL>fmt_coverage += \"<STR_LIT>\" % (width100+<NUM_LIT:3>,)<EOL>if self.config.show_missing:<EOL><INDENT>header += \"<STR_LIT>\"<EOL>fmt_coverage += \"<STR_LIT>\"<EOL><DEDENT>rule = \"<STR_LIT:->\" * len(header) + \"<STR_LIT:\\n>\"<EOL>header += \"<STR_LIT:\\n>\"<EOL>fmt_coverage += \"<STR_LIT:\\n>\"<EOL>if not outfile:<EOL><INDENT>outfile = sys.stdout<EOL><DEDENT>outfile.write(header)<EOL>outfile.write(rule)<EOL>total = Numbers()<EOL>for cu in self.code_units:<EOL><INDENT>try:<EOL><INDENT>analysis = self.coverage._analyze(cu)<EOL>nums = analysis.numbers<EOL>args = (cu.name, nums.n_statements, nums.n_missing)<EOL>if self.branches:<EOL><INDENT>args += (nums.n_branches, nums.n_missing_branches)<EOL><DEDENT>args += (nums.pc_covered_str,)<EOL>if self.config.show_missing:<EOL><INDENT>args += (analysis.missing_formatted(),)<EOL><DEDENT>outfile.write(fmt_coverage % args)<EOL>total += nums<EOL><DEDENT>except KeyboardInterrupt:                   <EOL><INDENT>raise<EOL><DEDENT>except:<EOL><INDENT>report_it = not self.config.ignore_errors<EOL>if report_it:<EOL><INDENT>typ, msg = sys.exc_info()[:<NUM_LIT:2>]<EOL>if typ is NotPython and not cu.should_be_python():<EOL><INDENT>report_it = False<EOL><DEDENT><DEDENT>if report_it:<EOL><INDENT>outfile.write(fmt_err % (cu.name, typ.__name__, msg))<EOL><DEDENT><DEDENT><DEDENT>if total.n_files > <NUM_LIT:1>:<EOL><INDENT>outfile.write(rule)<EOL>args = (\"<STR_LIT>\", total.n_statements, total.n_missing)<EOL>if self.branches:<EOL><INDENT>args += (total.n_branches, total.n_missing_branches)<EOL><DEDENT>args += (total.pc_covered_str,)<EOL>if self.config.show_missing:<EOL><INDENT>args += (\"<STR_LIT>\",)<EOL><DEDENT>outfile.write(fmt_coverage % args)<EOL><DEDENT>return total.pc_covered<EOL>", "docstring": "Writes a report summarizing coverage statistics per module.\n\n        `outfile` is a file object to write the summary to.", "id": "f17087:c0:m1"}
{"signature": "@property<EOL><INDENT>def cdn_url(self):<DEDENT>", "body": "return '<STR_LIT>'.format(<EOL>cdn_base=conf.cdn_base,<EOL>group_id=self.id<EOL>)<EOL>", "docstring": "Returns group's CDN url.\n\n        Usage example::\n\n            >>> file_group = FileGroup('0513dda0-582f-447d-846f-096e5df9e2bb~2')\n            >>> file_group.cdn_url\n            https://ucarecdn.com/0513dda0-582f-447d-846f-096e5df9e2bb~2/", "id": "f427:c1:m7"}
{"signature": "@abc.abstractmethod<EOL><INDENT>def one_step(self, current_state, previous_kernel_results):<DEDENT>", "body": "raise NotImplementedError()<EOL>", "docstring": "Takes one step of the TransitionKernel.\n\n        Must be overridden by subclasses.\n\n        Args:\n          current_state: `Tensor` or Python `list` of `Tensor`s representing the\n            current state(s) of the Markov chain(s).\n          previous_kernel_results: A (possibly nested) `tuple`, `namedtuple` or\n            `list` of `Tensor`s representing internal calculations made within the\n            previous call to this function (or as returned by `bootstrap_results`).\n\n        Returns:\n          next_state: `Tensor` or Python `list` of `Tensor`s representing the\n            next state(s) of the Markov chain(s).\n          kernel_results: A (possibly nested) `tuple`, `namedtuple` or `list` of\n            `Tensor`s representing internal calculations made within this function.", "id": "f15525:c0:m0"}
{"signature": "def find_module(module, paths=None):", "body": "parts = module.split('<STR_LIT:.>')<EOL>while parts:<EOL><INDENT>part = parts.pop(<NUM_LIT:0>)<EOL>f, path, (suffix,mode,kind) = info = imp.find_module(part, paths)<EOL>if kind==PKG_DIRECTORY:<EOL><INDENT>parts = parts or ['<STR_LIT>']<EOL>paths = [path]<EOL><DEDENT>elif parts:<EOL><INDENT>raise ImportError(\"<STR_LIT>\" % (parts,module))<EOL><DEDENT><DEDENT>return info<EOL>", "docstring": "Just like 'imp.find_module()', but with package support", "id": "f21748:m1"}
{"signature": "def _set_name(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:name>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:string>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:string>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__name = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for name, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/named_explicit_paths/named_explicit_path/state/name (string)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_name is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_name() directly.\n\n    YANG Description: A string name that uniquely identifies an explicit\npath", "id": "f22230:c0:m3"}
{"signature": "def _set_metric(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__metric = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for metric, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv4_reachability/prefixes/prefix/state/metric (oc-isis-types:wide-metric)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_metric is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_metric() directly.\n\nYANG Description: ISIS metric value.", "id": "f22678:c0:m12"}
{"signature": "def _set_srgb(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__srgb = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for srgb, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/segment_routing/config/srgb (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_srgb is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_srgb() directly.\n\n    YANG Description: A reference to the Segment Routing Global Block (SRGB) that is\nto be used by this IGP instance.", "id": "f22508:c0:m6"}
{"signature": "@log_calls<EOL><INDENT>def local_walk(self, basedir):<DEDENT>", "body": "result = []<EOL>for root, dirs, files in os.walk(basedir):<EOL><INDENT>for f in files:<EOL><INDENT>result.append(os.path.join(root, f))<EOL><DEDENT><DEDENT>return result<EOL>", "docstring": "Walk through local directories from root basedir", "id": "f16741:c8:m9"}
{"signature": "def summarize_for_policy_definition(<EOL>self, subscription_id, policy_definition_name, query_options=None, custom_headers=None, raw=False, **operation_config):", "body": "top = None<EOL>if query_options is not None:<EOL><INDENT>top = query_options.top<EOL><DEDENT>from_parameter = None<EOL>if query_options is not None:<EOL><INDENT>from_parameter = query_options.from_property<EOL><DEDENT>to = None<EOL>if query_options is not None:<EOL><INDENT>to = query_options.to<EOL><DEDENT>filter = None<EOL>if query_options is not None:<EOL><INDENT>filter = query_options.filter<EOL><DEDENT>url = self.summarize_for_policy_definition.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.policy_states_summary_resource, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.authorization_namespace, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", policy_definition_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>', minimum=<NUM_LIT:0>)<EOL><DEDENT>if from_parameter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", from_parameter, '<STR_LIT>')<EOL><DEDENT>if to is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT:to>\", to, '<STR_LIT>')<EOL><DEDENT>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.QueryFailureException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Summarizes policy states for the subscription level policy definition.\n\n        :param subscription_id: Microsoft Azure subscription ID.\n        :type subscription_id: str\n        :param policy_definition_name: Policy definition name.\n        :type policy_definition_name: str\n        :param query_options: Additional parameters for the operation\n        :type query_options: ~azure.mgmt.policyinsights.models.QueryOptions\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: SummarizeResults or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.policyinsights.models.SummarizeResults or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`QueryFailureException<azure.mgmt.policyinsights.models.QueryFailureException>`", "id": "f36919:c0:m12"}
{"signature": "def full_name(self):", "body": "if self.requested_version is not None:<EOL><INDENT>return '<STR_LIT>' % (self.name,self.requested_version)<EOL><DEDENT>return self.name<EOL>", "docstring": "Return full package/distribution name, w/version", "id": "f21748:c0:m1"}
{"signature": "def get_licenses(self):", "body": "return self.licenses<EOL>", "docstring": "Gives all the licenses in the format: ``[(name, url)]``", "id": "f14843:c0:m41"}
{"signature": "def log_in(self, utterance: Any, dialog_id: Optional[Hashable] = None) -> None:", "body": "if self.enabled:<EOL><INDENT>self._log(utterance, '<STR_LIT>', dialog_id)<EOL><DEDENT>", "docstring": "Wraps _log method for all input utterances.\n        Args:\n            utterance: Dialog utterance.\n            dialog_id: Dialog ID.", "id": "f3144:c0:m4"}
{"signature": "def add(self, s):", "body": "if self.is_terminated:<EOL><INDENT>raise TypeError(\"<STR_LIT>\")<EOL><DEDENT>if s == \"<STR_LIT>\":<EOL><INDENT>self._set_final(self.root)<EOL>return<EOL><DEDENT>curr = self.root<EOL>for i, a in enumerate(s):<EOL><INDENT>code = self.alphabet_codes[a]<EOL>next = self.graph[curr][code]<EOL>if next == Trie.NO_NODE:<EOL><INDENT>curr = self._add_descendant(curr, s[i:])<EOL>break<EOL><DEDENT>else:<EOL><INDENT>curr = next<EOL><DEDENT><DEDENT>self._set_final(curr)<EOL>return self<EOL>", "docstring": "\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0440\u043e\u043a\u0438 s \u0432 \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u043d\u044b\u0439 \u0431\u043e\u0440", "id": "f3058:c0:m6"}
{"signature": "def __eq__(self, oth) -> bool:", "body": "<EOL>return self.name == oth<EOL>", "docstring": "Use by all __contains__ call when we do some 'in' test", "id": "f4921:c9:m2"}
{"signature": "def dedent(self):", "body": "self.indent_amount -= <NUM_LIT:4><EOL>", "docstring": "Decrease the current indent for following lines.", "id": "f17077:c0:m4"}
{"signature": "def get(<EOL>self, resource_group_name, account_name, compute_policy_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", compute_policy_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified Data Lake Analytics compute policy.\n\n        :param resource_group_name: The name of the Azure resource group.\n        :type resource_group_name: str\n        :param account_name: The name of the Data Lake Analytics account.\n        :type account_name: str\n        :param compute_policy_name: The name of the compute policy to\n         retrieve.\n        :type compute_policy_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ComputePolicy or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.datalake.analytics.account.models.ComputePolicy or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44193:c0:m3"}
{"signature": "def create_or_update_public_certificate(<EOL>self, resource_group_name, name, public_certificate_name, public_certificate, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_or_update_public_certificate.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", public_certificate_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(public_certificate, '<STR_LIT>')<EOL>request = self._client.put(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Creates a hostname binding for an app.\n\n        Creates a hostname binding for an app.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param public_certificate_name: Public certificate name.\n        :type public_certificate_name: str\n        :param public_certificate: Public certificate details. This is the\n         JSON representation of a PublicCertificate object.\n        :type public_certificate: ~azure.mgmt.web.models.PublicCertificate\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: PublicCertificate or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.web.models.PublicCertificate or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44988:c0:m144"}
{"signature": "@abstractmethod<EOL><INDENT>async def begin_dialog(self, dc, options: object = None):<DEDENT>", "body": "raise NotImplementedError()<EOL>", "docstring": "Method called when a new dialog has been pushed onto the stack and is being activated.\n:param dc: The dialog context for the current turn of conversation.\n:param options: (Optional) additional argument(s) to pass to the dialog being started.", "id": "f10296:c0:m4"}
{"signature": "def _handle_auth(self, dtype, data, ts):", "body": "<EOL>if dtype == '<STR_LIT>':<EOL><INDENT>raise NotImplementedError<EOL><DEDENT>channel_id = data.pop('<STR_LIT>')<EOL>user_id = data.pop('<STR_LIT>')<EOL>identifier = ('<STR_LIT>', user_id)<EOL>self.channel_handlers[identifier] = channel_id<EOL>self.channel_directory[identifier] = channel_id<EOL>self.channel_directory[channel_id] = identifier<EOL>", "docstring": "Handles authentication responses.\n\n        :param dtype:\n        :param data:\n        :param ts:\n        :return:", "id": "f9864:c0:m5"}
{"signature": "def create_or_update_ip_filter_rule(<EOL>self, resource_group_name, namespace_name, ip_filter_rule_name, parameters, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_or_update_ip_filter_rule.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", namespace_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:6>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", ip_filter_rule_name, '<STR_LIT:str>', min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.put(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Creates or updates an IpFilterRule for a Namespace.\n\n        :param resource_group_name: Name of the resource group within the\n         Azure subscription.\n        :type resource_group_name: str\n        :param namespace_name: The Namespace name\n        :type namespace_name: str\n        :param ip_filter_rule_name: The IP Filter Rule name.\n        :type ip_filter_rule_name: str\n        :param parameters: The Namespace IpFilterRule.\n        :type parameters:\n         ~azure.mgmt.eventhub.v2018_01_01_preview.models.IpFilterRule\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: IpFilterRule or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.eventhub.v2018_01_01_preview.models.IpFilterRule\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.eventhub.v2018_01_01_preview.models.ErrorResponseException>`", "id": "f36558:c0:m10"}
{"signature": "def mph_to_knots(mph):", "body": "return mph * <NUM_LIT><EOL>", "docstring": "Miles/hour (mph) to knots (kt)", "id": "f2242:m8"}
{"signature": "def get_key(self):", "body": "master_password = getpass.getpass('<STR_LIT>')<EOL>return self.derive_key(master_password)<EOL>", "docstring": "Fetches the key for the domain. Prompts the user for password.\n\n        Thin wrapper around :func:`Domain.derive_key <pwm.core.Domain.derive_key>`.", "id": "f4386:c0:m4"}
{"signature": "def main():", "body": "args = parser.parse_args()<EOL>run_ms_bot_framework_server(agent_generator=make_agent,<EOL>app_id=args.ms_id,<EOL>app_secret=args.ms_secret,<EOL>stateful=True)<EOL>", "docstring": "Parse parameters and run ms bot framework", "id": "f3132:m4"}
{"signature": "def share(self, institute, case, collaborator_id, user, link):", "body": "if collaborator_id in case.get('<STR_LIT>', []):<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>self.create_event(<EOL>institute=institute,<EOL>case=case,<EOL>user=user,<EOL>link=link,<EOL>category='<STR_LIT>',<EOL>verb='<STR_LIT>',<EOL>subject=collaborator_id<EOL>)<EOL>updated_case = self.case_collection.find_one_and_update(<EOL>{'<STR_LIT>': case['<STR_LIT>']},<EOL>{<EOL>'<STR_LIT>': {'<STR_LIT>': collaborator_id}<EOL>},<EOL>return_document=pymongo.ReturnDocument.AFTER<EOL>)<EOL>LOG.debug(\"<STR_LIT>\")<EOL>return updated_case<EOL>", "docstring": "Share a case with a new institute.\n\n        Arguments:\n            institute (dict): A Institute object\n            case (dict): Case object\n            collaborator_id (str): A instute id\n            user (dict): A User object\n            link (str): The url to be used in the event\n\n        Return:\n            updated_case", "id": "f13784:c0:m7"}
{"signature": "@docsubst<EOL><INDENT>def to_items(self, column_names=None, selection=None, strings=True, virtual=False):<DEDENT>", "body": "items = []<EOL>for name in column_names or self.get_column_names(strings=strings, virtual=virtual):<EOL><INDENT>items.append((name, self.evaluate(name, selection=selection)))<EOL><DEDENT>return items<EOL>", "docstring": "Return a list of [(column_name, ndarray), ...)] pairs where the ndarray corresponds to the evaluated data\n\n        :param column_names: list of column names, to export, when None DataFrame.get_column_names(strings=strings, virtual=virtual) is used\n        :param selection: {selection}\n        :param strings: argument passed to DataFrame.get_column_names when column_names is None\n        :param virtual: argument passed to DataFrame.get_column_names when column_names is None\n        :return: list of (name, ndarray) pairs", "id": "f6914:c0:m94"}
{"signature": "def _get_explicit_path_name(self):", "body": "return self.__explicit_path_name<EOL>", "docstring": "Getter method for explicit_path_name, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_secondary_paths/p2p_secondary_path/state/explicit_path_name (leafref)\n\nYANG Description: reference to a defined path", "id": "f22257:c1:m17"}
{"signature": "def soften_mask(self):", "body": "self._hardmask = False<EOL>return self<EOL>", "docstring": "Force the mask to soft.\n\nWhether the mask of a masked array is hard or soft is determined by\nits `hardmask` property. `soften_mask` sets `hardmask` to False.\n\nSee Also\n--------\nhardmask", "id": "f18992:c13:m15"}
{"signature": "@property<EOL><INDENT>def lo_freq(self) -> float:<DEDENT>", "body": "return self._lo_freq<EOL>", "docstring": "Get the default lo frequency.", "id": "f10742:c1:m1"}
{"signature": "def finalize(self):", "body": "if self._context is not None:<EOL><INDENT>if self._socket is not None:<EOL><INDENT>self._close_socket(confused=False)<EOL><DEDENT>self._context.term()<EOL>self._context = None<EOL>self._poll = None<EOL><DEDENT>", "docstring": "Closes socket and terminates context\n\n        NO-OP if already closed.", "id": "f4217:c4:m4"}
{"signature": "@cli.command()<EOL>@click.option('<STR_LIT>', '<STR_LIT>', required=True, type=click.Path(exists=True), help='<STR_LIT>')<EOL>@click.option('<STR_LIT>','<STR_LIT>', type=click.Path(exists=False), help='<STR_LIT>')<EOL>def reduce(infile, outfile):", "body": "if outfile is None:<EOL><INDENT>outfile = infile<EOL><DEDENT>else:<EOL><INDENT>outfile = outfile<EOL><DEDENT>reduce_osw(infile, outfile)<EOL>", "docstring": "Reduce scored PyProphet file to minimum for global scoring", "id": "f5154:m6"}
{"signature": "def get_by_id(<EOL>self, role_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_by_id.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", role_id, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a role assignment by ID.\n\n        :param role_id: The ID of the role assignment to get.\n        :type role_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: RoleAssignment or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f45536:c0:m8"}
{"signature": "def restoreheartbeat(<EOL>self, resource_group_name, storage_sync_service_name, sync_group_name, cloud_endpoint_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.restoreheartbeat.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>', min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", storage_sync_service_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", sync_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", cloud_endpoint_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>', min_length=<NUM_LIT:1>)<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.StorageSyncErrorException(self._deserialize, response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>client_raw_response.add_headers({<EOL>'<STR_LIT>': '<STR_LIT:str>',<EOL>'<STR_LIT>': '<STR_LIT:str>',<EOL>})<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Restore Heartbeat a given CloudEndpoint.\n\n        :param resource_group_name: The name of the resource group. The name\n         is case insensitive.\n        :type resource_group_name: str\n        :param storage_sync_service_name: Name of Storage Sync Service\n         resource.\n        :type storage_sync_service_name: str\n        :param sync_group_name: Name of Sync Group resource.\n        :type sync_group_name: str\n        :param cloud_endpoint_name: Name of Cloud Endpoint object.\n        :type cloud_endpoint_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`StorageSyncErrorException<azure.mgmt.storagesync.models.StorageSyncErrorException>`", "id": "f42270:c0:m13"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/config (container)\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23431:c1:m2"}
{"signature": "def assert_allclose_cc(actual, desired, **kw):", "body": "try:<EOL><INDENT>assert_allclose(actual, desired, **kw)<EOL><DEDENT>except:<EOL><INDENT>assert_allclose(actual, conj(desired), **kw)<EOL><DEDENT>", "docstring": "Almost equal or complex conjugates almost equal", "id": "f19561:m5"}
{"signature": "def _get_from_address(self):", "body": "return self.__from_address<EOL>", "docstring": "Getter method for from_address, mapped from YANG variable /network_instances/network_instance/mpls/te_global_attributes/srlgs/srlg/static_srlg_members/members_list/config/from_address (inet:ip-address)\n\nYANG Description: IP address of the a-side of the SRLG link", "id": "f22178:c0:m2"}
{"signature": "def unpin_variant(self, institute, case, user, link, variant):", "body": "LOG.info(\"<STR_LIT>\".format(<EOL>variant['<STR_LIT>']))<EOL>LOG.info(\"<STR_LIT>\"\"<STR_LIT>\")<EOL>updated_case = self.case_collection.find_one_and_update(<EOL>{'<STR_LIT>': case['<STR_LIT>']},<EOL>{'<STR_LIT>': {'<STR_LIT>': variant['<STR_LIT>']}},<EOL>return_document=pymongo.ReturnDocument.AFTER<EOL>)<EOL>self.create_event(<EOL>institute=institute,<EOL>case=case,<EOL>user=user,<EOL>link=link,<EOL>category='<STR_LIT>',<EOL>verb='<STR_LIT>',<EOL>variant=variant,<EOL>subject=variant['<STR_LIT>'],<EOL>)<EOL>return updated_case<EOL>", "docstring": "Create an event for unpinning a variant.\n\n        Arguments:\n            institute (dict): A Institute object\n            case (dict): Case object\n            user (dict): A User object\n            link (str): The url to be used in the event\n            variant (dict): A variant object\n\n        Returns:\n            updated_case(dict)", "id": "f13796:c0:m1"}
{"signature": "def close_store(self):", "body": "service = self._traj.v_storage_service<EOL>if not service.is_open:<EOL><INDENT>raise RuntimeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>service.store(pypetconstants.CLOSE_FILE, None)<EOL>", "docstring": "Closes store manually not needed if used with `with`", "id": "f4215:c0:m3"}
{"signature": "def _get_helper_only(self):", "body": "return self.__helper_only<EOL>", "docstring": "Getter method for helper_only, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/graceful_restart/state/helper_only (boolean)\n\n    YANG Description: Enable or disable the IS-IS graceful restart helper function. When\nthis leaf is set, the local system does not utilise the IS-IS\ngraceful restart procedures during its own restart, but supports\nretaining forwarding information during a remote speaker's restart.", "id": "f22463:c0:m5"}
{"signature": "def list_by_server(<EOL>self, resource_group_name, server_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_server.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", server_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ServerDnsAliasPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ServerDnsAliasPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a list of server DNS aliases for a server.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server that the alias is pointing\n         to.\n        :type server_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ServerDnsAlias\n        :rtype:\n         ~azure.mgmt.sql.models.ServerDnsAliasPaged[~azure.mgmt.sql.models.ServerDnsAlias]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38375:c0:m6"}
{"signature": "def hop(self):", "body": "super(NewAaaa, self).hop()<EOL>", "docstring": "hop", "id": "f18502:c1:m0"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, virtual_wan_name, wan_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>virtual_wan_name=virtual_wan_name,<EOL>wan_parameters=wan_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates a VirtualWAN resource if it doesn't exist else updates the\n        existing VirtualWAN.\n\n        :param resource_group_name: The resource group name of the VirtualWan.\n        :type resource_group_name: str\n        :param virtual_wan_name: The name of the VirtualWAN being created or\n         updated.\n        :type virtual_wan_name: str\n        :param wan_parameters: Parameters supplied to create or update\n         VirtualWAN.\n        :type wan_parameters:\n         ~azure.mgmt.network.v2018_11_01.models.VirtualWAN\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns VirtualWAN or\n         ClientRawResponse<VirtualWAN> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_11_01.models.VirtualWAN]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_11_01.models.VirtualWAN]]\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_11_01.models.ErrorException>`", "id": "f32814:c0:m3"}
{"signature": "def delete_backup_slot(<EOL>self, resource_group_name, name, backup_id, slot, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete_backup_slot.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", backup_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", slot, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes a backup of an app by its ID.\n\n        Deletes a backup of an app by its ID.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param backup_id: ID of the backup.\n        :type backup_id: str\n        :param slot: Name of the deployment slot. If a slot is not specified,\n         the API will delete a backup of the production slot.\n        :type slot: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44988:c0:m171"}
{"signature": "def _get_min_delay(self):", "body": "return self.__min_delay<EOL>", "docstring": "Getter method for min_delay, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/min_max_link_delay/state/min_delay (uint32)\n\n    YANG Description: Minimum measured link delay value(in microseconds) between two\ndirectly connected IS-IS neighbors over a configurable\ninterval.", "id": "f22843:c1:m8"}
{"signature": "def send(client, sender, targets, msg_name, dest_name=None, block=None):", "body": "dest_name = msg_name if dest_name is None else dest_name<EOL>def _send(targets, m_name):<EOL><INDENT>msg = globals()[m_name]<EOL>return com.send(targets, msg)<EOL><DEDENT>client[sender].apply_async(_send, targets, msg_name)<EOL>return client[targets].execute('<STR_LIT>'%dest_name, block=None)<EOL>", "docstring": "send a message from one to one-or-more engines.", "id": "f21227:m1"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/bandwidth/state (container)\n\n    YANG Description: State parameters related to bandwidth\nconfiguration of TE tunnels", "id": "f22252:c0:m5"}
{"signature": "def urlopen(self, method, url, body=None, headers=None, retries=None,<EOL>redirect=True, assert_same_host=True, timeout=_Default,<EOL>pool_timeout=None, release_conn=None, **response_kw):", "body": "if headers is None:<EOL><INDENT>headers = self.headers<EOL><DEDENT>if not isinstance(retries, Retry):<EOL><INDENT>retries = Retry.from_int(retries, redirect=redirect, default=self.retries)<EOL><DEDENT>if release_conn is None:<EOL><INDENT>release_conn = response_kw.get('<STR_LIT>', True)<EOL><DEDENT>if assert_same_host and not self.is_same_host(url):<EOL><INDENT>raise HostChangedError(self, url, retries)<EOL><DEDENT>conn = None<EOL>if self.scheme == '<STR_LIT:http>':<EOL><INDENT>headers = headers.copy()<EOL>headers.update(self.proxy_headers)<EOL><DEDENT>err = None<EOL>try:<EOL><INDENT>conn = self._get_conn(timeout=pool_timeout)<EOL>httplib_response = self._make_request(conn, method, url,<EOL>timeout=timeout,<EOL>body=body, headers=headers)<EOL>response_conn = not release_conn and conn<EOL>response = HTTPResponse.from_httplib(httplib_response,<EOL>pool=self,<EOL>connection=response_conn,<EOL>**response_kw)<EOL><DEDENT>except Empty:<EOL><INDENT>raise EmptyPoolError(self, \"<STR_LIT>\")<EOL><DEDENT>except (BaseSSLError, CertificateError) as e:<EOL><INDENT>if conn:<EOL><INDENT>conn.close()<EOL>conn = None<EOL><DEDENT>raise SSLError(e)<EOL><DEDENT>except (TimeoutError, HTTPException, SocketError, ConnectionError) as e:<EOL><INDENT>if conn:<EOL><INDENT>conn.close()<EOL>conn = None<EOL><DEDENT>stacktrace = sys.exc_info()[<NUM_LIT:2>]<EOL>if isinstance(e, SocketError) and self.proxy:<EOL><INDENT>e = ProxyError('<STR_LIT>', e)<EOL><DEDENT>elif isinstance(e, (SocketError, HTTPException)):<EOL><INDENT>e = ProtocolError('<STR_LIT>', e)<EOL><DEDENT>retries = retries.increment(method, url, error=e,<EOL>_pool=self, _stacktrace=stacktrace)<EOL>retries.sleep()<EOL>err = e<EOL><DEDENT>finally:<EOL><INDENT>if release_conn:<EOL><INDENT>self._put_conn(conn)<EOL><DEDENT><DEDENT>if not conn:<EOL><INDENT>log.warning(\"<STR_LIT>\"<EOL>\"<STR_LIT>\" % (retries, err, url))<EOL>return self.urlopen(method, url, body, headers, retries,<EOL>redirect, assert_same_host,<EOL>timeout=timeout, pool_timeout=pool_timeout,<EOL>release_conn=release_conn, **response_kw)<EOL><DEDENT>redirect_location = redirect and response.get_redirect_location()<EOL>if redirect_location:<EOL><INDENT>if response.status == <NUM_LIT>:<EOL><INDENT>method = '<STR_LIT:GET>'<EOL><DEDENT>try:<EOL><INDENT>retries = retries.increment(method, url, response=response, _pool=self)<EOL><DEDENT>except MaxRetryError:<EOL><INDENT>if retries.raise_on_redirect:<EOL><INDENT>raise<EOL><DEDENT>return response<EOL><DEDENT>log.info(\"<STR_LIT>\" % (url, redirect_location))<EOL>return self.urlopen(method, redirect_location, body, headers,<EOL>retries=retries, redirect=redirect,<EOL>assert_same_host=assert_same_host,<EOL>timeout=timeout, pool_timeout=pool_timeout,<EOL>release_conn=release_conn, **response_kw)<EOL><DEDENT>if retries.is_forced_retry(method, status_code=response.status):<EOL><INDENT>retries = retries.increment(method, url, response=response, _pool=self)<EOL>retries.sleep()<EOL>log.info(\"<STR_LIT>\" % url)<EOL>return self.urlopen(method, url, body, headers,<EOL>retries=retries, redirect=redirect,<EOL>assert_same_host=assert_same_host,<EOL>timeout=timeout, pool_timeout=pool_timeout,<EOL>release_conn=release_conn, **response_kw)<EOL><DEDENT>return response<EOL>", "docstring": "Get a connection from the pool and perform an HTTP request. This is the\nlowest level call for making a request, so you'll need to specify all\nthe raw details.\n\n.. note::\n\n   More commonly, it's appropriate to use a convenience method provided\n   by :class:`.RequestMethods`, such as :meth:`request`.\n\n.. note::\n\n   `release_conn` will only behave as expected if\n   `preload_content=False` because we want to make\n   `preload_content=False` the default behaviour someday soon without\n   breaking backwards compatibility.\n\n:param method:\n    HTTP request method (such as GET, POST, PUT, etc.)\n\n:param body:\n    Data to send in the request body (useful for creating\n    POST requests, see HTTPConnectionPool.post_url for\n    more convenience).\n\n:param headers:\n    Dictionary of custom headers to send, such as User-Agent,\n    If-None-Match, etc. If None, pool headers are used. If provided,\n    these headers completely replace any pool-specific headers.\n\n:param retries:\n    Configure the number of retries to allow before raising a\n    :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n    Pass ``None`` to retry until you receive a response. Pass a\n    :class:`~urllib3.util.retry.Retry` object for fine-grained control\n    over different types of retries.\n    Pass an integer number to retry connection errors that many times,\n    but no other types of errors. Pass zero to never retry.\n\n    If ``False``, then retries are disabled and any exception is raised\n    immediately. Also, instead of raising a MaxRetryError on redirects,\n    the redirect response will be returned.\n\n:type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n:param redirect:\n    If True, automatically handle redirects (status codes 301, 302,\n    303, 307, 308). Each redirect counts as a retry. Disabling retries\n    will disable redirect, too.\n\n:param assert_same_host:\n    If ``True``, will make sure that the host of the pool requests is\n    consistent else will raise HostChangedError. When False, you can\n    use the pool on an HTTP proxy and request foreign hosts.\n\n:param timeout:\n    If specified, overrides the default timeout for this one\n    request. It may be a float (in seconds) or an instance of\n    :class:`urllib3.util.Timeout`.\n\n:param pool_timeout:\n    If set and the pool is set to block=True, then this method will\n    block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n    connection is available within the time period.\n\n:param release_conn:\n    If False, then the urlopen call will not release the connection\n    back into the pool once a response is received (but will release if\n    you read the entire contents of the response such as when\n    `preload_content=True`). This is useful if you're not preloading\n    the response's content immediately. You will need to call\n    ``r.release_conn()`` on the response ``r`` to return the connection\n    back into the pool. If None, it takes the value of\n    ``response_kw.get('preload_content', True)``.\n\n:param \\**response_kw:\n    Additional parameters are passed to\n    :meth:`urllib3.response.HTTPResponse.from_httplib`", "id": "f17247:c1:m10"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/global/hellos/config (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_config is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_config() directly.\n\n    YANG Description: Configuration parameters relating to RSVP\nhellos", "id": "f22325:c0:m3"}
{"signature": "def create_gtr(params):", "body": "model = params.gtr<EOL>gtr_params = params.gtr_params<EOL>if model == '<STR_LIT>':<EOL><INDENT>gtr = GTR.standard('<STR_LIT>', alphabet='<STR_LIT>' if params.aa else '<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>try:<EOL><INDENT>kwargs = {}<EOL>if gtr_params is not None:<EOL><INDENT>for param in gtr_params:<EOL><INDENT>keyval = param.split('<STR_LIT:=>')<EOL>if len(keyval)!=<NUM_LIT:2>: continue<EOL>if keyval[<NUM_LIT:0>] in ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']:<EOL><INDENT>keyval[<NUM_LIT:0>] = '<STR_LIT>'<EOL>keyval[<NUM_LIT:1>] = list(map(float, keyval[<NUM_LIT:1>].split('<STR_LIT:U+002C>')))<EOL><DEDENT>elif keyval[<NUM_LIT:0>] not in ['<STR_LIT>']:<EOL><INDENT>keyval[<NUM_LIT:1>] = float(keyval[<NUM_LIT:1>])<EOL><DEDENT>kwargs[keyval[<NUM_LIT:0>]] = keyval[<NUM_LIT:1>]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>print (\"<STR_LIT>\")<EOL><DEDENT>gtr = GTR.standard(model, **kwargs)<EOL>infer_gtr = False<EOL><DEDENT>except:<EOL><INDENT>print (\"<STR_LIT>\")<EOL>gtr = GTR.standard('<STR_LIT>', alphabet='<STR_LIT>' if params.aa else '<STR_LIT>')<EOL>infer_gtr = False<EOL><DEDENT><DEDENT>return gtr<EOL>", "docstring": "parse the arguments referring to the GTR model and return a GTR structure", "id": "f2307:m1"}
{"signature": "def setcopyright():", "body": "builtins.copyright = _Printer(\"<STR_LIT>\", sys.copyright)<EOL>if _is_jython:<EOL><INDENT>builtins.credits = _Printer(<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\")<EOL><DEDENT>elif _is_pypy:<EOL><INDENT>builtins.credits = _Printer(<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\")<EOL><DEDENT>else:<EOL><INDENT>builtins.credits = _Printer(\"<STR_LIT>\", \"\"\"<STR_LIT>\"\"\")<EOL><DEDENT>here = os.path.dirname(os.__file__)<EOL>builtins.license = _Printer(<EOL>\"<STR_LIT>\", \"<STR_LIT>\" % sys.version,<EOL>[\"<STR_LIT>\", \"<STR_LIT>\"],<EOL>[os.path.join(here, os.pardir), here, os.curdir])<EOL>", "docstring": "Set 'copyright' and 'credits' in __builtin__", "id": "f21260:m12"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/ish/state (container)\n\nYANG Description: Operational state relating to ISH PDUs.", "id": "f22435:c0:m2"}
{"signature": "def allstack(vals, depth=<NUM_LIT:0>):", "body": "if type(vals[<NUM_LIT:0>]) is ndarray:<EOL><INDENT>return concatenate(vals, axis=depth)<EOL><DEDENT>else:<EOL><INDENT>return concatenate([allstack(x, depth+<NUM_LIT:1>) for x in vals], axis=depth)<EOL><DEDENT>", "docstring": "If an ndarray has been split into multiple chunks by splitting it along\neach axis at a number of locations, this function rebuilds the\noriginal array from chunks.\n\nParameters\n----------\nvals : nested lists of ndarrays\n    each level of nesting of the lists representing a dimension of\n    the original array.", "id": "f990:m9"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/config/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: Whether the use of multiple paths for the same NLRI is\nenabled for the neighbor. This value is overridden by\nany more specific configuration value.", "id": "f23314:c1:m3"}
{"signature": "def tell(self):", "body": "return self.pos<EOL>", "docstring": "Return the stream's file pointer position.", "id": "f17283:c12:m7"}
{"signature": "def _get_received(self):", "body": "return self.__received<EOL>", "docstring": "Getter method for received, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/state/received (boolean)\n\n    YANG Description: This leaf indicates whether the neighbor advertised the\nability to support graceful-restart for this AFI-SAFI", "id": "f23281:c1:m5"}
{"signature": "def raise_error(etype=UnpicklingError, message=None):", "body": "raise etype(message)<EOL>", "docstring": "Function that raises an Exception in process", "id": "f14082:m7"}
{"signature": "def replace_pattern(<EOL>df,<EOL>column: str,<EOL>*,<EOL>pat: str,<EOL>repl: str,<EOL>new_column: str = None,<EOL>case: bool = True,<EOL>regex: bool = True<EOL>):", "body": "new_column = new_column or column<EOL>df.loc[:, new_column] = df[column].str.replace(pat, repl, case=case, regex=regex)<EOL>return df<EOL>", "docstring": "Replace occurrences of pattern/regex in `column` with some other string\nSee [pandas doc](\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.replace.html) for more information\n\n---\n\n### Parameters\n\n*mandatory :*\n- `column` (*str*): the column\n- `pat` (*str*): character sequence or regular expression\n- `repl` (*str*): replacement string\n\n*optional :*\n- `new_column` (*str*): the destination column (if not set, `column` will be used)\n- `case` (*boolean*): if true, case sensitive.\n- `regex` (*boolean*): default true", "id": "f4510:m10"}
{"signature": "def symrand(dim_or_eigv):", "body": "if isinstance(dim_or_eigv, int):<EOL><INDENT>dim = dim_or_eigv<EOL>d = (rand(dim)*<NUM_LIT:2>)-<NUM_LIT:1><EOL><DEDENT>elif (isinstance(dim_or_eigv, ndarray) and<EOL>len(dim_or_eigv.shape) == <NUM_LIT:1>):<EOL><INDENT>dim = dim_or_eigv.shape[<NUM_LIT:0>]<EOL>d = dim_or_eigv<EOL><DEDENT>else:<EOL><INDENT>raise TypeError(\"<STR_LIT>\")<EOL><DEDENT>v = random_rot(dim)<EOL>h = dot(dot(v.T.conj(), diag(d)), v)<EOL>h = <NUM_LIT:0.5>*(h.T+h)<EOL>return h<EOL>", "docstring": "Return a random symmetric (Hermitian) matrix.\n\n    If 'dim_or_eigv' is an integer N, return a NxN matrix, with eigenvalues\n        uniformly distributed on (-1,1).\n\n    If 'dim_or_eigv' is  1-D real array 'a', return a matrix whose\n                      eigenvalues are 'a'.", "id": "f19295:m1"}
{"signature": "def configure_edges(self, info):", "body": "if info.initialized:<EOL><INDENT>self.model.edit_traits(parent=info.ui.control,<EOL>kind=\"<STR_LIT>\", view=edges_view)<EOL><DEDENT>", "docstring": "Handles display of the edges editor.", "id": "f1988:c0:m9"}
{"signature": "def _get_administrative_tags(self):", "body": "return self.__administrative_tags<EOL>", "docstring": "Getter method for administrative_tags, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information/tlvs/tlv/node_administrative_tags/state/administrative_tags (uint32)\n\n    YANG Description: The set of administrative tags assigned to the local system by\nthe network operator. The meaning of these tags is opaque to OSPF\n- and their interpretation is per-domain specific", "id": "f23086:c1:m2"}
{"signature": "def __init__(self,<EOL>distributions,<EOL>dtype_override=None,<EOL>validate_args=False,<EOL>allow_nan_stats=False,<EOL>name='<STR_LIT>'):", "body": "parameters = dict(locals())<EOL>with tf.name_scope(name) as name:<EOL><INDENT>self._assertions = _maybe_validate_distributions(<EOL>distributions, dtype_override, validate_args)<EOL>if dtype_override is not None:<EOL><INDENT>dtype = dtype_override<EOL><DEDENT>else:<EOL><INDENT>dtype = set(<EOL>dtype_util.base_dtype(d.dtype)<EOL>for d in distributions<EOL>if d.dtype is not None)<EOL>if len(dtype) == <NUM_LIT:0>:  <EOL><INDENT>dtype = tf.float32<EOL><DEDENT>elif len(dtype) == <NUM_LIT:1>:<EOL><INDENT>dtype = dtype.pop()<EOL><DEDENT>else:<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT><DEDENT>reparameterization_type = set(d.reparameterization_type<EOL>for d in distributions)<EOL>reparameterization_type = (reparameterization_type.pop()<EOL>if len(reparameterization_type) == <NUM_LIT:1><EOL>else reparameterization.NOT_REPARAMETERIZED)<EOL>self._distributions = distributions<EOL>super(Blockwise, self).__init__(<EOL>dtype=dtype,<EOL>validate_args=validate_args,<EOL>allow_nan_stats=allow_nan_stats,<EOL>reparameterization_type=reparameterization_type,<EOL>parameters=parameters,<EOL>graph_parents=_flatten(d._graph_parents for d in distributions),  <EOL>name=name)<EOL><DEDENT>", "docstring": "Construct the `Blockwise` distribution.\n\n        Args:\n          distributions: Python `list` of `tfp.distributions.Distribution`\n            instances. All distribution instances must have the same `batch_shape`\n            and all must have `event_ndims==1`, i.e., be vector-variate\n            distributions.\n          dtype_override: samples of `distributions` will be cast to this `dtype`.\n            If unspecified, all `distributions` must have the same `dtype`.\n            Default value: `None` (i.e., do not cast).\n          validate_args: Python `bool`, default `False`. When `True` distribution\n            parameters are checked for validity despite possibly degrading runtime\n            performance. When `False` invalid inputs may silently render incorrect\n            outputs.\n          allow_nan_stats: Python `bool`, default `True`. When `True`, statistics\n            (e.g., mean, mode, variance) use the value \"`NaN`\" to indicate the\n            result is undefined. When `False`, an exception is raised if one or\n            more of the statistic's batch members are undefined.\n          name: Python `str` name prefixed to Ops created by this class.", "id": "f15650:c0:m0"}
{"signature": "def _find_telegrams(self):", "body": "<EOL>return re.findall(<EOL>r'<STR_LIT>',<EOL>self._buffer,<EOL>re.DOTALL<EOL>)<EOL>", "docstring": "Find complete telegrams in buffer from  start ('/') till ending\nchecksum ('!AB12\\r\\n').\n:rtype: list", "id": "f4403:c0:m4"}
{"signature": "def _set_ipv6_neighbor_address(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ipv6_neighbor_address = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ipv6_neighbor_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_srlg/state/ipv6_neighbor_address (inet:ipv6-address)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_ipv6_neighbor_address is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_ipv6_neighbor_address() directly.\n\nYANG Description: IPv6 neighbor address or Link Remote Identifier.", "id": "f22899:c1:m18"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, cross_connection_name, peering_name, peering_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>cross_connection_name=cross_connection_name,<EOL>peering_name=peering_name,<EOL>peering_parameters=peering_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a peering in the specified\n        ExpressRouteCrossConnection.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param cross_connection_name: The name of the\n         ExpressRouteCrossConnection.\n        :type cross_connection_name: str\n        :param peering_name: The name of the peering.\n        :type peering_name: str\n        :param peering_parameters: Parameters supplied to the create or update\n         ExpressRouteCrossConnection peering operation.\n        :type peering_parameters:\n         ~azure.mgmt.network.v2018_11_01.models.ExpressRouteCrossConnectionPeering\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         ExpressRouteCrossConnectionPeering or\n         ClientRawResponse<ExpressRouteCrossConnectionPeering> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_11_01.models.ExpressRouteCrossConnectionPeering]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_11_01.models.ExpressRouteCrossConnectionPeering]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32805:c0:m6"}
{"signature": "def _set_upper_bound(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=[<EOL>RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {\"<STR_LIT:value>\": <NUM_LIT:0>},<EOL>\"<STR_LIT>\": {\"<STR_LIT:value>\": <NUM_LIT:1>},<EOL>\"<STR_LIT>\": {\"<STR_LIT:value>\": <NUM_LIT:2>},<EOL>\"<STR_LIT>\": {\"<STR_LIT:value>\": <NUM_LIT:3>},<EOL>\"<STR_LIT>\": {\"<STR_LIT:value>\": <NUM_LIT:7>},<EOL>\"<STR_LIT>\": {},<EOL>},<EOL>),<EOL>],<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__upper_bound = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for upper_bound, mapped from YANG variable /network_instances/network_instance/mpls/global/reserved_label_blocks/reserved_label_block/state/upper_bound (oc-mplst:mpls-label)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_upper_bound is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_upper_bound() directly.\n\n    YANG Description: Upper bound for the global label block. The block is defined to include\nthis label.", "id": "f22201:c0:m9"}
{"signature": "def _preset(self, name, args, kwargs):", "body": "if self.f_contains(name, shortcuts=False):<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'<STR_LIT>' % name)<EOL><DEDENT>else:<EOL><INDENT>self._changed_default_parameters[name] = (args, kwargs)<EOL><DEDENT>", "docstring": "Generic preset function, marks a parameter or config for presetting.", "id": "f4238:c0:m28"}
{"signature": "def _set_up_down(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__up_down = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for up_down, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_reachability/prefixes/prefixes/state/up_down (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_up_down is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_up_down() directly.\n\n    YANG Description: The up/down bit. Set if a prefix is advertised from a higher level to\na lower level (e.g., level 2 to level 1), indicating that the prefix\nhas traveled down the hierarchy. Prefixes that have the up/down bit\nset may only be advertised down the hierarchy, i.e., to lower levels.\nWhen a prefix is first injected into IS-IS, the bit is UNSET.", "id": "f22654:c0:m3"}
{"signature": "def _set_subinterface(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__subinterface = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for subinterface, mapped from YANG variable /network_instances/network_instance/protocols/protocol/static_routes/static/next_hops/next_hop/interface_ref/state/subinterface (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_subinterface is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_subinterface() directly.\n\n    YANG Description: Reference to a subinterface -- this requires the base\ninterface to be specified using the interface leaf in\nthis container.  If only a reference to a base interface\nis requuired, this leaf should not be set.", "id": "f22387:c1:m6"}
{"signature": "@cache(level=<NUM_LIT:30>)<EOL>def hpss(S, kernel_size=<NUM_LIT>, power=<NUM_LIT>, mask=False, margin=<NUM_LIT:1.0>):", "body": "if np.iscomplexobj(S):<EOL><INDENT>S, phase = core.magphase(S)<EOL><DEDENT>else:<EOL><INDENT>phase = <NUM_LIT:1><EOL><DEDENT>if np.isscalar(kernel_size):<EOL><INDENT>win_harm = kernel_size<EOL>win_perc = kernel_size<EOL><DEDENT>else:<EOL><INDENT>win_harm = kernel_size[<NUM_LIT:0>]<EOL>win_perc = kernel_size[<NUM_LIT:1>]<EOL><DEDENT>if np.isscalar(margin):<EOL><INDENT>margin_harm = margin<EOL>margin_perc = margin<EOL><DEDENT>else:<EOL><INDENT>margin_harm = margin[<NUM_LIT:0>]<EOL>margin_perc = margin[<NUM_LIT:1>]<EOL><DEDENT>if margin_harm < <NUM_LIT:1> or margin_perc < <NUM_LIT:1>:<EOL><INDENT>raise ParameterError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>harm = np.empty_like(S)<EOL>harm[:] = median_filter(S, size=(<NUM_LIT:1>, win_harm), mode='<STR_LIT>')<EOL>perc = np.empty_like(S)<EOL>perc[:] = median_filter(S, size=(win_perc, <NUM_LIT:1>), mode='<STR_LIT>')<EOL>split_zeros = (margin_harm == <NUM_LIT:1> and margin_perc == <NUM_LIT:1>)<EOL>mask_harm = util.softmask(harm, perc * margin_harm,<EOL>power=power,<EOL>split_zeros=split_zeros)<EOL>mask_perc = util.softmask(perc, harm * margin_perc,<EOL>power=power,<EOL>split_zeros=split_zeros)<EOL>if mask:<EOL><INDENT>return mask_harm, mask_perc<EOL><DEDENT>return ((S * mask_harm) * phase, (S * mask_perc) * phase)<EOL>", "docstring": "Median-filtering harmonic percussive source separation (HPSS).\n\n    If `margin = 1.0`, decomposes an input spectrogram `S = H + P`\n    where `H` contains the harmonic components,\n    and `P` contains the percussive components.\n\n    If `margin > 1.0`, decomposes an input spectrogram `S = H + P + R`\n    where `R` contains residual components not included in `H` or `P`.\n\n    This implementation is based upon the algorithm described by [1]_ and [2]_.\n\n    .. [1] Fitzgerald, Derry.\n        \"Harmonic/percussive separation using median filtering.\"\n        13th International Conference on Digital Audio Effects (DAFX10),\n        Graz, Austria, 2010.\n\n    .. [2] Driedger, M\u00fcller, Disch.\n        \"Extending harmonic-percussive separation of audio.\"\n        15th International Society for Music Information Retrieval Conference (ISMIR 2014),\n        Taipei, Taiwan, 2014.\n\n    Parameters\n    ----------\n    S : np.ndarray [shape=(d, n)]\n        input spectrogram. May be real (magnitude) or complex.\n\n    kernel_size : int or tuple (kernel_harmonic, kernel_percussive)\n        kernel size(s) for the median filters.\n\n        - If scalar, the same size is used for both harmonic and percussive.\n        - If tuple, the first value specifies the width of the\n          harmonic filter, and the second value specifies the width\n          of the percussive filter.\n\n    power : float > 0 [scalar]\n        Exponent for the Wiener filter when constructing soft mask matrices.\n\n    mask : bool\n        Return the masking matrices instead of components.\n\n        Masking matrices contain non-negative real values that\n        can be used to measure the assignment of energy from `S`\n        into harmonic or percussive components.\n\n        Components can be recovered by multiplying `S * mask_H`\n        or `S * mask_P`.\n\n\n    margin : float or tuple (margin_harmonic, margin_percussive)\n        margin size(s) for the masks (as described in [2]_)\n\n        - If scalar, the same size is used for both harmonic and percussive.\n        - If tuple, the first value specifies the margin of the\n          harmonic mask, and the second value specifies the margin\n          of the percussive mask.\n\n    Returns\n    -------\n    harmonic : np.ndarray [shape=(d, n)]\n        harmonic component (or mask)\n\n    percussive : np.ndarray [shape=(d, n)]\n        percussive component (or mask)\n\n\n    See Also\n    --------\n    util.softmask\n\n    Notes\n    -----\n    This function caches at level 30.\n\n    Examples\n    --------\n    Separate into harmonic and percussive\n\n    >>> y, sr = librosa.load(librosa.util.example_audio_file(), duration=15)\n    >>> D = librosa.stft(y)\n    >>> H, P = librosa.decompose.hpss(D)\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.figure()\n    >>> plt.subplot(3, 1, 1)\n    >>> librosa.display.specshow(librosa.amplitude_to_db(np.abs(D),\n    ...                                                  ref=np.max),\n    ...                          y_axis='log')\n    >>> plt.colorbar(format='%+2.0f dB')\n    >>> plt.title('Full power spectrogram')\n    >>> plt.subplot(3, 1, 2)\n    >>> librosa.display.specshow(librosa.amplitude_to_db(np.abs(H),\n    ...                                                  ref=np.max),\n    ...                          y_axis='log')\n    >>> plt.colorbar(format='%+2.0f dB')\n    >>> plt.title('Harmonic power spectrogram')\n    >>> plt.subplot(3, 1, 3)\n    >>> librosa.display.specshow(librosa.amplitude_to_db(np.abs(P),\n    ...                                                  ref=np.max),\n    ...                          y_axis='log')\n    >>> plt.colorbar(format='%+2.0f dB')\n    >>> plt.title('Percussive power spectrogram')\n    >>> plt.tight_layout()\n\n\n    Or with a narrower horizontal filter\n\n    >>> H, P = librosa.decompose.hpss(D, kernel_size=(13, 31))\n\n    Just get harmonic/percussive masks, not the spectra\n\n    >>> mask_H, mask_P = librosa.decompose.hpss(D, mask=True)\n    >>> mask_H\n    array([[  1.000e+00,   1.469e-01, ...,   2.648e-03,   2.164e-03],\n           [  1.000e+00,   2.368e-01, ...,   9.413e-03,   7.703e-03],\n           ...,\n           [  8.869e-01,   5.673e-02, ...,   4.603e-02,   1.247e-05],\n           [  7.068e-01,   2.194e-02, ...,   4.453e-02,   1.205e-05]], dtype=float32)\n    >>> mask_P\n    array([[  2.858e-05,   8.531e-01, ...,   9.974e-01,   9.978e-01],\n           [  1.586e-05,   7.632e-01, ...,   9.906e-01,   9.923e-01],\n           ...,\n           [  1.131e-01,   9.433e-01, ...,   9.540e-01,   1.000e+00],\n           [  2.932e-01,   9.781e-01, ...,   9.555e-01,   1.000e+00]], dtype=float32)\n\n    Separate into harmonic/percussive/residual components by using a margin > 1.0\n\n    >>> H, P = librosa.decompose.hpss(D, margin=3.0)\n    >>> R = D - (H+P)\n    >>> y_harm = librosa.core.istft(H)\n    >>> y_perc = librosa.core.istft(P)\n    >>> y_resi = librosa.core.istft(R)\n\n\n    Get a more isolated percussive component by widening its margin\n\n    >>> H, P = librosa.decompose.hpss(D, margin=(1.0,5.0))", "id": "f18149:m1"}
{"signature": "def _get_max_prefixes(self):", "body": "return self.__max_prefixes<EOL>", "docstring": "Getter method for max_prefixes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/config/max_prefixes (uint32)\n\n    YANG Description: Maximum number of prefixes that will be accepted\nfrom the neighbour", "id": "f23398:c0:m2"}
{"signature": "def isalive(self):", "body": "if self.terminated:<EOL><INDENT>return False<EOL><DEDENT>if self.flag_eof:<EOL><INDENT>waitpid_options = <NUM_LIT:0><EOL><DEDENT>else:<EOL><INDENT>waitpid_options = os.WNOHANG<EOL><DEDENT>try:<EOL><INDENT>pid, status = os.waitpid(self.pid, waitpid_options)<EOL><DEDENT>except OSError as e: <EOL><INDENT>if e.errno == errno.ECHILD:<EOL><INDENT>raise ExceptionPexpect ('<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>raise e<EOL><DEDENT><DEDENT>if pid == <NUM_LIT:0>:<EOL><INDENT>try:<EOL><INDENT>pid, status = os.waitpid(self.pid, waitpid_options) <EOL><DEDENT>except OSError as e: <EOL><INDENT>if e[<NUM_LIT:0>] == errno.ECHILD:<EOL><INDENT>raise ExceptionPexpect ('<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>raise e<EOL><DEDENT><DEDENT>if pid == <NUM_LIT:0>:<EOL><INDENT>return True<EOL><DEDENT><DEDENT>if pid == <NUM_LIT:0>:<EOL><INDENT>return True<EOL><DEDENT>if os.WIFEXITED (status):<EOL><INDENT>self.status = status<EOL>self.exitstatus = os.WEXITSTATUS(status)<EOL>self.signalstatus = None<EOL>self.terminated = True<EOL><DEDENT>elif os.WIFSIGNALED (status):<EOL><INDENT>self.status = status<EOL>self.exitstatus = None<EOL>self.signalstatus = os.WTERMSIG(status)<EOL>self.terminated = True<EOL><DEDENT>elif os.WIFSTOPPED (status):<EOL><INDENT>raise ExceptionPexpect ('<STR_LIT>')<EOL><DEDENT>return False<EOL>", "docstring": "This tests if the child process is running or not. This is\n        non-blocking. If the child was terminated then this will read the\n        exitstatus or signalstatus of the child. This returns True if the child\n        process appears to be running or False if not. It can take literally\n        SECONDS for Solaris to return the right status.", "id": "f21318:c3:m30"}
{"signature": "def get_shared_key(<EOL>self, resource_group_name, virtual_network_gateway_connection_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_shared_key.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_network_gateway_connection_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "The Get VirtualNetworkGatewayConnectionSharedKey operation retrieves\n        information about the specified virtual network gateway connection\n        shared key through Network resource provider.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_gateway_connection_name: The virtual network\n         gateway connection shared key name.\n        :type virtual_network_gateway_connection_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ConnectionSharedKey or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2017_10_01.models.ConnectionSharedKey or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33114:c0:m10"}
{"signature": "def get_query(self, query):", "body": "url = self._api_url(<EOL>\"<STR_LIT>\", query=query)<EOL>return self._getter(url, subkey='<STR_LIT>')<EOL>", "docstring": "Run a generic issue/PR query", "id": "f5482:c0:m3"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/grace_lsa/tlvs/tlv/unknown_tlv/state (container)\n\nYANG Description: Contents of an unknown TLV within the LSA", "id": "f23030:c0:m2"}
{"signature": "def rlist_classes(module, cls_filter=None):", "body": "found = list()<EOL>mnames = rlist_modules(module)<EOL>for mname in mnames:<EOL><INDENT>[found.append(c) for c in list_classes(mname, cls_filter)]<EOL><DEDENT>return found<EOL>", "docstring": "Attempts to list all of the classes within a given module namespace.\nThis method, unlike list_classes, will recurse into discovered\nsubmodules.\n\nIf a type filter is set, it will be called with each class as its\nparameter. This filter's return value must be interpretable as a\nboolean. Results that evaluate as True will include the type in the\nlist of returned classes. Results that evaluate as False will exclude\nthe type in the list of returned classes.\n\n:param mname: of the module to descend into\n:param cls_filter: a function to call to determine what classes should be\n            included.", "id": "f5084:m10"}
{"signature": "def points2htmlfontsize(points):", "body": "<EOL>if points<=<NUM_LIT:8>:<EOL><INDENT>return <NUM_LIT:1><EOL><DEDENT>elif points<=<NUM_LIT:10>:<EOL><INDENT>return <NUM_LIT:2><EOL><DEDENT>elif points<=<NUM_LIT:12>:<EOL><INDENT>return <NUM_LIT:3><EOL><DEDENT>elif points<=<NUM_LIT>:<EOL><INDENT>return <NUM_LIT:4><EOL><DEDENT>elif points<=<NUM_LIT>:<EOL><INDENT>return <NUM_LIT:5><EOL><DEDENT>elif points<=<NUM_LIT>:<EOL><INDENT>return <NUM_LIT:6><EOL><DEDENT>else:<EOL><INDENT>return <NUM_LIT:7><EOL><DEDENT>", "docstring": "Approximate font size converter, converts from Points to HTML ``<font>`` tag font sizes.\n\nNote that this method is very inaccurate, since there are only seven possible output values that represent at least 25 input values.\nWhen in doubt, this function always rounds down, e.g. every input value less than eight is converted to HTML size 1.", "id": "f11158:m1"}
{"signature": "def _get_subtlv_type(self):", "body": "return self.__subtlv_type<EOL>", "docstring": "Getter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/min_max_link_delay/state/subtlv_type (identityref)\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22718:c1:m2"}
{"signature": "def _set_net(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(<EOL>allowed_type=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>)<EOL>),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__net = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for net, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/state/net (oc-isis-types:net)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_net is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_net() directly.\n\n    YANG Description: ISIS network entity title (NET). The first 8 bits are usually\n49 (private AFI), next 16 bits represent area, next 48 bits represent\nsystem id and final 8 bits are set to 0.", "id": "f22466:c0:m9"}
{"signature": "def update_tags(<EOL>self, resource_group_name, network_interface_name, tags=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_tags_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_interface_name=network_interface_name,<EOL>tags=tags,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Updates a network interface tags.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_interface_name: The name of the network interface.\n        :type network_interface_name: str\n        :param tags: Resource tags.\n        :type tags: dict[str, str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns NetworkInterface or\n         ClientRawResponse<NetworkInterface> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_01_01.models.NetworkInterface]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_01_01.models.NetworkInterface]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32029:c0:m7"}
{"signature": "def plot_bloch_multivector(rho, title='<STR_LIT>', figsize=None):", "body": "if not HAS_MATPLOTLIB:<EOL><INDENT>raise ImportError('<STR_LIT>')<EOL><DEDENT>rho = _validate_input_state(rho)<EOL>num = int(np.log2(len(rho)))<EOL>width, height = plt.figaspect(<NUM_LIT:1>/num)<EOL>fig = plt.figure(figsize=(width, height))<EOL>for i in range(num):<EOL><INDENT>ax = fig.add_subplot(<NUM_LIT:1>, num, i + <NUM_LIT:1>, projection='<STR_LIT>')<EOL>pauli_singles = [<EOL>Pauli.pauli_single(num, i, '<STR_LIT:X>'),<EOL>Pauli.pauli_single(num, i, '<STR_LIT:Y>'),<EOL>Pauli.pauli_single(num, i, '<STR_LIT>')<EOL>]<EOL>bloch_state = list(<EOL>map(lambda x: np.real(np.trace(np.dot(x.to_matrix(), rho))),<EOL>pauli_singles))<EOL>plot_bloch_vector(bloch_state, \"<STR_LIT>\" + str(i), ax=ax,<EOL>figsize=figsize)<EOL><DEDENT>fig.suptitle(title, fontsize=<NUM_LIT:16>)<EOL>plt.close(fig)<EOL>return fig<EOL>", "docstring": "Plot the Bloch sphere.\n\n    Plot a sphere, axes, the Bloch vector, and its projections onto each axis.\n\n    Args:\n        rho (ndarray): Numpy array for state vector or density matrix.\n        title (str): a string that represents the plot title\n        figsize (tuple): Has no effect, here for compatibility only.\n\n    Returns:\n        Figure: A matplotlib figure instance if `ax = None`.\n\n    Raises:\n        ImportError: Requires matplotlib.", "id": "f10878:m2"}
{"signature": "def _get_propagate(self):", "body": "return self.__propagate<EOL>", "docstring": "Getter method for propagate, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/nssa_external_lsa/state/propagate (boolean)\n\n    YANG Description: When this bit is set to true, an NSSA border router will\ntranslate a Type 7 LSA (NSSA External) to a Type 5 LSA\n(AS External).", "id": "f22991:c1:m17"}
{"signature": "def iterdecode(iterator, encoding, errors='<STR_LIT:strict>', **kwargs):", "body": "decoder = getincrementaldecoder(encoding)(errors, **kwargs)<EOL>for input in iterator:<EOL><INDENT>output = decoder.decode(input)<EOL>if output:<EOL><INDENT>yield output<EOL><DEDENT><DEDENT>output = decoder.decode(\"<STR_LIT>\", True)<EOL>if output:<EOL><INDENT>yield output<EOL><DEDENT>", "docstring": "Decoding iterator.\n\nDecodes the input strings from the iterator using an IncrementalDecoder.\n\nerrors and kwargs are passed through to the IncrementalDecoder\nconstructor.", "id": "f16912:m9"}
{"signature": "def get(<EOL>self, resource_group_name, local_network_gateway_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", local_network_gateway_name, '<STR_LIT:str>', min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified local network gateway in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param local_network_gateway_name: The name of the local network\n         gateway.\n        :type local_network_gateway_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: LocalNetworkGateway or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_12_01.models.LocalNetworkGateway or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29219:c0:m3"}
{"signature": "def read(self, dir_path: str, dataset: Optional[str] = '<STR_LIT>', url: Optional[str] = None, *args, **kwargs)-> Dict[str, Dict[str, Any]]:", "body": "if url is not None:<EOL><INDENT>self.url = url<EOL><DEDENT>elif dataset == '<STR_LIT>':<EOL><INDENT>self.url = self.url_squad<EOL><DEDENT>elif dataset == '<STR_LIT>':<EOL><INDENT>self.url = self.url_sber_squad<EOL><DEDENT>elif dataset == '<STR_LIT>':<EOL><INDENT>self.url = self.url_multi_squad<EOL><DEDENT>else:<EOL><INDENT>raise RuntimeError('<STR_LIT>'.format(dataset))<EOL><DEDENT>dir_path = Path(dir_path)<EOL>required_files = ['<STR_LIT>'.format(dt) for dt in ['<STR_LIT:train>', '<STR_LIT>']]<EOL>if not dir_path.exists():<EOL><INDENT>dir_path.mkdir()<EOL><DEDENT>if not all((dir_path / f).exists() for f in required_files):<EOL><INDENT>download_decompress(self.url, dir_path)<EOL><DEDENT>dataset = {}<EOL>for f in required_files:<EOL><INDENT>with dir_path.joinpath(f).open('<STR_LIT:r>', encoding='<STR_LIT:utf8>') as fp:<EOL><INDENT>data = json.load(fp)<EOL><DEDENT>if f == '<STR_LIT>':<EOL><INDENT>dataset['<STR_LIT>'] = data<EOL><DEDENT>else:<EOL><INDENT>dataset['<STR_LIT:train>'] = data<EOL><DEDENT><DEDENT>return dataset<EOL>", "docstring": "Args:\n    dir_path: path to save data\n    dataset: default dataset names: ``'SQuAD'``, ``'SberSQuAD'`` or ``'MultiSQuAD'``\n    url: link to archive with dataset, use url argument if non-default dataset is used\n\nReturns:\n    dataset split on train/valid\n\nRaises:\n    RuntimeError: if `dataset` is not one of these: ``'SQuAD'``, ``'SberSQuAD'``, ``'MultiSQuAD'``.", "id": "f3016:c0:m0"}
{"signature": "@fluent<EOL><INDENT>def header(self, name, value):<DEDENT>", "body": "headers = {name: value}<EOL>self._request.headers = headers<EOL>self.add_matcher(matcher('<STR_LIT>', headers))<EOL>", "docstring": "Defines a URL path to match.\n\nOnly call this method if the URL has no path already defined.\n\nArguments:\n    path (str): URL path value to match. E.g: ``/api/users``.\n\nReturns:\n    self: current Mock instance.", "id": "f11904:c0:m4"}
{"signature": "@property<EOL><INDENT>def application_security_groups(self):<DEDENT>", "body": "api_version = self._get_api_version('<STR_LIT>')<EOL>if api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_09_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_10_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_11_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_01_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_02_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_04_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_06_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_07_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_08_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_10_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_11_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_12_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2019_02_01.operations import ApplicationSecurityGroupsOperations as OperationClass<EOL><DEDENT>else:<EOL><INDENT>raise NotImplementedError(\"<STR_LIT>\".format(api_version))<EOL><DEDENT>return OperationClass(self._client, self.config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))<EOL>", "docstring": "Instance depends on the API version:\n\n           * 2017-09-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2017_09_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2017-10-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2017_10_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2017-11-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2017_11_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-01-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_01_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-02-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_02_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-04-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_04_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-06-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_06_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-07-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_07_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-08-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_08_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-10-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_10_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-11-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_11_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2018-12-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2018_12_01.operations.ApplicationSecurityGroupsOperations>`\n           * 2019-02-01: :class:`ApplicationSecurityGroupsOperations<azure.mgmt.network.v2019_02_01.operations.ApplicationSecurityGroupsOperations>`", "id": "f30333:c1:m5"}
{"signature": "def perform_maintenance(<EOL>self, resource_group_name, vm_scale_set_name, instance_id, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._perform_maintenance_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_scale_set_name=vm_scale_set_name,<EOL>instance_id=instance_id,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Performs maintenance on a virtual machine in a VM scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_scale_set_name: The name of the VM scale set.\n        :type vm_scale_set_name: str\n        :param instance_id: The instance ID of the virtual machine.\n        :type instance_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25372:c0:m23"}
{"signature": "def allows_children ( self, object ):", "body": "return True<EOL>", "docstring": "Returns whether this object can have children.", "id": "f1991:c0:m0"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering/tlvs/tlv/link/sub_tlvs/sub_tlv/state (container)\n\nYANG Description: State parameters of the Link Sub-TLV", "id": "f23044:c0:m2"}
{"signature": "def _get_advertisement_interval(self):", "body": "return self.__advertisement_interval<EOL>", "docstring": "Getter method for advertisement_interval, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/vrrp/vrrp_group/state/advertisement_interval (uint16)\n\n    YANG Description: Sets the interval between successive VRRP\nadvertisements -- RFC 5798 defines this as a 12-bit\nvalue expressed as 0.1 seconds, with default 100, i.e.,\n1 second.  Several implementation express this in units of\nseconds", "id": "f22015:c0:m20"}
{"signature": "def _set_max_reservable_link_bandwidth(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=bitarray, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__max_reservable_link_bandwidth = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for max_reservable_link_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/max_reservable_link_bandwidth/state/max_reservable_link_bandwidth (oc-types:ieeefloat32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_max_reservable_link_bandwidth is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_max_reservable_link_bandwidth() directly.\n\n    YANG Description: The maximum amount of bandwidth that can be reserved in this\ndirection on this link.  Note that for oversubscription\npurposes,  this can be greater than the bandwidth of the link.\nIt is encoded  in 32 bits in IEEE floating point format.  The\nunits are bytes  (not bits!) per second.", "id": "f22776:c1:m6"}
{"signature": "@pexdoc.pcontracts.contract(suffix=\"<STR_LIT>\", offset=int)<EOL>def peng_suffix_math(suffix, offset):", "body": "<EOL>eobj = pexdoc.exh.addex(ValueError, \"<STR_LIT>\")<EOL>try:<EOL><INDENT>return _POWER_TO_SUFFIX_DICT[_SUFFIX_TO_POWER_DICT[suffix] + <NUM_LIT:3> * offset]<EOL><DEDENT>except KeyError:<EOL><INDENT>eobj(True)<EOL><DEDENT>", "docstring": "r\"\"\"\n    Return engineering suffix from a starting suffix and an number of suffixes offset.\n\n    :param suffix: Engineering suffix\n    :type  suffix: :ref:`EngineeringNotationSuffix`\n\n    :param offset: Engineering suffix offset\n    :type  offset: integer\n\n    :rtype: string\n\n    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc()) ]]]\n    .. Auto-generated exceptions documentation for\n    .. peng.functions.peng_suffix_math\n\n    :raises:\n     * RuntimeError (Argument \\`offset\\` is not valid)\n\n     * RuntimeError (Argument \\`suffix\\` is not valid)\n\n     * ValueError (Argument \\`offset\\` is not valid)\n\n    .. [[[end]]]\n\n    For example:\n\n        >>> import peng\n        >>> peng.peng_suffix_math('u', 6)\n        'T'", "id": "f6749:m18"}
{"signature": "def getrecordbyid(self, id=[], esn='<STR_LIT>', outputschema=namespaces['<STR_LIT>'], format=outputformat):", "body": "<EOL>data = {<EOL>'<STR_LIT>': self.service,<EOL>'<STR_LIT:version>': self.version,<EOL>'<STR_LIT>': '<STR_LIT>',<EOL>'<STR_LIT>': format,<EOL>'<STR_LIT>': outputschema,<EOL>'<STR_LIT>': esn,<EOL>'<STR_LIT:id>': '<STR_LIT:U+002C>'.join(id),<EOL>}<EOL>self.request = urlencode(data)<EOL>self._invoke()<EOL>if self.exceptionreport is None:<EOL><INDENT>self.results = {}<EOL>self.records = OrderedDict()<EOL>self._parserecords(outputschema, esn)<EOL><DEDENT>", "docstring": "Construct and process a GetRecordById request\n\nParameters\n----------\n\n- id: the list of Ids\n- esn: the ElementSetName 'full', 'brief' or 'summary' (default is 'full')\n- outputschema: the outputSchema (default is 'http://www.opengis.net/cat/csw/2.0.2')\n- format: the outputFormat (default is 'application/xml')", "id": "f4748:c0:m4"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, network_security_group_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_security_group_name=network_security_group_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a network security group in the specified resource\n        group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_security_group_name: The name of the network security\n         group.\n        :type network_security_group_name: str\n        :param parameters: Parameters supplied to the create or update network\n         security group operation.\n        :type parameters:\n         ~azure.mgmt.network.v2018_10_01.models.NetworkSecurityGroup\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns NetworkSecurityGroup or\n         ClientRawResponse<NetworkSecurityGroup> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_10_01.models.NetworkSecurityGroup]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_10_01.models.NetworkSecurityGroup]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30332:c0:m5"}
{"signature": "def _set_out_ack_messages(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:64>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__out_ack_messages = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for out_ack_messages, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/global/state/counters/out_ack_messages (yang:counter64)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_out_ack_messages is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_out_ack_messages() directly.\n\nYANG Description: Number of sent RSVP refresh reduction ack messages", "id": "f22321:c1:m63"}
{"signature": "def _get_mac_aging_time(self):", "body": "return self.__mac_aging_time<EOL>", "docstring": "Getter method for mac_aging_time, mapped from YANG variable /network_instances/network_instance/fdb/config/mac_aging_time (uint16)\n\n    YANG Description: The number of seconds of inactivity after which the entry\nin the local FDB is timed out.", "id": "f22107:c1:m5"}
{"signature": "def _get_argspec(func):", "body": "if inspect.isclass(func):<EOL><INDENT>func = func.__init__<EOL><DEDENT>if not inspect.isfunction(func):<EOL><INDENT>return [], False<EOL><DEDENT>parameters = inspect.signature(func).parameters<EOL>args = []<EOL>uses_starstar = False<EOL>for par in parameters.values():<EOL><INDENT>if (par.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD or<EOL>par.kind == inspect.Parameter.KEYWORD_ONLY):<EOL><INDENT>args.append(par.name)<EOL><DEDENT>elif par.kind == inspect.Parameter.VAR_KEYWORD:<EOL><INDENT>uses_starstar = True<EOL><DEDENT><DEDENT>return args, uses_starstar<EOL>", "docstring": "Helper function to support both Python versions", "id": "f4218:m4"}
{"signature": "def generate_changeset(old, new, comment=None):", "body": "rrsets_tag = '<STR_LIT>' % R53_XMLNS<EOL>if rrsets_tag not in (old.tag, new.tag):<EOL><INDENT>log.error('<STR_LIT>' % (old.tag, new.tag))<EOL>raise InvalidArgumentException()<EOL><DEDENT>if comment is None:<EOL><INDENT>comment = '<STR_LIT>' % (<EOL>__file__,<EOL>os.environ['<STR_LIT>'],<EOL>socket.gethostname(),<EOL>time.strftime('<STR_LIT>'))<EOL><DEDENT>root = lxml.etree.XML(\"\"\"<STR_LIT>\"\"\" % (<EOL>R53_XMLNS, comment), parser=XML_PARSER)<EOL>changesroot = root.find('<STR_LIT>' % R53_XMLNS)<EOL>old = normalize_rrs(old)<EOL>new = normalize_rrs(new)<EOL>oldset = set([lxml.etree.tostring(x).rstrip() for x in old])<EOL>newset = set([lxml.etree.tostring(x).rstrip() for x in new])<EOL>if oldset == newset:<EOL><INDENT>return None<EOL><DEDENT>for rrs in old:<EOL><INDENT>rrsst = lxml.etree.tostring(rrs).rstrip()<EOL>if rrsst not in newset:<EOL><INDENT>log.debug(\"<STR_LIT>\")<EOL>log.debug(rrsst)<EOL>change = lxml.etree.XML('<STR_LIT>' % R53_XMLNS, parser=XML_PARSER)<EOL>change.append(rrs)<EOL>changesroot.append(change)<EOL><DEDENT><DEDENT>for rrs in new:<EOL><INDENT>rrsst = lxml.etree.tostring(rrs).rstrip()<EOL>if rrsst not in oldset:<EOL><INDENT>log.debug(\"<STR_LIT>\")<EOL>log.debug(rrsst)<EOL>change = lxml.etree.XML('<STR_LIT>' % R53_XMLNS, parser=XML_PARSER)<EOL>change.append(rrs)<EOL>changesroot.append(change)<EOL><DEDENT><DEDENT>return root<EOL>", "docstring": "Diff two XML configs and return an object with changes to be written.\n\n    Args: old, new: lxml.etree.Element (<ResourceRecordSets>).\n    Returns: lxml.etree.ETree (<ChangeResourceRecordSetsRequest>) or None", "id": "f16052:m4"}
{"signature": "def variables(self):", "body": "return list(self._raw_data.keys())<EOL>", "docstring": "Return the list of variable names.\n\nParameters\n----------\nNone\n\nReturns\n-------\nnames : list of str\n    The names of all variables in the `VariableSet` instance.", "id": "f19160:c3:m4"}
{"signature": "def add_item(self, query_params=None):", "body": "return self.fetch_json(<EOL>uri_path=self.base_uri + '<STR_LIT>',<EOL>http_method='<STR_LIT:POST>',<EOL>query_params=query_params or {}<EOL>)<EOL>", "docstring": "Add an item to this checklist. Returns a dictionary of values of new\nitem.", "id": "f12597:c0:m6"}
{"signature": "def _get_path_computation_method(self):", "body": "return self.__path_computation_method<EOL>", "docstring": "Getter method for path_computation_method, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_primary_path/p2p_primary_path/config/path_computation_method (identityref)\n\n    YANG Description: The method used for computing the path, either\nlocally computed, queried from a server or not\ncomputed at all (explicitly configured).", "id": "f22271:c1:m5"}
{"signature": "def set_form_widgets_attrs(form, attrs):", "body": "for _, field in form.fields.items():<EOL><INDENT>attrs_ = dict(attrs)<EOL>for name, val in attrs.items():<EOL><INDENT>if hasattr(val, '<STR_LIT>'):<EOL><INDENT>attrs_[name] = val(field)<EOL><DEDENT><DEDENT>field.widget.attrs = field.widget.build_attrs(attrs_)<EOL><DEDENT>", "docstring": "Applies a given HTML attributes to each field widget of a given form.\n\n    Example:\n\n        set_form_widgets_attrs(my_form, {'class': 'clickable'})", "id": "f12987:m2"}
{"signature": "def _set_model_id(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=int, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}, int_size=<NUM_LIT:8><EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__model_id = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for model_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/bandwidth_constraints/state/model_id (uint8)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_model_id is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_model_id() directly.\n\n    YANG Description: Identifier for the Bandwidth Constraints  Model currently in\nuse by the LSR initiating the IGP advertisement.", "id": "f22859:c0:m6"}
{"signature": "def _get_state_changes(self):", "body": "return self.__state_changes<EOL>", "docstring": "Getter method for state_changes, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/state/counters/state_changes (yang:counter64)\n\nYANG Description: Number of state changes for the label switched path", "id": "f22240:c0:m11"}
{"signature": "def restore(self):", "body": "if PyFunceble.CONFIGURATION[\"<STR_LIT>\"] and self.backup_content:<EOL><INDENT>file_to_restore = PyFunceble.INTERN[\"<STR_LIT>\"]<EOL>if file_to_restore in self.backup_content:<EOL><INDENT>to_initiate = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]<EOL>alternatives = {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>}<EOL>for string in to_initiate:<EOL><INDENT>try:<EOL><INDENT>PyFunceble.INTERN[\"<STR_LIT>\"][\"<STR_LIT>\"].update(<EOL>{string: self.backup_content[file_to_restore][string]}<EOL>)<EOL><DEDENT>except KeyError:<EOL><INDENT>PyFunceble.INTERN[\"<STR_LIT>\"][\"<STR_LIT>\"].update(<EOL>{<EOL>string: self.backup_content[file_to_restore][<EOL>alternatives[string]<EOL>]<EOL>}<EOL>)<EOL><DEDENT><DEDENT><DEDENT><DEDENT>", "docstring": "Restore data from the given path.", "id": "f8242:c0:m2"}
{"signature": "def update_tags(<EOL>self, resource_group_name, ddos_custom_policy_name, tags=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_tags_initial(<EOL>resource_group_name=resource_group_name,<EOL>ddos_custom_policy_name=ddos_custom_policy_name,<EOL>tags=tags,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Update a DDoS custom policy tags.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param ddos_custom_policy_name: The name of the DDoS custom policy.\n        :type ddos_custom_policy_name: str\n        :param tags: Resource tags.\n        :type tags: dict[str, str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns DdosCustomPolicy or\n         ClientRawResponse<DdosCustomPolicy> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2019_02_01.models.DdosCustomPolicy]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2019_02_01.models.DdosCustomPolicy]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34891:c0:m7"}
{"signature": "def diff(a, n=<NUM_LIT:1>, axis=-<NUM_LIT:1>):", "body": "if n == <NUM_LIT:0>:<EOL><INDENT>return a<EOL><DEDENT>if n < <NUM_LIT:0>:<EOL><INDENT>raise ValueError(<EOL>\"<STR_LIT>\" + repr(n))<EOL><DEDENT>a = asanyarray(a)<EOL>nd = len(a.shape)<EOL>slice1 = [slice(None)]*nd<EOL>slice2 = [slice(None)]*nd<EOL>slice1[axis] = slice(<NUM_LIT:1>, None)<EOL>slice2[axis] = slice(None, -<NUM_LIT:1>)<EOL>slice1 = tuple(slice1)<EOL>slice2 = tuple(slice2)<EOL>if n > <NUM_LIT:1>:<EOL><INDENT>return diff(a[slice1]-a[slice2], n-<NUM_LIT:1>, axis=axis)<EOL><DEDENT>else:<EOL><INDENT>return a[slice1]-a[slice2]<EOL><DEDENT>", "docstring": "Calculate the n-th order discrete difference along given axis.\n\nThe first order difference is given by ``out[n] = a[n+1] - a[n]`` along\nthe given axis, higher order differences are calculated by using `diff`\nrecursively.\n\nParameters\n----------\na : array_like\n    Input array\nn : int, optional\n    The number of times values are differenced.\naxis : int, optional\n    The axis along which the difference is taken, default is the last axis.\n\nReturns\n-------\ndiff : ndarray\n    The `n` order differences. The shape of the output is the same as `a`\n    except along `axis` where the dimension is smaller by `n`.\n\nSee Also\n--------\ngradient, ediff1d, cumsum\n\nExamples\n--------\n>>> x = np.array([1, 2, 4, 7, 0])\n>>> np.diff(x)\narray([ 1,  2,  3, -7])\n>>> np.diff(x, n=2)\narray([  1,   1, -10])\n\n>>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n>>> np.diff(x)\narray([[2, 3, 4],\n       [5, 1, 2]])\n>>> np.diff(x, axis=0)\narray([[-1,  2,  0, -2]])", "id": "f19125:m9"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/bandwidth/state (container)\n\n    YANG Description: State parameters related to bandwidth\nconfiguration of TE tunnels", "id": "f22252:c1:m5"}
{"signature": "def register_json(self, obj):", "body": "if not isinstance(obj, list):<EOL><INDENT>obj = [obj]<EOL><DEDENT>self.register(Descriptor.from_json(j) for j in obj)<EOL>", "docstring": "Register Descriptors from json descriptor objects.\n\n        Parameters:\n            obj(list or dict): descriptors to register", "id": "f15177:c0:m2"}
{"signature": "def fftconvolve(in1, in2, mode=\"<STR_LIT>\"):", "body": "in1 = asarray(in1)<EOL>in2 = asarray(in2)<EOL>if in1.ndim == in2.ndim == <NUM_LIT:0>:  <EOL><INDENT>return in1 * in2<EOL><DEDENT>elif not in1.ndim == in2.ndim:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>elif in1.size == <NUM_LIT:0> or in2.size == <NUM_LIT:0>:  <EOL><INDENT>return array([])<EOL><DEDENT>s1 = array(in1.shape)<EOL>s2 = array(in2.shape)<EOL>complex_result = (np.issubdtype(in1.dtype, np.complex) or<EOL>np.issubdtype(in2.dtype, np.complex))<EOL>shape = s1 + s2 - <NUM_LIT:1><EOL>if mode == \"<STR_LIT>\":<EOL><INDENT>_check_valid_mode_shapes(s1, s2)<EOL><DEDENT>fshape = [_next_regular(int(d)) for d in shape]<EOL>fslice = tuple([slice(<NUM_LIT:0>, int(sz)) for sz in shape])<EOL>if not complex_result and (_rfft_mt_safe or _rfft_lock.acquire(False)):<EOL><INDENT>try:<EOL><INDENT>ret = irfftn(rfftn(in1, fshape) *<EOL>rfftn(in2, fshape), fshape)[fslice].copy()<EOL><DEDENT>finally:<EOL><INDENT>if not _rfft_mt_safe:<EOL><INDENT>_rfft_lock.release()<EOL><DEDENT><DEDENT><DEDENT>else:<EOL><INDENT>ret = ifftn(fftn(in1, fshape) * fftn(in2, fshape))[fslice].copy()<EOL>if not complex_result:<EOL><INDENT>ret = ret.real<EOL><DEDENT><DEDENT>if mode == \"<STR_LIT>\":<EOL><INDENT>return ret<EOL><DEDENT>elif mode == \"<STR_LIT>\":<EOL><INDENT>return _centered(ret, s1)<EOL><DEDENT>elif mode == \"<STR_LIT>\":<EOL><INDENT>return _centered(ret, s1 - s2 + <NUM_LIT:1>)<EOL><DEDENT>else:<EOL><INDENT>raise ValueError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Convolve two N-dimensional arrays using FFT.\n\n    Convolve `in1` and `in2` using the fast Fourier transform method, with\n    the output size determined by the `mode` argument.\n\n    This is generally much faster than `convolve` for large arrays (n > ~500),\n    but can be slower when only a few output values are needed, and can only\n    output float arrays (int or object array inputs will be cast to float).\n\n    Parameters\n    ----------\n    in1 : array_like\n        First input.\n    in2 : array_like\n        Second input. Should have the same number of dimensions as `in1`;\n        if sizes of `in1` and `in2` are not equal then `in1` has to be the\n        larger array.\n    mode : str {'full', 'valid', 'same'}, optional\n        A string indicating the size of the output:\n\n        ``full``\n           The output is the full discrete linear convolution\n           of the inputs. (Default)\n        ``valid``\n           The output consists only of those elements that do not\n           rely on the zero-padding.\n        ``same``\n           The output is the same size as `in1`, centered\n           with respect to the 'full' output.\n\n    Returns\n    -------\n    out : array\n        An N-dimensional array containing a subset of the discrete linear\n        convolution of `in1` with `in2`.\n\n    Examples\n    --------\n    Autocorrelation of white noise is an impulse.  (This is at least 100 times\n    as fast as `convolve`.)\n\n    >>> from scipy import signal\n    >>> sig = np.random.randn(1000)\n    >>> autocorr = signal.fftconvolve(sig, sig[::-1], mode='full')\n\n    >>> import matplotlib.pyplot as plt\n    >>> fig, (ax_orig, ax_mag) = plt.subplots(2, 1)\n    >>> ax_orig.plot(sig)\n    >>> ax_orig.set_title('White noise')\n    >>> ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)\n    >>> ax_mag.set_title('Autocorrelation')\n    >>> fig.show()\n\n    Gaussian blur implemented using FFT convolution.  Notice the dark borders\n    around the image, due to the zero-padding beyond its boundaries.\n    The `convolve2d` function allows for other types of image boundaries,\n    but is far slower.\n\n    >>> from scipy import misc\n    >>> lena = misc.lena()\n    >>> kernel = np.outer(signal.gaussian(70, 8), signal.gaussian(70, 8))\n    >>> blurred = signal.fftconvolve(lena, kernel, mode='same')\n\n    >>> fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(1, 3)\n    >>> ax_orig.imshow(lena, cmap='gray')\n    >>> ax_orig.set_title('Original')\n    >>> ax_orig.set_axis_off()\n    >>> ax_kernel.imshow(kernel, cmap='gray')\n    >>> ax_kernel.set_title('Gaussian kernel')\n    >>> ax_kernel.set_axis_off()\n    >>> ax_blurred.imshow(blurred, cmap='gray')\n    >>> ax_blurred.set_title('Blurred')\n    >>> ax_blurred.set_axis_off()\n    >>> fig.show()", "id": "f19249:m6"}
{"signature": "def on_conflict(self, fields: List[Union[str, Tuple[str]]], action, index_predicate: str=None):", "body": "return self.get_queryset().on_conflict(fields, action, index_predicate)<EOL>", "docstring": "Sets the action to take when conflicts arise when attempting\n        to insert/create a new row.\n\n        Arguments:\n            fields:\n                The fields the conflicts can occur in.\n\n            action:\n                The action to take when the conflict occurs.\n\n            index_predicate:\n                The index predicate to satisfy an arbiter partial index.", "id": "f353:c1:m3"}
{"signature": "def list(<EOL>self, resource_group_name, circuit_name, peering_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", circuit_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", peering_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.PeerExpressRouteCircuitConnectionPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.PeerExpressRouteCircuitConnectionPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all global reach peer connections associated with a private\n        peering in an express route circuit.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the circuit.\n        :type circuit_name: str\n        :param peering_name: The name of the peering.\n        :type peering_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of\n         PeerExpressRouteCircuitConnection\n        :rtype:\n         ~azure.mgmt.network.v2018_12_01.models.PeerExpressRouteCircuitConnectionPaged[~azure.mgmt.network.v2018_12_01.models.PeerExpressRouteCircuitConnection]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29203:c0:m2"}
{"signature": "def listen(self):", "body": "self._sock.listen(<NUM_LIT:1>)<EOL>while self.starting:<EOL><INDENT>try:<EOL><INDENT>sock, ip = self._sock.accept()<EOL>threading.Thread(target=self.handle, args=(sock,)).start()<EOL><DEDENT>except socket.error:<EOL><INDENT>pass<EOL><DEDENT><DEDENT>", "docstring": "Listen on host:port", "id": "f5912:c0:m5"}
{"signature": "def timezone(zone):", "body": "if zone.upper() == '<STR_LIT>':<EOL><INDENT>return utc<EOL><DEDENT>try:<EOL><INDENT>zone = ascii(zone)<EOL><DEDENT>except UnicodeEncodeError:<EOL><INDENT>raise UnknownTimeZoneError(zone)<EOL><DEDENT>zone = _unmunge_zone(zone)<EOL>if zone not in _tzinfo_cache:<EOL><INDENT>if zone in all_timezones_set:<EOL><INDENT>fp = open_resource(zone)<EOL>try:<EOL>", "docstring": "r''' Return a datetime.tzinfo implementation for the given timezone \n\n    >>> from datetime import datetime, timedelta\n    >>> utc = timezone('UTC')\n    >>> eastern = timezone('US/Eastern')\n    >>> eastern.zone\n    'US/Eastern'\n    >>> timezone(unicode('US/Eastern')) is eastern\n    True\n    >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n    >>> loc_dt = utc_dt.astimezone(eastern)\n    >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'\n    >>> loc_dt.strftime(fmt)\n    '2002-10-27 01:00:00 EST (-0500)'\n    >>> (loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 00:50:00 EST (-0500)'\n    >>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:50:00 EDT (-0400)'\n    >>> (loc_dt + timedelta(minutes=10)).strftime(fmt)\n    '2002-10-27 01:10:00 EST (-0500)'\n\n    Raises UnknownTimeZoneError if passed an unknown zone.\n\n    >>> try:\n    ...     timezone('Asia/Shangri-La')\n    ... except UnknownTimeZoneError:\n    ...     print('Unknown')\n    Unknown\n\n    >>> try:\n    ...     timezone(unicode('\\N{TRADE MARK SIGN}'))\n    ... except UnknownTimeZoneError:\n    ...     print('Unknown')\n    Unknown", "id": "f13299:m0"}
{"signature": "def get_private_dir(self, create=False):", "body": "if self.is_local():<EOL><INDENT>name = os.path.abspath(self.path).replace(os.path.sep, \"<STR_LIT:_>\")[:<NUM_LIT>]  <EOL>name = name.replace(\"<STR_LIT::>\", \"<STR_LIT:_>\")  <EOL><DEDENT>else:<EOL><INDENT>server = self.server<EOL>name = \"<STR_LIT>\" % (server.hostname, server.port, server.base_path.replace(\"<STR_LIT:/>\", \"<STR_LIT:_>\"), self.name)<EOL><DEDENT>dir = os.path.join(vaex.utils.get_private_dir(), \"<STR_LIT>\", name)<EOL>if create and not os.path.exists(dir):<EOL><INDENT>os.makedirs(dir)<EOL><DEDENT>return dir<EOL>", "docstring": "Each DataFrame has a directory where files are stored for metadata etc.\n\n        Example\n\n        >>> import vaex\n        >>> ds = vaex.example()\n        >>> vaex.get_private_dir()\n        '/Users/users/breddels/.vaex/dfs/_Users_users_breddels_vaex-testing_data_helmi-dezeeuw-2000-10p.hdf5'\n\n        :param bool create: is True, it will create the directory if it does not exist", "id": "f6914:c0:m68"}
{"signature": "def ranfunc():", "body": "return '<STR_LIT>'<EOL>", "docstring": "A function with some random output.\n\n       Normal examples are verified as usual:\n       >>> 1+3\n       4\n\n       But if you put '# random' in the output, it is ignored:\n       >>> 1+3\n       junk goes here...  # random\n\n       >>> 1+2\n       again,  anything goes #random\n       if multiline, the random mark is only needed once.\n\n       >>> 1+2\n       You can also put the random marker at the end:\n       # random\n\n       >>> 1+2\n       # random\n       .. or at the beginning.\n\n       More correct input is properly verified:\n       >>> ranfunc()\n       'ranfunc'", "id": "f21370:m2"}
{"signature": "def create_or_update_value(<EOL>self, tag_name, tag_value, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_or_update_value.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", tag_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", tag_value, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.put(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Creates a tag value. The name of the tag must already exist.\n\n        :param tag_name: The name of the tag.\n        :type tag_name: str\n        :param tag_value: The value of the tag to create.\n        :type tag_value: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: TagValue or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.resource.resources.v2018_05_01.models.TagValue or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37814:c0:m2"}
{"signature": "def break_around_binary_operator(logical_line, tokens):", "body": "def is_binary_operator(token_type, text):<EOL><INDENT>return ((token_type == tokenize.OP or text in ['<STR_LIT>', '<STR_LIT>']) and<EOL>text not in \"<STR_LIT>\")<EOL><DEDENT>line_break = False<EOL>unary_context = True<EOL>for token_type, text, start, end, line in tokens:<EOL><INDENT>if token_type == tokenize.COMMENT:<EOL><INDENT>continue<EOL><DEDENT>if ('<STR_LIT:\\n>' in text or '<STR_LIT:\\r>' in text) and token_type != tokenize.STRING:<EOL><INDENT>line_break = True<EOL><DEDENT>else:<EOL><INDENT>if (is_binary_operator(token_type, text) and line_break and<EOL>not unary_context):<EOL><INDENT>yield start, \"<STR_LIT>\"<EOL><DEDENT>unary_context = text in '<STR_LIT>'<EOL>line_break = False<EOL><DEDENT><DEDENT>", "docstring": "r\"\"\"\n    Avoid breaks before binary operators.\n\n    The preferred place to break around a binary operator is after the\n    operator, not before it.\n\n    W503: (width == 0\\n + height == 0)\n    W503: (width == 0\\n and height == 0)\n\n    Okay: (width == 0 +\\n height == 0)\n    Okay: foo(\\n    -x)\n    Okay: foo(x\\n    [])\n    Okay: x = '''\\n''' + ''\n    Okay: foo(x,\\n    -y)\n    Okay: foo(x,  # comment\\n    -y)", "id": "f13285:m21"}
{"signature": "def _get_use_cspf(self):", "body": "return self.__use_cspf<EOL>", "docstring": "Getter method for use_cspf, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_secondary_paths/p2p_secondary_path/state/use_cspf (boolean)\n\nYANG Description: Flag to enable CSPF for locally computed LSPs", "id": "f22257:c0:m8"}
{"signature": "def _get_summary_route_cost_mode(self):", "body": "return self.__summary_route_cost_mode<EOL>", "docstring": "Getter method for summary_route_cost_mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/global/config/summary_route_cost_mode (enumeration)\n\n    YANG Description: Specify how costs for the summary routes should be specified\nas per the behaviour in the original OSPF specification\nRFC1583, or alternatively whether the revised behaviour\ndescribed in RFC2328 should be utilised", "id": "f23147:c1:m5"}
{"signature": "def stop(<EOL>self, resource_group_name, network_watcher_name, connection_monitor_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._stop_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_watcher_name=network_watcher_name,<EOL>connection_monitor_name=connection_monitor_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Stops the specified connection monitor.\n\n        :param resource_group_name: The name of the resource group containing\n         Network Watcher.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the Network Watcher resource.\n        :type network_watcher_name: str\n        :param connection_monitor_name: The name of the connection monitor.\n        :type connection_monitor_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.network.v2018_10_01.models.ErrorResponseException>`", "id": "f30287:c0:m7"}
{"signature": "def _get_internal_route_preference(self):", "body": "return self.__internal_route_preference<EOL>", "docstring": "Getter method for internal_route_preference, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/route_preference/config/internal_route_preference (uint8)\n\nYANG Description: Administrative Distance(preference) for internal ISIS routes.", "id": "f22528:c1:m5"}
{"signature": "def load_external_types(self, path):", "body": "folder, filename = os.path.split(path)<EOL>try:<EOL><INDENT>fileobj, pathname, description = imp.find_module(filename, [folder])<EOL>mod = imp.load_module(filename, fileobj, pathname, description)<EOL><DEDENT>except ImportError as exc:<EOL><INDENT>raise ArgumentError(\"<STR_LIT>\", module_path=path, parent_directory=folder, module_name=filename, error=str(exc))<EOL><DEDENT>self.load_type_module(mod)<EOL>", "docstring": "Given a path to a python package or module, load that module, search for all defined variables\ninside of it that do not start with _ or __ and inject them into the type system.  If any of the\ntypes cannot be injected, silently ignore them unless verbose is True.  If path points to a module\nit should not contain the trailing .py since this is added automatically by the python import system", "id": "f17793:c0:m16"}
{"signature": "def get_asset(self, symbol):", "body": "resp = self.get('<STR_LIT>'.format(symbol))<EOL>return Asset(resp)<EOL>", "docstring": "Get an asset", "id": "f10118:c2:m16"}
{"signature": "@property<EOL><INDENT>def description(self):<DEDENT>", "body": "raise NotImplementedError<EOL>", "docstring": "The schema description method is not currently implemented.", "id": "f9169:c4:m1"}
{"signature": "def __init__(self,<EOL>outcomes,<EOL>logits=None,<EOL>probs=None,<EOL>rtol=None,<EOL>atol=None,<EOL>validate_args=False,<EOL>allow_nan_stats=True,<EOL>name='<STR_LIT>'):", "body": "parameters = dict(locals())<EOL>with tf.compat.v1.name_scope(<EOL>name, values=[outcomes, logits, probs]) as name:<EOL><INDENT>self._outcomes = tf.convert_to_tensor(value=outcomes, name='<STR_LIT>')<EOL>if validate_args:<EOL><INDENT>assertions = _maybe_validate_args(self._outcomes, logits, probs,<EOL>validate_args)<EOL>with tf.control_dependencies(assertions):<EOL><INDENT>self._outcomes = tf.identity(self._outcomes)<EOL><DEDENT><DEDENT>if dtype_util.is_floating(self._outcomes.dtype):<EOL><INDENT>eps = np.finfo(dtype_util.as_numpy_dtype(self._outcomes.dtype)).eps<EOL>self._rtol = <NUM_LIT:10> * eps if rtol is None else rtol<EOL>self._atol = <NUM_LIT:10> * eps if atol is None else atol<EOL><DEDENT>else:<EOL><INDENT>self._rtol = None<EOL>self._atol = None<EOL><DEDENT>self._categorical = categorical.Categorical(<EOL>logits=logits,<EOL>probs=probs,<EOL>dtype=tf.int32,<EOL>validate_args=validate_args,<EOL>allow_nan_stats=allow_nan_stats)<EOL><DEDENT>super(FiniteDiscrete, self).__init__(<EOL>dtype=self._outcomes.dtype,<EOL>reparameterization_type=reparameterization.NOT_REPARAMETERIZED,<EOL>validate_args=validate_args,<EOL>allow_nan_stats=allow_nan_stats,<EOL>parameters=parameters,<EOL>graph_parents=[<EOL>self._outcomes, self._categorical.logits, self._categorical.probs<EOL>],<EOL>name=name)<EOL>", "docstring": "Construct a finite discrete contribution.\n\n        Args:\n          outcomes: A 1-D floating or integer `Tensor`, representing a list of\n            possible outcomes in strictly ascending order.\n          logits: A floating N-D `Tensor`, `N >= 1`, representing the log\n            probabilities of a set of FiniteDiscrete distributions. The first `N -\n            1` dimensions index into a batch of independent distributions and the\n            last dimension represents a vector of logits for each discrete value.\n            Only one of `logits` or `probs` should be passed in.\n          probs: A floating  N-D `Tensor`, `N >= 1`, representing the probabilities\n            of a set of FiniteDiscrete distributions. The first `N - 1` dimensions\n            index into a batch of independent distributions and the last dimension\n            represents a vector of probabilities for each discrete value. Only one\n            of `logits` or `probs` should be passed in.\n          rtol: `Tensor` with same `dtype` as `outcomes`. The relative tolerance for\n            floating number comparison. Only effective when `outcomes` is a floating\n            `Tensor`. Default is `10 * eps`.\n          atol: `Tensor` with same `dtype` as `outcomes`. The absolute tolerance for\n            floating number comparison. Only effective when `outcomes` is a floating\n            `Tensor`. Default is `10 * eps`.\n          validate_args:  Python `bool`, default `False`. When `True` distribution\n            parameters are checked for validity despite possibly degrading runtime\n            performance. When `False` invalid inputs may render incorrect outputs.\n          allow_nan_stats: Python `bool`, default `True`. When `True`, statistics\n            (e.g., mean, mode, variance) use the value '`NaN`' to indicate the\n            result is undefined. When `False`, an exception is raised if one or more\n            of the statistic's batch members are undefined.\n          name: Python `str` name prefixed to Ops created by this class.", "id": "f15716:c0:m0"}
{"signature": "def transform_hits(hits):", "body": "packages = {}<EOL>for hit in hits:<EOL><INDENT>name = hit['<STR_LIT:name>']<EOL>summary = hit['<STR_LIT>']<EOL>version = hit['<STR_LIT:version>']<EOL>score = hit['<STR_LIT>']<EOL>if score is None:<EOL><INDENT>score = <NUM_LIT:0><EOL><DEDENT>if name not in packages.keys():<EOL><INDENT>packages[name] = {<EOL>'<STR_LIT:name>': name,<EOL>'<STR_LIT>': summary,<EOL>'<STR_LIT>': [version],<EOL>'<STR_LIT>': score,<EOL>}<EOL><DEDENT>else:<EOL><INDENT>packages[name]['<STR_LIT>'].append(version)<EOL>if version == highest_version(packages[name]['<STR_LIT>']):<EOL><INDENT>packages[name]['<STR_LIT>'] = summary<EOL>packages[name]['<STR_LIT>'] = score<EOL><DEDENT><DEDENT><DEDENT>package_list = sorted(<EOL>packages.values(),<EOL>key=lambda x: x['<STR_LIT>'],<EOL>reverse=True,<EOL>)<EOL>return package_list<EOL>", "docstring": "The list from pypi is really a list of versions. We want a list of\npackages with the list of versions stored inline. This converts the\nlist from pypi into one we can use.", "id": "f17186:m0"}
{"signature": "def build_job(self, jenkins_server):", "body": "<EOL>if self.parameters and isinstance(self.parameters, six.string_types):<EOL><INDENT>import ast<EOL>self.parameters = ast.literal_eval(self.parameters)<EOL><DEDENT>if not self.parameters:<EOL><INDENT>self.parameters = None<EOL><DEDENT>request = Request(jenkins_server.build_job_url(self.job_name,<EOL>self.parameters, None))<EOL>return jenkins_request_with_headers(jenkins_server, request)<EOL>", "docstring": "This function makes an API call to Jenkins to trigger a build for 'job_name'\nIt returned a dict with 2 keys : body and headers.\nheaders contains also a dict-like object which can be queried to get\nthe location to poll in the queue.\n\n:param jenkins_server: The jenkins server where the job should be triggered\n:return: Dict containing the response body (key body)\n    and the headers coming along (headers)", "id": "f9344:c0:m1"}
{"signature": "@property<EOL><INDENT>def action_up(self):<DEDENT>", "body": "return self._buttons & ControllerButtons.action_up<EOL>", "docstring": "``True`` if the up action button (\"Y\" on Xbox 360) is pressed.  Available only on game controllers with \n        the ``standard`` or ``extended`` profiles.", "id": "f6775:c0:m16"}
{"signature": "def _generate_normals(polygons):", "body": "if isinstance(polygons, np.ndarray):<EOL><INDENT>n = polygons.shape[-<NUM_LIT:2>]<EOL>i1, i2, i3 = <NUM_LIT:0>, n//<NUM_LIT:3>, <NUM_LIT:2>*n//<NUM_LIT:3><EOL>v1 = polygons[..., i1, :] - polygons[..., i2, :]<EOL>v2 = polygons[..., i2, :] - polygons[..., i3, :]<EOL><DEDENT>else:<EOL><INDENT>v1 = np.empty((len(polygons), <NUM_LIT:3>))<EOL>v2 = np.empty((len(polygons), <NUM_LIT:3>))<EOL>for poly_i, ps in enumerate(polygons):<EOL><INDENT>n = len(ps)<EOL>i1, i2, i3 = <NUM_LIT:0>, n//<NUM_LIT:3>, <NUM_LIT:2>*n//<NUM_LIT:3><EOL>v1[poly_i, :] = ps[i1, :] - ps[i2, :]<EOL>v2[poly_i, :] = ps[i2, :] - ps[i3, :]<EOL><DEDENT><DEDENT>return np.cross(v1, v2)<EOL>", "docstring": "Takes a list of polygons and return an array of their normals.\nNormals point towards the viewer for a face with its vertices in\ncounterclockwise order, following the right hand rule.\nUses three points equally spaced around the polygon.\nThis normal of course might not make sense for polygons with more than\nthree points not lying in a plane, but it's a plausible and fast\napproximation.\nArgs:\n    polygons (list): list of (M_i, 3) array_like, or (..., M, 3) array_like\n        A sequence of polygons to compute normals for, which can have\n        varying numbers of vertices. If the polygons all have the same\n        number of vertices and array is passed, then the operation will\n        be vectorized.\nReturns:\n    normals: (..., 3) array_like\n        A normal vector estimated for the polygon.", "id": "f10878:m12"}
{"signature": "def set_proxy(self, host, port, user, password):", "body": "self.proxy_host = host<EOL>self.proxy_port = port<EOL>self.proxy_user = user<EOL>self.proxy_password = password<EOL>", "docstring": "Sets the proxy server host and port for the HTTP CONNECT Tunnelling.\n\nhost:\n    Address of the proxy. Ex: '192.168.0.100'\nport:\n    Port of the proxy. Ex: 6000\nuser:\n    User for proxy authorization.\npassword:\n    Password for proxy authorization.", "id": "f39494:c0:m1"}
{"signature": "def __init__(self, elem):", "body": "self.name = elem.tag.split('<STR_LIT:}>')[<NUM_LIT:1>]          <EOL>self.methods = []<EOL>for resource in elem.findall(ns('<STR_LIT>')+ns('<STR_LIT>')+ns('<STR_LIT>')+ns('<STR_LIT>')):<EOL><INDENT>url = resource.attrib['<STR_LIT>']<EOL>self.methods.append({'<STR_LIT:type>': '<STR_LIT>', '<STR_LIT:url>': url})<EOL><DEDENT>for resource in elem.findall(ns('<STR_LIT>')+ns('<STR_LIT>')+ns('<STR_LIT>')+ns('<STR_LIT>')):<EOL><INDENT>url = resource.attrib['<STR_LIT>']<EOL>self.methods.append({'<STR_LIT:type>': '<STR_LIT>', '<STR_LIT:url>': url})<EOL><DEDENT>", "docstring": ".", "id": "f4790:c1:m0"}
{"signature": "def get(<EOL>self, resource_group_name, namespace_name, topic_name, subscription_name, rule_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", namespace_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:6>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", topic_name, '<STR_LIT:str>', min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", subscription_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", rule_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves the description for the specified rule.\n\n        :param resource_group_name: Name of the Resource group within the\n         Azure subscription.\n        :type resource_group_name: str\n        :param namespace_name: The namespace name\n        :type namespace_name: str\n        :param topic_name: The topic name.\n        :type topic_name: str\n        :param subscription_name: The subscription name.\n        :type subscription_name: str\n        :param rule_name: The rule name.\n        :type rule_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Rule or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.servicebus.models.Rule or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.servicebus.models.ErrorResponseException>`", "id": "f43707:c0:m4"}
{"signature": "def list_by_resource_group(<EOL>self, resource_group_name, top=None, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_resource_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(<EOL>request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VaultPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VaultPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "The List operation gets information about the vaults associated with\n        the subscription and within the specified resource group.\n\n        :param resource_group_name: The name of the Resource Group to which\n         the vault belongs.\n        :type resource_group_name: str\n        :param top: Maximum number of results to return.\n        :type top: int\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Vault\n        :rtype:\n         ~azure.mgmt.keyvault.v2018_02_14.models.VaultPaged[~azure.mgmt.keyvault.v2018_02_14.models.Vault]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38521:c0:m7"}
{"signature": "def on_click(self, element, event):", "body": "return False<EOL>", "docstring": "Override this method in subclass to process\n        click events. Note that element can be None\n        (click on empty space).", "id": "f16117:c0:m28"}
{"signature": "def catmull_clark(script):", "body": "filter_xml = '<STR_LIT>'<EOL>util.write_filter(script, filter_xml)<EOL>return None<EOL>", "docstring": "Apply the Catmull-Clark Subdivision Surfaces.\n\n    Note that position of the new vertices is simply linearly interpolated.\n    If the mesh is triangle based (no faux edges) it generates a quad mesh,\n    otherwise it honors the faux-edge bits.\n\n    Args:\n        script: the FilterScript object or script filename to write\n            the filter to.\n\n    Layer stack:\n        No impacts\n\n    MeshLab versions:\n        2016.12\n        1.3.4BETA", "id": "f9650:m4"}
{"signature": "def _set_mask(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__mask = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for mask, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/nssa_external_lsa/state/mask (uint8)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_mask is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_mask() directly.\n\nYANG Description: The subnet mask for the advertised destination", "id": "f22991:c0:m3"}
{"signature": "def _set_node_attribute(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=node_attribute.node_attribute,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__node_attribute = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for node_attribute, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering/tlvs/tlv/node_attribute (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_node_attribute is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_node_attribute() directly.\n\nYANG Description: Parameters included in the Node Attribute TLV", "id": "f23055:c1:m15"}
{"signature": "def latex_to_html(s, alt='<STR_LIT:image>'):", "body": "base64_data = latex_to_png(s, encode=True)<EOL>if base64_data:<EOL><INDENT>return _data_uri_template_png  % (base64_data, alt)<EOL><DEDENT>", "docstring": "Render LaTeX to HTML with embedded PNG data using data URIs.\n\n    Parameters\n    ----------\n    s : str\n        The raw string containing valid inline LateX.\n    alt : str\n        The alt text to use for the HTML.", "id": "f21605:m3"}
{"signature": "def __call__(self,*packages, **options):", "body": "frame = self.parent_frame<EOL>self.info_modules = {}<EOL>if options.get('<STR_LIT>', False):<EOL><INDENT>self.imported_packages = []<EOL><DEDENT>self.verbose = verbose = options.get('<STR_LIT>', -<NUM_LIT:1>)<EOL>postpone = options.get('<STR_LIT>', None)<EOL>self._init_info_modules(packages or None)<EOL>self.log('<STR_LIT>'% self.parent_name)<EOL>for package_name in self._get_sorted_names():<EOL><INDENT>if package_name in self.imported_packages:<EOL><INDENT>continue<EOL><DEDENT>info_module = self.info_modules[package_name]<EOL>global_symbols = getattr(info_module, '<STR_LIT>', [])<EOL>postpone_import = getattr(info_module, '<STR_LIT>', False)<EOL>if (postpone and not global_symbols)or (postpone_import and postpone is not None):<EOL><INDENT>continue<EOL><DEDENT>old_object = frame.f_locals.get(package_name, None)<EOL>cmdstr = '<STR_LIT>'+package_name<EOL>if self._execcmd(cmdstr):<EOL><INDENT>continue<EOL><DEDENT>self.imported_packages.append(package_name)<EOL>if verbose!=-<NUM_LIT:1>:<EOL><INDENT>new_object = frame.f_locals.get(package_name)<EOL>if old_object is not None and old_object is not new_object:<EOL><INDENT>self.warn('<STR_LIT>'% (package_name, self._obj2repr(new_object),<EOL>self._obj2repr(old_object)))<EOL><DEDENT><DEDENT>if '<STR_LIT:.>' not in package_name:<EOL><INDENT>self.parent_export_names.append(package_name)<EOL><DEDENT>for symbol in global_symbols:<EOL><INDENT>if symbol=='<STR_LIT:*>':<EOL><INDENT>symbols = eval('<STR_LIT>'% (package_name),<EOL>frame.f_globals, frame.f_locals)<EOL>if symbols is None:<EOL><INDENT>symbols = eval('<STR_LIT>' % (package_name),<EOL>frame.f_globals, frame.f_locals)<EOL>symbols = [s for s in symbols if not s.startswith('<STR_LIT:_>')]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>symbols = [symbol]<EOL><DEDENT>if verbose!=-<NUM_LIT:1>:<EOL><INDENT>old_objects = {}<EOL>for s in symbols:<EOL><INDENT>if s in frame.f_locals:<EOL><INDENT>old_objects[s] = frame.f_locals[s]<EOL><DEDENT><DEDENT><DEDENT>cmdstr = '<STR_LIT>'+package_name+'<STR_LIT>'+symbol<EOL>if self._execcmd(cmdstr):<EOL><INDENT>continue<EOL><DEDENT>if verbose!=-<NUM_LIT:1>:<EOL><INDENT>for s, old_object in old_objects.items():<EOL><INDENT>new_object = frame.f_locals[s]<EOL>if new_object is not old_object:<EOL><INDENT>self.warn('<STR_LIT>'% (s, self._obj2repr(new_object),<EOL>self._obj2repr(old_object)))<EOL><DEDENT><DEDENT><DEDENT>if symbol=='<STR_LIT:*>':<EOL><INDENT>self.parent_export_names.extend(symbols)<EOL><DEDENT>else:<EOL><INDENT>self.parent_export_names.append(symbol)<EOL><DEDENT><DEDENT><DEDENT>return<EOL>", "docstring": "Load one or more packages into parent package top-level namespace.\n\n       This function is intended to shorten the need to import many\n       subpackages, say of scipy, constantly with statements such as\n\n         import scipy.linalg, scipy.fftpack, scipy.etc...\n\n       Instead, you can say:\n\n         import scipy\n         scipy.pkgload('linalg','fftpack',...)\n\n       or\n\n         scipy.pkgload()\n\n       to load all of them in one call.\n\n       If a name which doesn't exist in scipy's namespace is\n       given, a warning is shown.\n\n       Parameters\n       ----------\n        *packages : arg-tuple\n             the names (one or more strings) of all the modules one\n             wishes to load into the top-level namespace.\n        verbose= : integer\n             verbosity level [default: -1].\n             verbose=-1 will suspend also warnings.\n        force= : bool\n             when True, force reloading loaded packages [default: False].\n        postpone= : bool\n             when True, don't load packages [default: False]", "id": "f18910:c0:m4"}
{"signature": "def _get_algorithm(self):", "body": "return self.__algorithm<EOL>", "docstring": "Getter method for algorithm, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix/tlvs/tlv/prefix_sid/state/algorithm (uint8)\n\nYANG Description: The algorithm that computes the path associated with the Prefix SID", "id": "f23020:c1:m20"}
{"signature": "def post(self, request):", "body": "serializer = self.serializer_class(data=request.data)<EOL>if serializer.is_valid():<EOL><INDENT>user = serializer.validated_data['<STR_LIT:user>']<EOL>signals.user_logged_in.send(type(self), user=user, request=request)<EOL>token = self.model.objects.create(user=user)<EOL>token.update_expiry()<EOL>return response.Response({'<STR_LIT>': token.key})<EOL><DEDENT>return response.Response(<EOL>serializer.errors, status=status.HTTP_400_BAD_REQUEST)<EOL>", "docstring": "Create auth token. Differs from DRF that it always creates new token\n        but not re-using them.", "id": "f14216:c0:m0"}
{"signature": "def list_table_valued_functions_by_database(<EOL>self, account_name, database_name, filter=None, top=None, skip=None, select=None, orderby=None, count=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_table_valued_functions_by_database.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.adla_catalog_dns_suffix, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", database_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>', minimum=<NUM_LIT:1>)<EOL><DEDENT>if skip is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", skip, '<STR_LIT:int>', minimum=<NUM_LIT:1>)<EOL><DEDENT>if select is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", select, '<STR_LIT:str>')<EOL><DEDENT>if orderby is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", orderby, '<STR_LIT:str>')<EOL><DEDENT>if count is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT:count>\", count, '<STR_LIT:bool>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(<EOL>request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.USqlTableValuedFunctionPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.USqlTableValuedFunctionPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves the list of all table valued functions in a database from the\n        Data Lake Analytics catalog.\n\n        :param account_name: The Azure Data Lake Analytics account upon which\n         to execute catalog operations.\n        :type account_name: str\n        :param database_name: The name of the database containing the table\n         valued functions.\n        :type database_name: str\n        :param filter: OData filter. Optional.\n        :type filter: str\n        :param top: The number of items to return. Optional.\n        :type top: int\n        :param skip: The number of items to skip over before returning\n         elements. Optional.\n        :type skip: int\n        :param select: OData Select statement. Limits the properties on each\n         entry to just those requested, e.g.\n         Categories?$select=CategoryName,Description. Optional.\n        :type select: str\n        :param orderby: OrderBy clause. One or more comma-separated\n         expressions with an optional \"asc\" (the default) or \"desc\" depending\n         on the order you'd like the values sorted, e.g.\n         Categories?$orderby=CategoryName desc. Optional.\n        :type orderby: str\n        :param count: The Boolean value of true or false to request a count of\n         the matching resources included with the resources in the response,\n         e.g. Categories?$count=true. Optional.\n        :type count: bool\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of USqlTableValuedFunction\n        :rtype:\n         ~azure.mgmt.datalake.analytics.catalog.models.USqlTableValuedFunctionPaged[~azure.mgmt.datalake.analytics.catalog.models.USqlTableValuedFunction]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44293:c0:m40"}
{"signature": "def _set_peer_group(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__peer_group = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for peer_group, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/config/peer_group (leafref)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_peer_group is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_peer_group() directly.\n\nYANG Description: The peer-group with which this neighbor is associated", "id": "f23347:c1:m3"}
{"signature": "def assertMessageHasHeaders(self, message, headers):", "body": "if isinstance(message, bytes):<EOL><INDENT>message = message_from_bytes(message)<EOL><DEDENT>msg_headers = set(message.items())<EOL>self.assertTrue(headers.issubset(msg_headers), msg='<STR_LIT>'<EOL>'<STR_LIT>' % (headers - msg_headers),)<EOL>", "docstring": "Asserts that the `message` has all `headers`.\n\nmessage: can be an instance of an email.Message subclass or a string\n         with the contents of an email message.\nheaders: should be a set of (header-name, header-value) tuples.", "id": "f20830:c0:m0"}
{"signature": "@property<EOL><INDENT>def progress_nmax(self):<DEDENT>", "body": "return self.wprogressbar.nmax<EOL>", "docstring": "Property that proxies the ``progress_nmax`` label.\n\nSetting this property will cause the progressbar label to be recalculated.\n\nNote that setting this property if the widget has not been initialized may\ncause various errors to occur.", "id": "f11169:c3:m6"}
{"signature": "@contextmanager<EOL><INDENT>def rethrow_na(self, exception):<DEDENT>", "body": "try:<EOL><INDENT>yield<EOL><DEDENT>except exception as e:<EOL><INDENT>self.fail(e)<EOL><DEDENT>", "docstring": "[contextmanager] treat any exceptions as known exception.", "id": "f15182:c2:m19"}
{"signature": "@contextmanager<EOL>def cd(directory):", "body": "old_dir = os.getcwd()<EOL>try:<EOL><INDENT>os.chdir(directory)<EOL>yield<EOL><DEDENT>finally:<EOL><INDENT>os.chdir(old_dir)<EOL><DEDENT>", "docstring": "Change the current working directory, temporarily.\n\n    Use as a context manager: with cd(d): ...", "id": "f17100:m10"}
{"signature": "@staticmethod<EOL><INDENT>def _parser_to_string_io(parser):<DEDENT>", "body": "memory_file = StringIO()<EOL>parser.write(memory_file)<EOL>memory_file.flush()<EOL>memory_file.seek(<NUM_LIT:0>)<EOL>return memory_file<EOL>", "docstring": "Turns a ConfigParser into a StringIO stream.", "id": "f4237:c1:m8"}
{"signature": "def read_first_header(self):", "body": "self.file_obj.seek(<NUM_LIT:0>)<EOL>header_dict, pos = self.read_header()<EOL>self.file_obj.seek(<NUM_LIT:0>)<EOL>return header_dict<EOL>", "docstring": "Read first header in file\n\n        Returns:\n            header (dict): keyword:value pairs of header metadata", "id": "f8167:c1:m5"}
{"signature": "def masked_array(self, geometry=None):", "body": "if geometry is None:<EOL><INDENT>return self._masked_array()<EOL><DEDENT>geom = transform(geometry, self.sref)<EOL>env = Envelope.from_geom(geom).intersect(self.envelope)<EOL>arr = self._masked_array(env)<EOL>if geom.GetGeometryType() != ogr.wkbPoint:<EOL><INDENT>dims = self.get_offset(env)[<NUM_LIT:2>:]<EOL>affine = AffineTransform(*tuple(self.affine))<EOL>affine.origin = env.ul<EOL>mask = ~np.ma.make_mask(geom_to_array(geom, dims, affine))<EOL>arr.mask = arr.mask | mask<EOL><DEDENT>return arr<EOL>", "docstring": "Returns a MaskedArray using nodata values.\n\n        Keyword args:\n        geometry -- any geometry, envelope, or coordinate extent tuple", "id": "f1741:c2:m22"}
{"signature": "def crop(image, **kwargs):", "body": "image.crop(**kwargs)<EOL>return image<EOL>", "docstring": "Crops an image based on given width or height", "id": "f11832:m3"}
{"signature": "def _get_number_tos_metrics(self):", "body": "return self.__number_tos_metrics<EOL>", "docstring": "Getter method for number_tos_metrics, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/router_lsa/state/number_tos_metrics (uint16)\n\n    YANG Description: The number of different TOS metrics given for this link, not\nincluding the link metric (which is referred to as TOS 0).", "id": "f22979:c0:m17"}
{"signature": "def __dir__(self):", "body": "result = super(NNGroupNode, self).__dir__()<EOL>if not is_debug():<EOL><INDENT>result.extend(self.f_dir_data())<EOL><DEDENT>return result<EOL>", "docstring": "Adds all children to auto-completion", "id": "f4156:c7:m13"}
{"signature": "def _select(self, select_from):", "body": "if len(select_from) <= <NUM_LIT:0>:<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>return choice(select_from)<EOL>", "docstring": "select an element from a list using random.choice\n\n            Parameters\n            ==========\n            should be a list of things to select from", "id": "f9904:c0:m1"}
{"signature": "def _set_subtlv_type(self, v, load=False):", "body": "parent = getattr(self, \"<STR_LIT>\", None)<EOL>if parent is not None and load is False:<EOL><INDENT>raise AttributeError(<EOL>\"<STR_LIT>\" + \"<STR_LIT>\"<EOL>)<EOL><DEDENT>if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>is_keyval=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__subtlv_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_reachability/prefixes/prefixes/subTLVs/subTLVs/subtlv_type (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_subtlv_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_subtlv_type() directly.\n\n    YANG Description: A reference for the TLV type being described within\nthe LSDB", "id": "f22661:c0:m3"}
{"signature": "def __init__(self, *args, **kwargs):", "body": "super(PostgresManager, self).__init__(*args, **kwargs)<EOL>db_backend = settings.DATABASES['<STR_LIT:default>']['<STR_LIT>']<EOL>if '<STR_LIT>' not in db_backend:<EOL><INDENT>raise ImproperlyConfigured((<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>) % db_backend)<EOL><DEDENT>django.db.models.signals.post_save.connect(<EOL>self._on_model_save, sender=self.model, weak=False)<EOL>django.db.models.signals.pre_delete.connect(<EOL>self._on_model_delete, sender=self.model, weak=False)<EOL>self._signals_connected = True<EOL>", "docstring": "Initializes a new instance of :see:PostgresManager.", "id": "f353:c1:m0"}
{"signature": "def _get_passive(self):", "body": "return self.__passive<EOL>", "docstring": "Getter method for passive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive (boolean)\n\nYANG Description: ISIS passive interface admin enable/disable function.", "id": "f22408:c0:m5"}
{"signature": "@property<EOL><INDENT>def checked(self):<DEDENT>", "body": "return \"<STR_LIT>\" in self.native.attrib<EOL>", "docstring": "bool: Whether or not the element is checked.", "id": "f16670:c0:m7"}
{"signature": "def __new_argv(self, *new_pargs, **new_kargs):", "body": "new_argv = self.argv.copy()<EOL>new_extra_argv = list(self.extra_argv)<EOL>for v in new_pargs:<EOL><INDENT>arg_name = None<EOL>for name in self.pargl:<EOL><INDENT>if not name in new_argv:<EOL><INDENT>arg_name = name<EOL>break<EOL><DEDENT><DEDENT>if arg_name:<EOL><INDENT>new_argv[arg_name] = v<EOL><DEDENT>elif self.var_pargs:<EOL><INDENT>new_extra_argv.append(v)<EOL><DEDENT>else:<EOL><INDENT>num_prev_pargs = len([name for name in self.pargl if name in self.argv])<EOL>raise TypeError(\"<STR_LIT>\"% (self.__name__,<EOL>len(self.pargl),<EOL>num_prev_pargs + len(new_pargs)))<EOL><DEDENT><DEDENT>for k,v in new_kargs.items():<EOL><INDENT>if not (self.var_kargs or (k in self.pargl) or (k in self.kargl)):<EOL><INDENT>raise TypeError(\"<STR_LIT>\"% (self.__name__, k))<EOL><DEDENT>new_argv[k] = v<EOL><DEDENT>return (new_argv, new_extra_argv)<EOL>", "docstring": "Calculate new argv and extra_argv values resulting from adding\n        the specified positional and keyword arguments.", "id": "f5604:c0:m5"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/ipv6_neighbor_address/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of sub-TLV 13.", "id": "f22717:c0:m3"}
{"signature": "def run(self):", "body": "try:<EOL><INDENT>self.listen()<EOL><DEDENT>except Exception as e:<EOL><INDENT>logger.critical(\"<STR_LIT>\", str(e))<EOL>logger.critical(traceback.format_exc())<EOL><DEDENT>", "docstring": "Run thread to listen for jobs and reschedule successful ones.", "id": "f4335:c1:m1"}
{"signature": "def manipulate_multiproc_safe(traj):", "body": "<EOL>traj.last_process_name = mp.current_process().name<EOL>traj.results.f_store(store_data=<NUM_LIT:3>)<EOL>", "docstring": "Target function that manipulates the trajectory.\n\n    Stores the current name of the process into the trajectory and\n    **overwrites** previous settings.\n\n    :param traj:\n\n        Trajectory container with multiprocessing safe storage service", "id": "f4245:m0"}
{"signature": "def _get_max_link_bandwidth(self):", "body": "return self.__max_link_bandwidth<EOL>", "docstring": "Getter method for max_link_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/max_link_bandwidth (container)\n\nYANG Description: This container defines sub-TLV 9.", "id": "f22782:c1:m17"}
{"signature": "@property<EOL><INDENT>def content(self):<DEDENT>", "body": "return yaml.safe_load(self.read())<EOL>", "docstring": "Parse the file contents into a dictionary.", "id": "f12610:c3:m0"}
{"signature": "def _set_name(self, v, load=False):", "body": "parent = getattr(self, \"<STR_LIT>\", None)<EOL>if parent is not None and load is False:<EOL><INDENT>raise AttributeError(<EOL>\"<STR_LIT>\" + \"<STR_LIT>\"<EOL>)<EOL><DEDENT>if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:name>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>is_keyval=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__name = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for name, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_primary_path/p2p_primary_path/name (leafref)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_name is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_name() directly.\n\nYANG Description: Path name", "id": "f22272:c0:m3"}
{"signature": "def delete(<EOL>self, resource_group_name, vm_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "The operation to delete a virtual machine.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25735:c0:m9"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/config/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: Whether the use of multiple paths for the same NLRI is\nenabled for the neighbor. This value is overridden by\nany more specific configuration value.", "id": "f23203:c1:m3"}
{"signature": "def restore_slot(<EOL>self, resource_group_name, name, backup_id, request, slot, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._restore_slot_initial(<EOL>resource_group_name=resource_group_name,<EOL>name=name,<EOL>backup_id=backup_id,<EOL>request=request,<EOL>slot=slot,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Restores a specific backup to another app (or deployment slot, if\n        specified).\n\n        Restores a specific backup to another app (or deployment slot, if\n        specified).\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param backup_id: ID of the backup.\n        :type backup_id: str\n        :param request: Information on restore request .\n        :type request: ~azure.mgmt.web.models.RestoreRequest\n        :param slot: Name of the deployment slot. If a slot is not specified,\n         the API will restore a backup of the production slot.\n        :type slot: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44988:c0:m174"}
{"signature": "def __reduce__(self):", "body": "items = [[k, self[k]] for k in self]<EOL>inst_dict = vars(self).copy()<EOL>for k in vars(OrderedDict()):<EOL><INDENT>inst_dict.pop(k, None)<EOL><DEDENT>if inst_dict:<EOL><INDENT>return (self.__class__, (items,), inst_dict)<EOL><DEDENT>return self.__class__, (items,)<EOL>", "docstring": "Return state information for pickling", "id": "f7864:c0:m17"}
{"signature": "def _get_tag64(self):", "body": "return self.__tag64<EOL>", "docstring": "Getter method for tag64, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv6_reachability/prefixes/prefix/subTLVs/subTLVs/tag64 (container)\n\nYANG Description: This container defines sub-TLV 2.", "id": "f22911:c0:m11"}
{"signature": "def file2module(filename):", "body": "basename = osp.basename(filename)<EOL>if '<STR_LIT:.>' in basename:<EOL><INDENT>pos = basename.rfind('<STR_LIT:.>')<EOL>return basename[:pos]<EOL><DEDENT>else:<EOL><INDENT>return basename<EOL><DEDENT>return None<EOL>", "docstring": "Given a file name, extract the most likely module name.", "id": "f7456:m1"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration parameters for VLANs", "id": "f22004:c0:m3"}
{"signature": "def iid_normal_chains_should_pass_wrapper(self,<EOL>sample_shape,<EOL>independent_chain_shape,<EOL>other_shape,<EOL>dtype=np.float32):", "body": "state_shape = sample_shape + independent_chain_shape + other_shape<EOL>state_ = rng.randn(*state_shape).astype(dtype)<EOL>if other_shape:<EOL><INDENT>state_ *= rng.rand(*other_shape).astype(dtype)<EOL><DEDENT>self.check_results(state_, independent_chain_shape, should_pass=True)<EOL>", "docstring": "Check results with iid normal chains.", "id": "f15531:c3:m3"}
{"signature": "def _get_interface_id(self):", "body": "return self.__interface_id<EOL>", "docstring": "Getter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix/tlvs/tlv/sid_label_binding/tlvs/tlv/ero_path/segments/segment/unnumbered_hop/state/interface_id (uint32)\n\nYANG Description: The identifier assigned to the link by the remote system", "id": "f23013:c0:m5"}
{"signature": "def _get_bandwidth_constraints(self):", "body": "return self.__bandwidth_constraints<EOL>", "docstring": "Getter method for bandwidth_constraints, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/bandwidth_constraints (container)\n\n    YANG Description: This container defines bandwidth-constraints. For DS-TE, the\nexisting Maximum Reservable link bandwidth parameter is retained,\nbut its semantics is generalized and interpreted as the aggregate\nbandwidth constraint across all Class-Types", "id": "f22782:c1:m44"}
{"signature": "def resource_listdir(resource_name):", "body": "", "docstring": "List of resource names in the directory (like ``os.listdir()``)", "id": "f16923:c10:m5"}
{"signature": "def _get_preempt(self):", "body": "return self.__preempt<EOL>", "docstring": "Getter method for preempt, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config/preempt (boolean)\n\n    YANG Description: When set to true, enables preemption by a higher\npriority backup router of a lower priority master router", "id": "f21953:c0:m11"}
{"signature": "@staticmethod<EOL><INDENT>def bytes_to_readable(num):<DEDENT>", "body": "if num < <NUM_LIT>:<EOL><INDENT>return \"<STR_LIT>\"<EOL><DEDENT>elif num < <NUM_LIT>:<EOL><INDENT>return \"<STR_LIT>\"<EOL><DEDENT>for unit in ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']:<EOL><INDENT>if abs(num) < <NUM_LIT>:<EOL><INDENT>return \"<STR_LIT>\" % (num, unit)<EOL><DEDENT>num /= <NUM_LIT><EOL><DEDENT>return \"<STR_LIT>\" % (num, '<STR_LIT>')<EOL>", "docstring": "Converts bytes to a human readable format", "id": "f6343:c0:m0"}
{"signature": "def _set_designated_router(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__designated_router = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for designated_router, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/state/designated_router (yang:dotted-quad)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_designated_router is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_designated_router() directly.\n\n    YANG Description: The designated router for the adjacency. This device\nadvertises the Network LSA for broadcast and NBMA networks.", "id": "f23104:c1:m15"}
{"signature": "def compact(self, paths):", "body": "short_paths = set()<EOL>for path in sorted(paths, key=len):<EOL><INDENT>if not any([(path.startswith(shortpath) and<EOL>path[len(shortpath.rstrip(os.path.sep))] == os.path.sep)<EOL>for shortpath in short_paths]):<EOL><INDENT>short_paths.add(path)<EOL><DEDENT><DEDENT>return short_paths<EOL>", "docstring": "Compact a path set to contain the minimal number of paths\n        necessary to contain all paths in the set. If /a/path/ and\n        /a/path/to/a/file.txt are both in the set, leave only the\n        shorter path.", "id": "f21273:c3:m5"}
{"signature": "@GoogleCloudBaseHook.catch_http_exception<EOL><INDENT>def text_detection(<EOL>self, image, max_results=None, retry=None, timeout=None, additional_properties=None<EOL>):<DEDENT>", "body": "client = self.annotator_client<EOL>self.log.info(\"<STR_LIT>\")<EOL>if additional_properties is None:<EOL><INDENT>additional_properties = {}<EOL><DEDENT>response = client.text_detection(<EOL>image=image, max_results=max_results, retry=retry, timeout=timeout, **additional_properties<EOL>)<EOL>response = MessageToDict(response)<EOL>self._check_for_error(response)<EOL>self.log.info(\"<STR_LIT>\")<EOL>return response<EOL>", "docstring": "For the documentation see:\n:py:class:`~airflow.contrib.operators.gcp_vision_operator.CloudVisionDetectTextOperator`", "id": "f9183:c1:m17"}
{"signature": "def generate_md5_key(list_of_arguments):", "body": "for arg in list_of_arguments:<EOL><INDENT>if not isinstance(arg, string_types):<EOL><INDENT>raise SyntaxError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\".format(arg, type(arg)))<EOL><DEDENT><DEDENT>hash = hashlib.md5()<EOL>hash.update('<STR_LIT:U+0020>'.join(list_of_arguments).encode('<STR_LIT:utf-8>'))<EOL>return hash.hexdigest()<EOL>", "docstring": "Generate an md5-key from a list of arguments.\n\nArgs:\n    list_of_arguments: A list of strings\n\nReturns:\n    A md5-key object generated from the list of strings.", "id": "f13717:m0"}
{"signature": "def snapshot(self,<EOL>label,<EOL>snapshot_type='<STR_LIT>',<EOL>qubits=None,<EOL>params=None):", "body": "<EOL>if not isinstance(label, str):<EOL><INDENT>warnings.warn(<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\", DeprecationWarning)<EOL>label = str(label)<EOL><DEDENT>if isinstance(qubits, QuantumRegister):<EOL><INDENT>qubits = qubits[:]<EOL><DEDENT>if not qubits:<EOL><INDENT>tuples = []<EOL>if isinstance(self, QuantumCircuit):<EOL><INDENT>for register in self.qregs:<EOL><INDENT>tuples.append(register)<EOL><DEDENT><DEDENT>if not tuples:<EOL><INDENT>raise ExtensionError('<STR_LIT>')<EOL><DEDENT>qubits = []<EOL>for tuple_element in tuples:<EOL><INDENT>if isinstance(tuple_element, QuantumRegister):<EOL><INDENT>for j in range(tuple_element.size):<EOL><INDENT>qubits.append((tuple_element, j))<EOL><DEDENT><DEDENT>else:<EOL><INDENT>qubits.append(tuple_element)<EOL><DEDENT><DEDENT><DEDENT>return self.append(<EOL>Snapshot(<EOL>label,<EOL>snapshot_type=snapshot_type,<EOL>num_qubits=len(qubits),<EOL>params=params), qubits)<EOL>", "docstring": "Take a statevector snapshot of the internal simulator representation.\n    Works on all qubits, and prevents reordering (like barrier).\n\n    For other types of snapshots use the Snapshot extension directly.\n\n    Args:\n        label (str): a snapshot label to report the result\n        snapshot_type (str): the type of the snapshot.\n        qubits (list or None): the qubits to apply snapshot to [Default: None].\n        params (list or None): the parameters for snapshot_type [Default: None].\n\n    Returns:\n        QuantumCircuit: with attached command\n\n    Raises:\n        ExtensionError: malformed command", "id": "f10847:m0"}
{"signature": "def list_all(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_all.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ExpressRouteCircuitPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ExpressRouteCircuitPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the express route circuits in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ExpressRouteCircuit\n        :rtype:\n         ~azure.mgmt.network.v2017_06_01.models.ExpressRouteCircuitPaged[~azure.mgmt.network.v2017_06_01.models.ExpressRouteCircuit]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32292:c0:m15"}
{"signature": "def _get_unknown_tlv(self):", "body": "return self.__unknown_tlv<EOL>", "docstring": "Getter method for unknown_tlv, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information/tlvs/tlv/segment_routing_sid_label_range/tlvs/tlv/unknown_tlv (container)\n\n    YANG Description: An unknown TLV within the context. Unknown TLVs are\ndefined to be the set of TLVs that are not modelled\nwithin the OpenConfig model, or are unknown to the\nlocal system such that it cannot decode their value.", "id": "f23082:c0:m2"}
{"signature": "def declare_set(self, name, sep=os.pathsep):", "body": "self._declare_special(name, sep, SetVariable)<EOL>", "docstring": "Declare an environment variable as a set-like special variable.\nThis can be used even if the environment variable is not\npresent.\n\n:param name: The name of the environment variable that should\n             be considered set-like.\n:param sep: The separator to be used.  Defaults to the value\n            of ``os.pathsep``.", "id": "f1150:c3:m7"}
{"signature": "def _sendPendingMessages(self):", "body": "if len(self._queue) == <NUM_LIT:0>:<EOL><INDENT>time.sleep(<NUM_LIT:0.1>)<EOL>return<EOL><DEDENT>msg = self._queue.pop(<NUM_LIT:0>)<EOL>if msg.canSend():<EOL><INDENT>self._sendMsg(msg)<EOL>msg.refresh()<EOL>if not (msg.isFinished()):<EOL><INDENT>self._queue.append(msg)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>self._queue.append(msg)<EOL>time.sleep(<NUM_LIT>)<EOL><DEDENT>", "docstring": "Method sleeps, if nothing to do", "id": "f13038:c2:m11"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, ddos_protection_plan_name, location=None, tags=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>ddos_protection_plan_name=ddos_protection_plan_name,<EOL>location=location,<EOL>tags=tags,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a DDoS protection plan.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param ddos_protection_plan_name: The name of the DDoS protection\n         plan.\n        :type ddos_protection_plan_name: str\n        :param location: Resource location.\n        :type location: str\n        :param tags: Resource tags.\n        :type tags: dict[str, str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns DdosProtectionPlan or\n         ClientRawResponse<DdosProtectionPlan> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2019_02_01.models.DdosProtectionPlan]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2019_02_01.models.DdosProtectionPlan]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34893:c0:m5"}
{"signature": "def list(<EOL>self, resource_group_name, registry_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", registry_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ReplicationPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ReplicationPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all the replications for the specified container registry.\n\n        :param resource_group_name: The name of the resource group to which\n         the container registry belongs.\n        :type resource_group_name: str\n        :param registry_name: The name of the container registry.\n        :type registry_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Replication\n        :rtype:\n         ~azure.mgmt.containerregistry.v2017_10_01.models.ReplicationPaged[~azure.mgmt.containerregistry.v2017_10_01.models.Replication]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f23815:c0:m8"}
{"signature": "def jsonRender(self, def_buf):", "body": "try:<EOL><INDENT>ret_dict = SerialBlock()<EOL>ret_dict[Field.Meter_Address] = self.getMeterAddress()<EOL>for fld in def_buf:<EOL><INDENT>compare_fld = fld.upper()<EOL>if not \"<STR_LIT>\" in compare_fld and not \"<STR_LIT>\" in compare_fld:<EOL><INDENT>ret_dict[str(fld)] = def_buf[fld][MeterData.StringValue]<EOL><DEDENT><DEDENT><DEDENT>except:<EOL><INDENT>ekm_log(traceback.format_exc(sys.exc_info()))<EOL>return \"<STR_LIT>\"<EOL><DEDENT>return json.dumps(ret_dict, indent=<NUM_LIT:4>)<EOL>", "docstring": "Translate the passed serial block into string only JSON.\n\n        Args:\n            def_buf (SerialBlock): Any :class:`~ekmmeters.SerialBlock` object.\n\n        Returns:\n            str: JSON rendering of meter record.", "id": "f2325:c29:m14"}
{"signature": "def maybe_call_fn_and_grads(fn,<EOL>fn_arg_list,<EOL>result=None,<EOL>grads=None,<EOL>check_non_none_grads=True,<EOL>name=None):", "body": "with tf.compat.v1.name_scope(name, '<STR_LIT>',<EOL>[fn_arg_list, result, grads]):<EOL><INDENT>fn_arg_list = (list(fn_arg_list) if is_list_like(fn_arg_list)<EOL>else [fn_arg_list])<EOL>result, grads = _value_and_gradients(fn, fn_arg_list, result, grads)<EOL>if not all(r.dtype.is_floating<EOL>for r in (result if is_list_like(result) else [result])):  <EOL><INDENT>raise TypeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>if len(fn_arg_list) != len(grads):<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>if check_non_none_grads and any(g is None for g in grads):<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'.format(fn_arg_list, grads))<EOL><DEDENT>return result, grads<EOL><DEDENT>", "docstring": "Calls `fn` and computes the gradient of the result wrt `args_list`.", "id": "f15516:m8"}
{"signature": "def list_virtual_machine_scale_set_vm_network_interfaces(<EOL>self, resource_group_name, virtual_machine_scale_set_name, virtualmachine_index, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_virtual_machine_scale_set_vm_network_interfaces.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_machine_scale_set_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtualmachine_index, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkInterfacePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkInterfacePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets information about all network interfaces in a virtual machine in a\n        virtual machine scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_machine_scale_set_name: The name of the virtual machine\n         scale set.\n        :type virtual_machine_scale_set_name: str\n        :param virtualmachine_index: The virtual machine index.\n        :type virtualmachine_index: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkInterface\n        :rtype:\n         ~azure.mgmt.network.v2019_02_01.models.NetworkInterfacePaged[~azure.mgmt.network.v2019_02_01.models.NetworkInterface]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34946:c0:m14"}
{"signature": "def _set_subtlv_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__subtlv_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/extended_admin_group/state/subtlv_type (identityref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_subtlv_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_subtlv_type() directly.\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22863:c0:m3"}
{"signature": "def _get_status(self):", "body": "return self.__status<EOL>", "docstring": "Getter method for status, mapped from YANG variable /interfaces/interface/routed_vlan/ipv6/addresses/address/state/status (enumeration)\n\n    YANG Description: [adapted from IETF IP model RFC 7277]\n\nThe status of an address.  Most of the states correspond\nto states from the IPv6 Stateless Address\nAutoconfiguration protocol.", "id": "f22037:c0:m11"}
{"signature": "def validate_twilio(attr, value):", "body": "if attr in (\"<STR_LIT>\", \"<STR_LIT:to>\"):<EOL><INDENT>check_valid(\"<STR_LIT>\", attr, value, validus.isphone, \"<STR_LIT>\")<EOL><DEDENT>elif attr in (\"<STR_LIT>\"):<EOL><INDENT>check_valid(\"<STR_LIT>\", attr, value, validus.isurl, \"<STR_LIT:url>\")<EOL><DEDENT>", "docstring": "Twilio input validator function.", "id": "f6686:m5"}
{"signature": "def _set_admin_groups(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=admin_groups.admin_groups,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__admin_groups = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for admin_groups, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_secondary_paths/p2p_secondary_path/admin_groups (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_admin_groups is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_admin_groups() directly.\n\n    YANG Description: Top-level container for include/exclude constraints for\nlink affinities", "id": "f22262:c0:m12"}
{"signature": "def _get_subtlv_type(self):", "body": "return self.__subtlv_type<EOL>", "docstring": "Getter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/te_default_metric/state/subtlv_type (identityref)\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22809:c1:m2"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualNetworkGatewayPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualNetworkGatewayPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all virtual network gateways by resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualNetworkGateway\n        :rtype:\n         ~azure.mgmt.network.v2018_04_01.models.VirtualNetworkGatewayPaged[~azure.mgmt.network.v2018_04_01.models.VirtualNetworkGateway]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33812:c0:m8"}
{"signature": "def add_args(self, parser):", "body": "pass<EOL>", "docstring": "Adds arguments to the argument parser. This is used to modify which arguments are processed by the command.\n\nFor a full description of the argument parser see https://docs.python.org/3/library/argparse.html.\n\n:param parser: The argument parser object", "id": "f13942:c0:m4"}
{"signature": "def _set_interface(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__interface = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for interface, mapped from YANG variable /network_instances/network_instance/protocols/protocol/static_routes/static/next_hops/next_hop/interface_ref/state/interface (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_interface is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_interface() directly.\n\n    YANG Description: Reference to a base interface.  If a reference to a\nsubinterface is required, this leaf must be specified\nto indicate the base interface.", "id": "f22387:c1:m3"}
{"signature": "@nox.session<EOL>def lint(session):", "body": "session.install('<STR_LIT>')<EOL>session.run('<STR_LIT>',<EOL>'<STR_LIT>')<EOL>", "docstring": "Run flake8.\n    Returns a failure if flake8 finds linting errors or sufficiently\n    serious code quality issues.", "id": "f12321:m1"}
{"signature": "def _get_auth_password(self):", "body": "return self.__auth_password<EOL>", "docstring": "Getter method for auth_password, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/authentication/key/config/auth_password (oc-types:routing-password)\n\nYANG Description: Authentication key string.", "id": "f22457:c1:m2"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/config/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is\nenabled for the neighbour or group", "id": "f23201:c0:m6"}
{"signature": "def base64_encode(nb):", "body": "for ws in nb.worksheets:<EOL><INDENT>for cell in ws.cells:<EOL><INDENT>if cell.cell_type == '<STR_LIT:code>':<EOL><INDENT>for output in cell.outputs:<EOL><INDENT>if '<STR_LIT>' in output:<EOL><INDENT>output.png = encodestring(output.png).decode('<STR_LIT:ascii>')<EOL><DEDENT>if '<STR_LIT>' in output:<EOL><INDENT>output.jpeg = encodestring(output.jpeg).decode('<STR_LIT:ascii>')<EOL><DEDENT><DEDENT><DEDENT><DEDENT><DEDENT>return nb<EOL>", "docstring": "Base64 encode all bytes objects in the notebook.\n\n    These will be b64-encoded unicode strings\n\n    Note: This is never used", "id": "f21576:m5"}
{"signature": "def get(<EOL>self, resource_group_name, network_watcher_name, connection_monitor_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", network_watcher_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", connection_monitor_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a connection monitor by name.\n\n        :param resource_group_name: The name of the resource group containing\n         Network Watcher.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the Network Watcher resource.\n        :type network_watcher_name: str\n        :param connection_monitor_name: The name of the connection monitor.\n        :type connection_monitor_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ConnectionMonitorResult or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_10_01.models.ConnectionMonitorResult\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.network.v2018_10_01.models.ErrorResponseException>`", "id": "f30287:c0:m3"}
{"signature": "def torus(script, major_radius=<NUM_LIT>, minor_radius=<NUM_LIT:1.0>, inner_diameter=None,<EOL>outer_diameter=None, major_segments=<NUM_LIT>, minor_segments=<NUM_LIT:12>,<EOL>color=None):", "body": "if inner_diameter is not None and outer_diameter is not None:<EOL><INDENT>major_radius = (inner_diameter + outer_diameter) / <NUM_LIT:4><EOL>minor_radius = major_radius - inner_diameter / <NUM_LIT:2><EOL><DEDENT>filter_xml = '<STR_LIT>'.join([<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>' % major_radius,<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>' % minor_radius,<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>' % major_segments,<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>' % minor_segments,<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'])<EOL>util.write_filter(script, filter_xml)<EOL>if isinstance(script, FilterScript):<EOL><INDENT>script.add_layer('<STR_LIT>', change_layer=True)<EOL><DEDENT>if color is not None:<EOL><INDENT>vert_color.function(script, color=color)<EOL><DEDENT>return None<EOL>", "docstring": "Create a torus mesh\n\n    Args:\n        major_radius (float, (optional)): radius from the origin to the\n            center of the cross sections\n        minor_radius (float, (optional)): radius of the torus cross\n            section\n        inner_diameter (float, (optional)): inner diameter of torus. If\n            both inner_diameter and outer_diameter are provided then\n            these will override major_radius and minor_radius.,\n        outer_diameter (float, (optional)): outer diameter of torus. If\n            both inner_diameter and outer_diameter are provided then\n            these will override major_radius and minor_radius.\n        major_segments (int (optional)): number of segments for the main\n            ring of the torus\n        minor_segments (int (optional)): number of segments for the minor\n            ring of the torus\n        color (str (optional)): color name to apply vertex colors to the\n            newly created mesh\n\n    Returns:\n        None", "id": "f9642:m4"}
{"signature": "def get_tier_names(self):", "body": "return self.tiers.keys()<EOL>", "docstring": "List all the tier names.\n\n        :returns: List of all tier names", "id": "f14843:c0:m56"}
{"signature": "def min(self, axis):", "body": "raise NotImplementedError<EOL>", "docstring": "Return the minimum of the array elements over the given axis or axes.", "id": "f986:c0:m11"}
{"signature": "def _get_name(self):", "body": "return self.__name<EOL>", "docstring": "Getter method for name, mapped from YANG variable /network_instances/network_instance/protocols/protocol/name (leafref)\n\n    YANG Description: An operator-assigned identifier for the routing\nor forwarding protocol. For some processes this\nleaf may be system defined.", "id": "f23159:c1:m5"}
{"signature": "def add_owner(<EOL>self, application_object_id, url, additional_properties=None, custom_headers=None, raw=False, **operation_config):", "body": "parameters = models.AddOwnerParameters(additional_properties=additional_properties, url=url)<EOL>url = self.add_owner.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", application_object_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.tenant_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.GraphErrorException(self._deserialize, response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Add an owner to an application.\n\n        :param application_object_id: The object ID of the application to\n         which to add the owner.\n        :type application_object_id: str\n        :param url: A owner object URL, such as\n         \"https://graph.windows.net/0b1f9851-1bf0-433f-aec3-cb9272f093dc/directoryObjects/f260bbc4-c254-447b-94cf-293b5ec434dd\",\n         where \"0b1f9851-1bf0-433f-aec3-cb9272f093dc\" is the tenantId and\n         \"f260bbc4-c254-447b-94cf-293b5ec434dd\" is the objectId of the owner\n         (user, application, servicePrincipal, group) to be added.\n        :type url: str\n        :param additional_properties: Unmatched properties from the message\n         are deserialized this collection\n        :type additional_properties: dict[str, object]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`GraphErrorException<azure.graphrbac.models.GraphErrorException>`", "id": "f37163:c0:m7"}
{"signature": "def decode(a, encoding=None, errors=None):", "body": "return _to_string_or_unicode_array(<EOL>_vec_string(a, object_, '<STR_LIT>', _clean_args(encoding, errors)))<EOL>", "docstring": "Calls `str.decode` element-wise.\n\nThe set of available codecs comes from the Python standard library,\nand may be extended at runtime.  For more information, see the\n:mod:`codecs` module.\n\nParameters\n----------\na : array_like of str or unicode\n\nencoding : str, optional\n   The name of an encoding\n\nerrors : str, optional\n   Specifies how to handle encoding errors\n\nReturns\n-------\nout : ndarray\n\nSee also\n--------\nstr.decode\n\nNotes\n-----\nThe type of the result will depend on the encoding specified.\n\nExamples\n--------\n>>> c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n>>> c\narray(['aAaAaA', '  aA  ', 'abBABba'],\n    dtype='|S7')\n>>> np.char.encode(c, encoding='cp037')\narray(['\\\\x81\\\\xc1\\\\x81\\\\xc1\\\\x81\\\\xc1', '@@\\\\x81\\\\xc1@@',\n    '\\\\x81\\\\x82\\\\xc2\\\\xc1\\\\xc2\\\\x82\\\\x81'],\n    dtype='|S7')", "id": "f19052:m17"}
{"signature": "def CCompiler_customize_cmd(self, cmd, ignore=()):", "body": "log.info('<STR_LIT>' % (self.__class__.__name__,<EOL>cmd.__class__.__name__))<EOL>def allow(attr):<EOL><INDENT>return getattr(cmd, attr, None) is not None and attr not in ignore<EOL><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>self.set_include_dirs(cmd.include_dirs)<EOL><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>for (name, value) in cmd.define:<EOL><INDENT>self.define_macro(name, value)<EOL><DEDENT><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>for macro in cmd.undef:<EOL><INDENT>self.undefine_macro(macro)<EOL><DEDENT><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>self.set_libraries(self.libraries + cmd.libraries)<EOL><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>self.set_library_dirs(self.library_dirs + cmd.library_dirs)<EOL><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>self.set_runtime_library_dirs(cmd.rpath)<EOL><DEDENT>if allow('<STR_LIT>'):<EOL><INDENT>self.set_link_objects(cmd.link_objects)<EOL><DEDENT>", "docstring": "Customize compiler using distutils command.\n\nParameters\n----------\ncmd : class instance\n    An instance inheriting from `distutils.cmd.Command`.\nignore : sequence of str, optional\n    List of `CCompiler` commands (without ``'set_'``) that should not be\n    altered. Strings that are checked for are:\n    ``('include_dirs', 'define', 'undef', 'libraries', 'library_dirs',\n    'rpath', 'link_objects')``.\n\nReturns\n-------\nNone", "id": "f19163:m4"}
{"signature": "def set_parent(self, parent) -> object:", "body": "ret = self<EOL>if parent is not None:<EOL><INDENT>ret = self._sig.set_parent(parent)<EOL>self.resolve()<EOL><DEDENT>elif not hasattr(self, '<STR_LIT>'):<EOL><INDENT>self.parent = None<EOL><DEDENT>return ret<EOL>", "docstring": "When we add a parent (from Symbol), don't forget to resolve.", "id": "f4956:c0:m16"}
{"signature": "def _conn_maker(self, *args, **kwargs):", "body": "result = HTTPSConnection(*args, **kwargs)<EOL>if self.ca_certs:<EOL><INDENT>result.ca_certs = self.ca_certs<EOL>result.check_domain = self.check_domain<EOL><DEDENT>return result<EOL>", "docstring": "This is called to create a connection instance. Normally you'd\npass a connection class to do_open, but it doesn't actually check for\na class, and just expects a callable. As long as we behave just as a\nconstructor would have, we should be OK. If it ever changes so that\nwe *must* pass a class, we'll create an UnsafeHTTPSConnection class\nwhich just sets check_domain to False in the class definition, and\nchoose which one to pass to do_open.", "id": "f17267:c8:m1"}
{"signature": "def fmin_cobyla(func, x0, cons, args=(), consargs=None, rhobeg=<NUM_LIT:1.0>,<EOL>rhoend=<NUM_LIT>, iprint=<NUM_LIT:1>, maxfun=<NUM_LIT:1000>, disp=None, catol=<NUM_LIT>):", "body": "err = \"<STR_LIT>\"\"<STR_LIT>\"<EOL>try:<EOL><INDENT>len(cons)<EOL><DEDENT>except TypeError:<EOL><INDENT>if callable(cons):<EOL><INDENT>cons = [cons]<EOL><DEDENT>else:<EOL><INDENT>raise TypeError(err)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>for thisfunc in cons:<EOL><INDENT>if not callable(thisfunc):<EOL><INDENT>raise TypeError(err)<EOL><DEDENT><DEDENT><DEDENT>if consargs is None:<EOL><INDENT>consargs = args<EOL><DEDENT>con = tuple({'<STR_LIT:type>': '<STR_LIT>', '<STR_LIT>': c, '<STR_LIT:args>': consargs} for c in cons)<EOL>if disp is not None:<EOL><INDENT>iprint = disp<EOL><DEDENT>opts = {'<STR_LIT>': rhobeg,<EOL>'<STR_LIT>': rhoend,<EOL>'<STR_LIT>': iprint,<EOL>'<STR_LIT>': iprint != <NUM_LIT:0>,<EOL>'<STR_LIT>': maxfun,<EOL>'<STR_LIT>': catol}<EOL>sol = _minimize_cobyla(func, x0, args, constraints=con,<EOL>**opts)<EOL>if iprint > <NUM_LIT:0> and not sol['<STR_LIT:success>']:<EOL><INDENT>print(\"<STR_LIT>\" % (sol.message,))<EOL><DEDENT>return sol['<STR_LIT:x>']<EOL>", "docstring": "Minimize a function using the Constrained Optimization BY Linear\nApproximation (COBYLA) method. This method wraps a FORTRAN\nimplentation of the algorithm.\n\nParameters\n----------\nfunc : callable\n    Function to minimize. In the form func(x, \\\\*args).\nx0 : ndarray\n    Initial guess.\ncons : sequence\n    Constraint functions; must all be ``>=0`` (a single function\n    if only 1 constraint). Each function takes the parameters `x`\n    as its first argument.\nargs : tuple\n    Extra arguments to pass to function.\nconsargs : tuple\n    Extra arguments to pass to constraint functions (default of None means\n    use same extra arguments as those passed to func).\n    Use ``()`` for no extra arguments.\nrhobeg :\n    Reasonable initial changes to the variables.\nrhoend :\n    Final accuracy in the optimization (not precisely guaranteed). This\n    is a lower bound on the size of the trust region.\niprint : {0, 1, 2, 3}\n    Controls the frequency of output; 0 implies no output.  Deprecated.\ndisp : {0, 1, 2, 3}\n    Over-rides the iprint interface.  Preferred.\nmaxfun : int\n    Maximum number of function evaluations.\ncatol : float\n    Absolute tolerance for constraint violations.\n\nReturns\n-------\nx : ndarray\n    The argument that minimises `f`.\n\nSee also\n--------\nminimize: Interface to minimization algorithms for multivariate\n    functions. See the 'COBYLA' `method` in particular.\n\nNotes\n-----\nThis algorithm is based on linear approximations to the objective\nfunction and each constraint. We briefly describe the algorithm.\n\nSuppose the function is being minimized over k variables. At the\njth iteration the algorithm has k+1 points v_1, ..., v_(k+1),\nan approximate solution x_j, and a radius RHO_j.\n(i.e. linear plus a constant) approximations to the objective\nfunction and constraint functions such that their function values\nagree with the linear approximation on the k+1 points v_1,.., v_(k+1).\nThis gives a linear program to solve (where the linear approximations\nof the constraint functions are constrained to be non-negative).\n\nHowever the linear approximations are likely only good\napproximations near the current simplex, so the linear program is\ngiven the further requirement that the solution, which\nwill become x_(j+1), must be within RHO_j from x_j. RHO_j only\ndecreases, never increases. The initial RHO_j is rhobeg and the\nfinal RHO_j is rhoend. In this way COBYLA's iterations behave\nlike a trust region algorithm.\n\nAdditionally, the linear program may be inconsistent, or the\napproximation may give poor improvement. For details about\nhow these issues are resolved, as well as how the points v_i are\nupdated, refer to the source code or the references below.\n\n\nReferences\n----------\nPowell M.J.D. (1994), \"A direct search optimization method that models\nthe objective and constraint functions by linear interpolation.\", in\nAdvances in Optimization and Numerical Analysis, eds. S. Gomez and\nJ-P Hennart, Kluwer Academic (Dordrecht), pp. 51-67\n\nPowell M.J.D. (1998), \"Direct search algorithms for optimization\ncalculations\", Acta Numerica 7, 287-336\n\nPowell M.J.D. (2007), \"A view of algorithms for optimization without\nderivatives\", Cambridge University Technical Report DAMTP 2007/NA03\n\n\nExamples\n--------\nMinimize the objective function f(x,y) = x*y subject\nto the constraints x**2 + y**2 < 1 and y > 0::\n\n    >>> def objective(x):\n    ...     return x[0]*x[1]\n    ...\n    >>> def constr1(x):\n    ...     return 1 - (x[0]**2 + x[1]**2)\n    ...\n    >>> def constr2(x):\n    ...     return x[1]\n    ...\n    >>> fmin_cobyla(objective, [0.0, 0.1], [constr1, constr2], rhoend=1e-7)\n\n       Normal return from subroutine COBYLA\n\n       NFVALS =   64   F =-5.000000E-01    MAXCV = 1.998401E-14\n       X =-7.071069E-01   7.071067E-01\n    array([-0.70710685,  0.70710671])\n\nThe exact solution is (-sqrt(2)/2, sqrt(2)/2).", "id": "f19408:m0"}
{"signature": "def _check_unreachable(self, node):", "body": "unreach_stmt = node.next_sibling()<EOL>if unreach_stmt is not None:<EOL><INDENT>self.add_message(\"<STR_LIT>\", node=unreach_stmt)<EOL><DEDENT>", "docstring": "check unreachable code", "id": "f18869:c8:m25"}
{"signature": "def setinputsizes(self, sizes):", "body": "pass<EOL>", "docstring": "Does nothing by default", "id": "f9169:c4:m12"}
{"signature": "@classmethod<EOL><INDENT>def read_from(cls, data_stream, num_to_read):<DEDENT>", "body": "vlrlist = cls()<EOL>for _ in range(num_to_read):<EOL><INDENT>raw = RawVLR.read_from(data_stream)<EOL>try:<EOL><INDENT>vlrlist.append(vlr_factory(raw))<EOL><DEDENT>except UnicodeDecodeError:<EOL><INDENT>logger.error(\"<STR_LIT>\".format(raw))<EOL><DEDENT><DEDENT>return vlrlist<EOL>", "docstring": "Reads vlrs and parse them if possible from the stream\n\n        Parameters\n        ----------\n        data_stream : io.BytesIO\n                      stream to read from\n        num_to_read : int\n                      number of vlrs to be read\n\n        Returns\n        -------\n        pylas.vlrs.vlrlist.VLRList\n            List of vlrs", "id": "f5991:c1:m13"}
{"signature": "@log_calls<EOL><INDENT>def download(self, source, target, mpi=None, pos=<NUM_LIT:0>, chunk=<NUM_LIT:0>, part=<NUM_LIT:0>):<DEDENT>", "body": "s3url = S3URL(source)<EOL>obj = self.lookup(s3url)<EOL>if obj is None:<EOL><INDENT>raise Failure('<STR_LIT>' % (s3url.path,))<EOL><DEDENT>if not mpi:<EOL><INDENT>if self.opt.dry_run:<EOL><INDENT>message('<STR_LIT>', source, target)<EOL>return<EOL><DEDENT>elif self.opt.sync_check and self.sync_check(LocalMD5Cache(target), obj):<EOL><INDENT>message('<STR_LIT>', source, target)<EOL>return<EOL><DEDENT>elif not self.opt.force and os.path.exists(target):<EOL><INDENT>raise Failure('<STR_LIT>' % target)<EOL><DEDENT>fsize = int(obj['<STR_LIT>'])<EOL>if fsize < self.opt.max_singlepart_download_size:<EOL><INDENT>mpi = ThreadUtil.MultipartItem(tempfile_get(target))<EOL>mpi.total = <NUM_LIT:1><EOL>pos = <NUM_LIT:0><EOL>chunk = fsize<EOL><DEDENT>else:<EOL><INDENT>for args in self.get_file_splits(tempfile_get(target), source, target, fsize, self.opt.multipart_split_size):<EOL><INDENT>self.pool.download(*args)<EOL><DEDENT>return<EOL><DEDENT><DEDENT>tempfile = mpi.id<EOL>if self.opt.recursive:<EOL><INDENT>self.mkdirs(tempfile)<EOL><DEDENT>response = self.s3.get_object(Bucket=s3url.bucket, Key=s3url.path, Range='<STR_LIT>' % (pos, pos + chunk - <NUM_LIT:1>))<EOL>self.write_file_chunk(tempfile, pos, chunk, response['<STR_LIT>'])<EOL>if mpi.complete({'<STR_LIT>': part}):<EOL><INDENT>try:<EOL><INDENT>self.update_privilege(obj, tempfile)<EOL>self._verify_file_size(obj, tempfile)<EOL>tempfile_set(tempfile, target)<EOL>message('<STR_LIT>', source, target)<EOL><DEDENT>except Exception as e:<EOL><INDENT>tempfile_set(tempfile, None)<EOL>raise Failure('<STR_LIT>' % (e.message, source))<EOL><DEDENT><DEDENT>", "docstring": "Thread worker for download operation.", "id": "f16741:c10:m13"}
{"signature": "def delete(<EOL>self, policy_definition_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", policy_definition_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes a policy definition in a subscription.\n\n        This operation deletes the policy definition in the given subscription\n        with the given name.\n\n        :param policy_definition_name: The name of the policy definition to\n         delete.\n        :type policy_definition_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37465:c0:m2"}
{"signature": "def get_stats(<EOL>self, resource_group_name, circuit_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_stats.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", circuit_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the stats from an express route circuit in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ExpressRouteCircuitStats or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2017_10_01.models.ExpressRouteCircuitStats or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33126:c0:m14"}
{"signature": "def set(self, token, request, *args, **kwargs):", "body": "if hasattr(request, '<STR_LIT:user>') and request.user:<EOL><INDENT>user = request.user<EOL><DEDENT>elif self.current_user:<EOL><INDENT>user = self.current_user()<EOL><DEDENT>client = request.client<EOL>tokens = self.query.filter_by(<EOL>client_id=client.client_id,<EOL>user_id=user.id).all()<EOL>if tokens:<EOL><INDENT>for tk in tokens:<EOL><INDENT>self.session.delete(tk)<EOL><DEDENT>self.session.commit()<EOL><DEDENT>expires_in = token.get('<STR_LIT>')<EOL>expires = datetime.utcnow() + timedelta(seconds=expires_in)<EOL>tok = self.model(**token)<EOL>tok.expires = expires<EOL>tok.client_id = client.client_id<EOL>tok.user_id = user.id<EOL>self.session.add(tok)<EOL>self.session.commit()<EOL>return tok<EOL>", "docstring": "Creates a Token object and removes all expired tokens that belong\n        to the user\n\n        :param token: token object\n        :param request: OAuthlib request object", "id": "f16089:c4:m2"}
{"signature": "def list_queues(self):", "body": "try:<EOL><INDENT>queues = self.mgmt_client.list_queues()<EOL><DEDENT>except requests.exceptions.ConnectionError as e:<EOL><INDENT>raise ServiceBusConnectionError(\"<STR_LIT>\".format(self.service_namespace), e)<EOL><DEDENT>queue_clients = []<EOL>for queue in queues:<EOL><INDENT>queue_clients.append(QueueClient.from_entity(<EOL>self._get_host(), queue,<EOL>shared_access_key_name=self.shared_access_key_name,<EOL>shared_access_key_value=self.shared_access_key_value,<EOL>mgmt_client=self.mgmt_client,<EOL>debug=self.debug))<EOL><DEDENT>return queue_clients<EOL>", "docstring": "Get clients for all queue entities in the namespace.\n\n        :rtype: list[~azure.servicebus.servicebus_client.QueueClient]\n        :raises: ~azure.servicebus.common.errors.ServiceBusConnectionError if the namespace is not found.\n\n        Example:\n            .. literalinclude:: ../examples/test_examples.py\n                :start-after: [START list_queues]\n                :end-before: [END list_queues]\n                :language: python\n                :dedent: 4\n                :caption: List the queues from Service Bus client", "id": "f39483:c0:m4"}
{"signature": "def _get_restart_suppress(self):", "body": "return self.__restart_suppress<EOL>", "docstring": "Getter method for restart_suppress, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart_suppress (boolean)\n\n    YANG Description: When set to true, adjacency is not advertised. The SA bit is used by a\nstarting router to  request that its neighbor suppress advertisement of\nthe adjacency  to the starting router in the neighbor's LSPs.", "id": "f22419:c1:m50"}
{"signature": "def walkParams(intf, discovered):", "body": "for si in intf._interfaces:<EOL><INDENT>yield from walkParams(si, discovered)<EOL><DEDENT>for p in intf._params:<EOL><INDENT>if p not in discovered:<EOL><INDENT>discovered.add(p)<EOL>yield p<EOL><DEDENT><DEDENT>", "docstring": "walk parameter instances on this interface", "id": "f1342:m1"}
{"signature": "def init_logger(self):", "body": "return PJFLogger.init_logger()<EOL>", "docstring": "Init the default logger", "id": "f5931:c0:m9"}
{"signature": "@internal<EOL>def raise_StopSimulation(sim):", "body": "raise StopSimumulation()<EOL>return<EOL>yield<EOL>", "docstring": "Simulation process used to stop simulation", "id": "f1445:m1"}
{"signature": "def delete(<EOL>self, resource_group_name, circuit_name, peering_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>circuit_name=circuit_name,<EOL>peering_name=peering_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified peering from the specified express route circuit.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param peering_name: The name of the peering.\n        :type peering_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34228:c0:m2"}
{"signature": "def _get_package_data(root, file_patterns=None):", "body": "if file_patterns is None:<EOL><INDENT>file_patterns = ['<STR_LIT:*>']<EOL><DEDENT>return _get_files(file_patterns, pjoin(HERE, root))<EOL>", "docstring": "Expand file patterns to a list of `package_data` paths.\n\n    Parameters\n    -----------\n    root: str\n        The relative path to the package root from `HERE`.\n    file_patterns: list or str, optional\n        A list of glob patterns for the data file locations.\n        The globs can be recursive if they include a `**`.\n        They should be relative paths from the root or\n        absolute paths.  If not given, all files will be used.\n\n    Note:\n    Files in `node_modules` are ignored.", "id": "f9671:m19"}
{"signature": "def delete(<EOL>self, resource_group_name, network_interface_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_interface_name=network_interface_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified network interface.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_interface_name: The name of the network interface.\n        :type network_interface_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29516:c0:m5"}
{"signature": "def list(<EOL>self, resource_group_name, account_name, pool_name, volume_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", pool_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", volume_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.SnapshotPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.SnapshotPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "List snapshots.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param account_name: The name of the NetApp account\n        :type account_name: str\n        :param pool_name: The name of the capacity pool\n        :type pool_name: str\n        :param volume_name: The name of the volume\n        :type volume_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Snapshot\n        :rtype:\n         ~azure.mgmt.netapp.models.SnapshotPaged[~azure.mgmt.netapp.models.Snapshot]\n        :raises:\n         :class:`ErrorException<azure.mgmt.netapp.models.ErrorException>`", "id": "f36622:c0:m1"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/mpls/te_interface_attributes/interface/interface_ref/config (container)\n\nYANG Description: Configured reference to interface / subinterface", "id": "f22211:c1:m2"}
{"signature": "def _get_interface_mode(self):", "body": "return self.__interface_mode<EOL>", "docstring": "Getter method for interface_mode, mapped from YANG variable /interfaces/interface/ethernet/switched_vlan/config/interface_mode (oc-vlan-types:vlan-mode-type)\n\n    YANG Description: Set the interface to access or trunk mode for\nVLANs", "id": "f22003:c0:m2"}
{"signature": "def create_project(<EOL>self, name, description=None, domain_id=None, classification_type=None, target_export_platforms=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_project.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT:name>'] = self._serialize.query(\"<STR_LIT:name>\", name, '<STR_LIT:str>')<EOL>if description is not None:<EOL><INDENT>query_parameters['<STR_LIT:description>'] = self._serialize.query(\"<STR_LIT:description>\", description, '<STR_LIT:str>')<EOL><DEDENT>if domain_id is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", domain_id, '<STR_LIT:str>')<EOL><DEDENT>if classification_type is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", classification_type, '<STR_LIT:str>')<EOL><DEDENT>if target_export_platforms is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", target_export_platforms, '<STR_LIT>', div='<STR_LIT:U+002C>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.api_key, '<STR_LIT:str>')<EOL>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.CustomVisionErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Create a project.\n\n        :param name: Name of the project.\n        :type name: str\n        :param description: The description of the project.\n        :type description: str\n        :param domain_id: The id of the domain to use for this project.\n         Defaults to General.\n        :type domain_id: str\n        :param classification_type: The type of classifier to create for this\n         project. Possible values include: 'Multiclass', 'Multilabel'\n        :type classification_type: str\n        :param target_export_platforms: List of platforms the trained model is\n         intending exporting to.\n        :type target_export_platforms: list[str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Project or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.cognitiveservices.vision.customvision.training.models.Project\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`CustomVisionErrorException<azure.cognitiveservices.vision.customvision.training.models.CustomVisionErrorException>`", "id": "f28122:c1:m26"}
{"signature": "def _prints_status_file(self):  ", "body": "if PyFunceble.INTERN[\"<STR_LIT>\"]:<EOL><INDENT>output = (<EOL>self.output_parent_dir<EOL>+ PyFunceble.OUTPUTS[\"<STR_LIT>\"][\"<STR_LIT>\"]<EOL>+ self.domain_status<EOL>)<EOL>if PyFunceble.CONFIGURATION[\"<STR_LIT>\"]:<EOL><INDENT>Prints(<EOL>[self.tested, self.domain_status, self.source], \"<STR_LIT>\", output, True<EOL>).data()<EOL><DEDENT>elif PyFunceble.CONFIGURATION[\"<STR_LIT>\"]:<EOL><INDENT>if self.domain_status.lower() in PyFunceble.STATUS[\"<STR_LIT:list>\"][\"<STR_LIT>\"]:<EOL><INDENT>if PyFunceble.HTTP_CODE[\"<STR_LIT>\"]:<EOL><INDENT>data_to_print = [<EOL>self.tested,<EOL>self.expiration_date,<EOL>self.source,<EOL>PyFunceble.INTERN[\"<STR_LIT>\"],<EOL>PyFunceble.CURRENT_TIME,<EOL>]<EOL><DEDENT>else:<EOL><INDENT>data_to_print = [<EOL>self.tested,<EOL>self.expiration_date,<EOL>self.source,<EOL>PyFunceble.CURRENT_TIME,<EOL>]<EOL><DEDENT>Prints(<EOL>data_to_print, PyFunceble.STATUS[\"<STR_LIT>\"][\"<STR_LIT>\"], output, True<EOL>).data()<EOL><DEDENT>elif self.domain_status.lower() in PyFunceble.STATUS[\"<STR_LIT:list>\"][\"<STR_LIT>\"]:<EOL><INDENT>data_to_print = [self.tested, self.source, PyFunceble.CURRENT_TIME]<EOL>Prints(<EOL>data_to_print,<EOL>PyFunceble.STATUS[\"<STR_LIT>\"][\"<STR_LIT>\"],<EOL>output,<EOL>True,<EOL>).data()<EOL><DEDENT>elif self.domain_status.lower() in PyFunceble.STATUS[\"<STR_LIT:list>\"][\"<STR_LIT>\"]:<EOL><INDENT>if PyFunceble.HTTP_CODE[\"<STR_LIT>\"]:<EOL><INDENT>data_to_print = [<EOL>self.tested,<EOL>PyFunceble.INTERN[\"<STR_LIT>\"],<EOL>self.domain_status,<EOL>self.source,<EOL>PyFunceble.INTERN[\"<STR_LIT>\"],<EOL>PyFunceble.CURRENT_TIME,<EOL>]<EOL><DEDENT>else:<EOL><INDENT>data_to_print = [<EOL>self.tested,<EOL>PyFunceble.INTERN[\"<STR_LIT>\"],<EOL>self.domain_status,<EOL>self.source,<EOL>PyFunceble.CURRENT_TIME,<EOL>]<EOL><DEDENT>Prints(<EOL>data_to_print,<EOL>PyFunceble.STATUS[\"<STR_LIT>\"][\"<STR_LIT>\"],<EOL>output,<EOL>True,<EOL>).data()<EOL><DEDENT>elif self.domain_status.lower() in PyFunceble.STATUS[\"<STR_LIT:list>\"][\"<STR_LIT>\"]:<EOL><INDENT>if PyFunceble.HTTP_CODE[\"<STR_LIT>\"]:<EOL><INDENT>data_to_print = [<EOL>self.tested,<EOL>self.source,<EOL>PyFunceble.INTERN[\"<STR_LIT>\"],<EOL>PyFunceble.CURRENT_TIME,<EOL>]<EOL><DEDENT>else:<EOL><INDENT>data_to_print = [<EOL>self.tested,<EOL>self.source,<EOL>PyFunceble.CURRENT_TIME,<EOL>]<EOL><DEDENT>Prints(<EOL>data_to_print,<EOL>PyFunceble.STATUS[\"<STR_LIT>\"][\"<STR_LIT>\"],<EOL>output,<EOL>True,<EOL>).data()<EOL><DEDENT><DEDENT><DEDENT>", "docstring": "Logic behind the printing (in file) when generating status file.", "id": "f8232:c0:m6"}
{"signature": "def add_face_from_url(<EOL>self, large_face_list_id, url, user_data=None, target_face=None, custom_headers=None, raw=False, **operation_config):", "body": "image_url = models.ImageUrl(url=url)<EOL>url = self.add_face_from_url.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", large_face_list_id, '<STR_LIT:str>', max_length=<NUM_LIT:64>, pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if user_data is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", user_data, '<STR_LIT:str>', max_length=<NUM_LIT>)<EOL><DEDENT>if target_face is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", target_face, '<STR_LIT>', div='<STR_LIT:U+002C>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>body_content = self._serialize.body(image_url, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.APIErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Add a face to a large face list. The input face is specified as an\n        image with a targetFace rectangle. It returns a persistedFaceId\n        representing the added face, and persistedFaceId will not expire.\n\n        :param large_face_list_id: Id referencing a particular large face\n         list.\n        :type large_face_list_id: str\n        :param url: Publicly reachable URL of an image\n        :type url: str\n        :param user_data: User-specified data about the face for any purpose.\n         The maximum length is 1KB.\n        :type user_data: str\n        :param target_face: A face rectangle to specify the target face to be\n         added to a person in the format of \"targetFace=left,top,width,height\".\n         E.g. \"targetFace=10,10,100,100\". If there is more than one face in the\n         image, targetFace is required to specify which face to add. No\n         targetFace means there is only one face detected in the entire image.\n        :type target_face: list[int]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: PersistedFace or ClientRawResponse if raw=true\n        :rtype: ~azure.cognitiveservices.vision.face.models.PersistedFace or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`APIErrorException<azure.cognitiveservices.vision.face.models.APIErrorException>`", "id": "f39000:c0:m11"}
{"signature": "def getA(self):", "body": "return self.__array__()<EOL>", "docstring": "Return `self` as an `ndarray` object.\n\nEquivalent to ``np.asarray(self)``.\n\nParameters\n----------\nNone\n\nReturns\n-------\nret : ndarray\n    `self` as an `ndarray`\n\nExamples\n--------\n>>> x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n>>> x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])", "id": "f19135:c0:m27"}
{"signature": "def read_entry(self, file_name):", "body": "file_path = os.path.join(self.EXTRACTION_CACHE_PATH, file_name)<EOL>logger.info(f'<STR_LIT>')<EOL>return joblib.load(file_path)<EOL>", "docstring": "Args:\n    file_name (str):\n\nReturns:\n    pd.DataFrame:", "id": "f4522:c0:m10"}
{"signature": "def crypto_sign(msg, sk):", "body": "if len(sk) != SECRETKEYBYTES:<EOL><INDENT>raise ValueError(\"<STR_LIT>\" % len(sk))<EOL><DEDENT>vkbytes = sk[PUBLICKEYBYTES:]<EOL>skbytes = sk[:PUBLICKEYBYTES]<EOL>sig = djbec.signature(msg, skbytes, vkbytes)<EOL>return sig + msg<EOL>", "docstring": "Return signature+message given message and secret key.\n    The signature is the first SIGNATUREBYTES bytes of the return value.\n    A copy of msg is in the remainder.", "id": "f17131:m1"}
{"signature": "def _get_link_delay_variation(self):", "body": "return self.__link_delay_variation<EOL>", "docstring": "Getter method for link_delay_variation, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/link_delay_variation (container)\n\nYANG Description: This container defines unidirectional link delay variation.", "id": "f22782:c1:m62"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/authentication/state (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_state is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_state() directly.\n\n    YANG Description: State information associated\nwith authentication", "id": "f22301:c0:m6"}
{"signature": "def get_checklists(self, **query_params):", "body": "checklists = self.get_checklist_json(self.base_uri,<EOL>query_params=query_params)<EOL>checklists_list = []<EOL>for checklist_json in checklists:<EOL><INDENT>checklists_list.append(self.create_checklist(checklist_json))<EOL><DEDENT>return checklists_list<EOL>", "docstring": "Get the checklists for this card. Returns a list of Checklist objects.\n\nReturns:\n    list(Checklist): The checklists attached to this card", "id": "f12587:c0:m4"}
{"signature": "def _get_event_type(self):", "body": "return self.__event_type<EOL>", "docstring": "Getter method for event_type, mapped from YANG variable /system/aaa/accounting/events/event/state/event_type (identityref)\n\n    YANG Description: The type of activity to record at the AAA accounting\nserver", "id": "f21889:c0:m2"}
{"signature": "def create_pool(self, name, slots, description):", "body": "raise NotImplementedError()<EOL>", "docstring": "Create a pool.\n\n        :param name: pool name\n        :param slots: pool slots amount\n        :param description: pool description", "id": "f9541:c0:m5"}
{"signature": "def isolated(func):", "body": "def wrapped(func, runner, *args, **kwargs):<EOL><INDENT>with runner.isolated_filesystem():<EOL><INDENT>with open('<STR_LIT>', '<STR_LIT:w>') as f:<EOL><INDENT>f.write('<STR_LIT>')<EOL><DEDENT>return func(runner, *args, **kwargs)<EOL><DEDENT><DEDENT>return decorator.decorator(wrapped, func)<EOL>", "docstring": "Runs a method in an isolated filesystem.\n\n    This also stubs out an app.json for convenience.", "id": "f17770:m2"}
{"signature": "def is_masked(self, column):", "body": "column = _ensure_string_from_expression(column)<EOL>if column in self.columns:<EOL><INDENT>return np.ma.isMaskedArray(self.columns[column])<EOL><DEDENT>return False<EOL>", "docstring": "Return if a column is a masked (numpy.ma) column.", "id": "f6914:c0:m59"}
{"signature": "def __getitem__(self, index: int) -> Tuple:", "body": "<EOL>indexes = self.indexes[index*self.bs:(index+<NUM_LIT:1>)*self.bs]<EOL>X, y = self.__negative_sampling(indexes)<EOL>return X, y<EOL>", "docstring": "Generate one batch of data", "id": "f14585:c0:m2"}
{"signature": "def _set_receive(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__receive = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/add_paths/state/receive (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_receive is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_receive() directly.\n\n    YANG Description: Enable ability to receive multiple path advertisements\nfor an NLRI from the neighbor or group", "id": "f23361:c0:m3"}
{"signature": "@classmethod<EOL><INDENT>def has_resuming(cls):<DEDENT>", "body": "return False<EOL>", "docstring": "Returns whether it supports to resume the fetch process.\n\n        :returns: this backend supports items resuming", "id": "f118:c0:m4"}
{"signature": "def delete(<EOL>self, resource_group_name, network_interface_name, tap_configuration_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_interface_name=network_interface_name,<EOL>tap_configuration_name=tap_configuration_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified tap configuration from the NetworkInterface.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_interface_name: The name of the network interface.\n        :type network_interface_name: str\n        :param tap_configuration_name: The name of the tap configuration.\n        :type tap_configuration_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31647:c0:m2"}
{"signature": "def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,<EOL>source_address=None):", "body": "host, port = address<EOL>err = None<EOL>for res in getaddrinfo(host, port, <NUM_LIT:0>, SOCK_STREAM):<EOL><INDENT>af, socktype, proto, canonname, sa = res<EOL>sock = None<EOL>try:<EOL><INDENT>sock = socket(af, socktype, proto)<EOL>if timeout is not _GLOBAL_DEFAULT_TIMEOUT:<EOL><INDENT>sock.settimeout(timeout)<EOL><DEDENT>if source_address:<EOL><INDENT>sock.bind(source_address)<EOL><DEDENT>sock.connect(sa)<EOL>return sock<EOL><DEDENT>except error as _:<EOL><INDENT>err = _<EOL>if sock is not None:<EOL><INDENT>sock.close()<EOL><DEDENT><DEDENT><DEDENT>if err is not None:<EOL><INDENT>raise err<EOL><DEDENT>else:<EOL><INDENT>raise error(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.", "id": "f5919:m2"}
{"signature": "def list_all(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_all.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualMachinePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualMachinePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all of the virtual machines in the specified subscription. Use\n        the nextLink property in the response to get the next page of virtual\n        machines.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualMachine\n        :rtype:\n         ~azure.mgmt.compute.v2017_12_01.models.VirtualMachinePaged[~azure.mgmt.compute.v2017_12_01.models.VirtualMachine]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24370:c0:m19"}
{"signature": "def convert_positional_argument(self, index, arg_value):", "body": "<EOL>if self._has_self:<EOL><INDENT>if index == <NUM_LIT:0>:<EOL><INDENT>return arg_value<EOL><DEDENT>index -= <NUM_LIT:1><EOL><DEDENT>arg_name = self.arg_names[index]<EOL>return self.convert_argument(arg_name, arg_value)<EOL>", "docstring": "Convert and validate a positional argument.\n\n        Args:\n            index (int): The positional index of the argument\n            arg_value (object): The value to convert and validate\n\n        Returns:\n            object: The converted value.", "id": "f17798:c0:m14"}
{"signature": "def _set_router_id(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__router_id = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for router_id, mapped from YANG variable /network_instances/network_instance/config/router_id (yang:dotted-quad)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_router_id is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_router_id() directly.\n\n    YANG Description: A identifier for the local network instance - typically\nused within associated routing protocols or signalling\nrouting information in another network instance", "id": "f22175:c0:m15"}
{"signature": "def delete(<EOL>self, resource_group_name, gallery_name, gallery_image_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>gallery_name=gallery_name,<EOL>gallery_image_name=gallery_image_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Delete a gallery image.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param gallery_name: The name of the Shared Image Gallery in which the\n         Image Definition is to be deleted.\n        :type gallery_name: str\n        :param gallery_image_name: The name of the gallery Image Definition to\n         be deleted.\n        :type gallery_image_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25383:c0:m5"}
{"signature": "def _update_globals():", "body": "if not sys.platform.startswith('<STR_LIT>') and sys.platform != '<STR_LIT>':<EOL><INDENT>return<EOL><DEDENT>incompatible = '<STR_LIT>', '<STR_LIT>'<EOL>for name in incompatible:<EOL><INDENT>del globals()[name]<EOL>__all__.remove(name)<EOL><DEDENT>", "docstring": "Patch the globals to remove the objects not available on some platforms.\n\nXXX it'd be better to test assertions about bytecode instead.", "id": "f17063:m4"}
{"signature": "@classmethod<EOL><INDENT>def to_dict(cls):<DEDENT>", "body": "d = dict()<EOL>for name, field in six.iteritems(cls._FIELDS_MAP):<EOL><INDENT>field_info = field.to_dict()<EOL>d[name] = field_info<EOL><DEDENT>return d<EOL>", "docstring": "format Validator to dict", "id": "f6048:c1:m5"}
{"signature": "def _decompose_from_posterior_marginals(<EOL>model, posterior_means, posterior_covs, parameter_samples):", "body": "try:<EOL><INDENT>model.components<EOL><DEDENT>except AttributeError:<EOL><INDENT>raise ValueError('<STR_LIT>'<EOL>'<STR_LIT>'.format(model))<EOL><DEDENT>with tf.compat.v1.name_scope('<STR_LIT>'):<EOL><INDENT>latent_sizes = [component.latent_size for component in model.components]<EOL>component_means = tf.split(posterior_means, latent_sizes, axis=-<NUM_LIT:1>)<EOL>component_covs = _split_covariance_into_marginals(<EOL>posterior_covs, latent_sizes)<EOL>num_timesteps = dist_util.prefer_static_value(<EOL>tf.shape(input=posterior_means))[-<NUM_LIT:2>]<EOL>component_ssms = model.make_component_state_space_models(<EOL>num_timesteps=num_timesteps,<EOL>param_vals=parameter_samples)<EOL>component_predictive_dists = collections.OrderedDict()<EOL>for (component, component_ssm,<EOL>component_mean, component_cov) in zip(model.components, component_ssms,<EOL>component_means, component_covs):<EOL><INDENT>component_obs_mean, component_obs_cov = (<EOL>component_ssm.latents_to_observations(<EOL>latent_means=component_mean,<EOL>latent_covs=component_cov))<EOL>component_predictive_dists[component] = sts_util.mix_over_posterior_draws(<EOL>means=component_obs_mean[..., <NUM_LIT:0>],<EOL>variances=component_obs_cov[..., <NUM_LIT:0>, <NUM_LIT:0>])<EOL><DEDENT><DEDENT>return component_predictive_dists<EOL>", "docstring": "Utility method to decompose a joint posterior into components.\n\n    Args:\n      model: `tfp.sts.Sum` instance defining an additive STS model.\n      posterior_means: float `Tensor` of shape `concat(\n        [[num_posterior_draws], batch_shape, num_timesteps, latent_size])`\n        representing the posterior mean over latents in an\n        `AdditiveStateSpaceModel`.\n      posterior_covs: float `Tensor` of shape `concat(\n        [[num_posterior_draws], batch_shape, num_timesteps,\n        latent_size, latent_size])`\n        representing the posterior marginal covariances over latents in an\n        `AdditiveStateSpaceModel`.\n      parameter_samples: Python `list` of `Tensors` representing posterior\n        samples of model parameters, with shapes `[concat([\n        [num_posterior_draws], param.prior.batch_shape,\n        param.prior.event_shape]) for param in model.parameters]`. This may\n        optionally also be a map (Python `dict`) of parameter names to\n        `Tensor` values.\n\n    Returns:\n      component_dists: A `collections.OrderedDict` instance mapping\n        component StructuralTimeSeries instances (elements of `model.components`)\n        to `tfd.Distribution` instances representing the posterior marginal\n        distributions on the process modeled by each component. Each distribution\n        has batch shape matching that of `posterior_means`/`posterior_covs`, and\n        event shape of `[num_timesteps]`.", "id": "f15504:m1"}
{"signature": "def items(self):", "body": "return ((k, v) for k, v in zip(self.keys(), self.values()))<EOL>", "docstring": "r\"\"\"Get items.\n\n        Returns:\n            Iterable[(Descriptor, value)]", "id": "f15183:c0:m5"}
{"signature": "@classmethod<EOL><INDENT>def for_mainnet(cls):<DEDENT>", "body": "return cls(host='<STR_LIT>', port=<NUM_LIT>)<EOL>", "docstring": "Creates a ``Client`` instance for use with the NEO Main Net.", "id": "f17404:c0:m1"}
{"signature": "def proxied_attribute(local_attr, proxied_attr, doc):", "body": "def fget(self):<EOL><INDENT>return getattr(getattr(self, local_attr), proxied_attr)<EOL><DEDENT>def fset(self, value):<EOL><INDENT>setattr(getattr(self, local_attr), proxied_attr, value)<EOL><DEDENT>def fdel(self):<EOL><INDENT>delattr(getattr(self, local_attr), proxied_attr)<EOL><DEDENT>return property(fget, fset, fdel, doc)<EOL>", "docstring": "Create a property that proxies attribute ``proxied_attr`` through\n    the local attribute ``local_attr``.", "id": "f21754:m0"}
{"signature": "def sproot(tck,mest=<NUM_LIT:10>):", "body": "t,c,k = tck<EOL>if k != <NUM_LIT:3>:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>try:<EOL><INDENT>c[<NUM_LIT:0>][<NUM_LIT:0>]<EOL>parametric = True<EOL><DEDENT>except:<EOL><INDENT>parametric = False<EOL><DEDENT>if parametric:<EOL><INDENT>return _ntlist(list(map(lambda c,t=t,k=k,mest=mest:sproot([t,c,k],mest),c)))<EOL><DEDENT>else:<EOL><INDENT>if len(t) < <NUM_LIT:8>:<EOL><INDENT>raise TypeError(\"<STR_LIT>\" % len(t))<EOL><DEDENT>z,ier = _fitpack._sproot(t,c,k,mest)<EOL>if ier == <NUM_LIT:10>:<EOL><INDENT>raise TypeError(\"<STR_LIT>\")<EOL><DEDENT>if ier == <NUM_LIT:0>:<EOL><INDENT>return z<EOL><DEDENT>if ier == <NUM_LIT:1>:<EOL><INDENT>warnings.warn(RuntimeWarning(\"<STR_LIT>\"))<EOL>return z<EOL><DEDENT>raise TypeError(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Find the roots of a cubic B-spline.\n\nGiven the knots (>=8) and coefficients of a cubic B-spline return the\nroots of the spline.\n\nParameters\n----------\ntck : tuple\n    A tuple (t,c,k) containing the vector of knots,\n    the B-spline coefficients, and the degree of the spline.\n    The number of knots must be >= 8, and the degree must be 3.\n    The knots must be a montonically increasing sequence.\nmest : int\n    An estimate of the number of zeros (Default is 10).\n\nReturns\n-------\nzeros : ndarray\n    An array giving the roots of the spline.\n\nSee also\n--------\nsplprep, splrep, splint, spalde, splev\nbisplrep, bisplev\nUnivariateSpline, BivariateSpline\n\n\nReferences\n----------\n.. [1] C. de Boor, \"On calculating with b-splines\", J. Approximation\n    Theory, 6, p.50-62, 1972.\n.. [2] M.G. Cox, \"The numerical evaluation of b-splines\", J. Inst. Maths\n    Applics, 10, p.134-149, 1972.\n.. [3] P. Dierckx, \"Curve and surface fitting with splines\", Monographs\n    on Numerical Analysis, Oxford University Press, 1993.", "id": "f19277:m6"}
{"signature": "def __len__(self):", "body": "return len(self.photos)<EOL>", "docstring": "The number of photos in the dataset.", "id": "f3399:c0:m2"}
{"signature": "def check_inline(self):", "body": "return check_inline(self)<EOL>", "docstring": "Return the inline keyword recognized by the compiler, empty string\n        otherwise.", "id": "f19190:c0:m13"}
{"signature": "def __init__(self, name, abooks, **kwargs):", "body": "super().__init__(name, **kwargs)<EOL>self._abooks = abooks<EOL>", "docstring": ":param name: the name to identify the address book\n:type name: str\n:param abooks: a list of address books to combine in this collection\n:type abooks: list(AddressBook)\n:param **kwargs: further arguments for the parent constructor", "id": "f4373:c3:m0"}
{"signature": "def _add_to_filemenu():", "body": "import os<EOL>import pyblish<EOL>from maya import cmds<EOL>for item in (\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\"):<EOL><INDENT>if cmds.menuItem(item, exists=True):<EOL><INDENT>cmds.deleteUI(item, menuItem=True)<EOL><DEDENT><DEDENT>icon = os.path.dirname(pyblish.__file__)<EOL>icon = os.path.join(icon, \"<STR_LIT>\", \"<STR_LIT>\")<EOL>cmds.menuItem(\"<STR_LIT>\",<EOL>divider=True,<EOL>insertAfter=\"<STR_LIT>\",<EOL>parent=\"<STR_LIT>\")<EOL>cmds.menuItem(\"<STR_LIT>\",<EOL>insertAfter=\"<STR_LIT>\",<EOL>label=\"<STR_LIT>\",<EOL>parent=\"<STR_LIT>\",<EOL>image=icon,<EOL>command=\"<STR_LIT>\")<EOL>cmds.menuItem(\"<STR_LIT>\",<EOL>insertAfter=\"<STR_LIT>\",<EOL>parent=\"<STR_LIT>\",<EOL>divider=True)<EOL>", "docstring": "Helper function for the above :func:add_to_filemenu()\n\n    This function is serialised into a string and passed on\n    to evalDeferred above.", "id": "f12821:m10"}
{"signature": "def get(<EOL>self, location, publisher_name, offer, skus, version, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT:location>': self._serialize.url(\"<STR_LIT:location>\", location, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", publisher_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", offer, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", skus, '<STR_LIT:str>'),<EOL>'<STR_LIT:version>': self._serialize.url(\"<STR_LIT:version>\", version, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a virtual machine image.\n\n        :param location: The name of a supported Azure region.\n        :type location: str\n        :param publisher_name: A valid image publisher.\n        :type publisher_name: str\n        :param offer: A valid image publisher offer.\n        :type offer: str\n        :param skus: A valid image SKU.\n        :type skus: str\n        :param version: A valid image SKU version.\n        :type version: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: VirtualMachineImage or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.compute.v2019_03_01.models.VirtualMachineImage or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25373:c0:m1"}
{"signature": "def __call__(self,index=None):", "body": "index = self._get_index(index)<EOL>if index is None:<EOL><INDENT>return<EOL><DEDENT>try:<EOL><INDENT>marquee = self.marquee<EOL>next_block = self.src_blocks[index]<EOL>self.block_index += <NUM_LIT:1><EOL>if self._silent[index]:<EOL><INDENT>print(marquee('<STR_LIT>' %<EOL>(index,self.nblocks-index-<NUM_LIT:1>)), file=io.stdout)<EOL><DEDENT>else:<EOL><INDENT>self.pre_cmd()<EOL>self.show(index)<EOL>if self.auto_all or self._auto[index]:<EOL><INDENT>print(marquee('<STR_LIT>'), file=io.stdout)<EOL><DEDENT>else:<EOL><INDENT>print(marquee('<STR_LIT>'), end='<STR_LIT:U+0020>', file=io.stdout)<EOL>ans = input().strip()<EOL>if ans:<EOL><INDENT>print(marquee('<STR_LIT>'), file=io.stdout)<EOL>return<EOL><DEDENT><DEDENT><DEDENT>try:<EOL><INDENT>save_argv = sys.argv<EOL>sys.argv = self.sys_argv<EOL>self.run_cell(next_block)<EOL>self.post_cmd()<EOL><DEDENT>finally:<EOL><INDENT>sys.argv = save_argv<EOL><DEDENT><DEDENT>except:<EOL><INDENT>self.ip_showtb(filename=self.fname)<EOL><DEDENT>else:<EOL><INDENT>self.ip_ns.update(self.user_ns)<EOL><DEDENT>if self.block_index == self.nblocks:<EOL><INDENT>mq1 = self.marquee('<STR_LIT>')<EOL>if mq1:<EOL><INDENT>print(file=io.stdout)<EOL>print(mq1, file=io.stdout)<EOL>print(self.marquee('<STR_LIT>'), file=io.stdout)<EOL><DEDENT>self.finished = True<EOL><DEDENT>", "docstring": "run a block of the demo.\n\n        If index is given, it should be an integer >=1 and <= nblocks.  This\n        means that the calling convention is one off from typical Python\n        lists.  The reason for the inconsistency is that the demo always\n        prints 'Block n/N, and N is the total, so it would be very odd to use\n        zero-indexing here.", "id": "f21592:c1:m14"}
{"signature": "def _set_network_instance(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT:name>\",<EOL>network_instance.network_instance,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT:name>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__network_instance = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for network_instance, mapped from YANG variable /network_instances/network_instance (list)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_network_instance is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_network_instance() directly.\n\nYANG Description: Network instances configured on the local system", "id": "f23467:c1:m3"}
{"signature": "def get_metrics_data_relay(self, name, relay_name, metric, rollup, filter_expresssion):", "body": "response = self._perform_get(<EOL>self._get_get_metrics_data_relay_path(name, relay_name, metric, rollup, filter_expresssion),<EOL>None)<EOL>return _MinidomXmlToObject.convert_response_to_feeds(<EOL>response,<EOL>partial(<EOL>_ServiceBusManagementXmlSerializer.xml_to_metrics,<EOL>object_type=MetricValues<EOL>)<EOL>)<EOL>", "docstring": "Retrieves the list of supported metrics for this namespace and relay\n\nname:\n    Name of the service bus namespace.\nrelay_name:\n    Name of the service bus relay in this namespace.\nmetric:\n    name of a supported metric\nrollup:\n    name of a supported rollup\nfilter_expression:\n    filter, for instance \"$filter=Timestamp gt datetime'2014-10-01T00:00:00Z'\"", "id": "f41499:c0:m18"}
{"signature": "def t_MATCHES(self, t):", "body": "return t<EOL>", "docstring": "==", "id": "f11003:c0:m9"}
{"signature": "def cb_generate_config(self, *args, **kwargs):", "body": "self.linter.generate_config(skipsections=(\"<STR_LIT>\",))<EOL>sys.exit(<NUM_LIT:0>)<EOL>", "docstring": "optik callback for sample config file generation", "id": "f18861:c2:m4"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/config (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_config is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_config() directly.\n\n    YANG Description: Configuration parameters for the interface on which\nOSPFv2 is enabled", "id": "f23121:c1:m6"}
{"signature": "def _processPacket(self, packet):", "body": "try:<EOL><INDENT>packet_type      = (packet[<NUM_LIT:0>] & <NUM_LIT>) >> <NUM_LIT:4><EOL>packet_flags     = (packet[<NUM_LIT:0>] & <NUM_LIT>)<EOL>packet_type_name = self.packetTypes[packet_type]<EOL><DEDENT>except KeyError as e:<EOL><INDENT>log.error(\"<STR_LIT>\" % packet_type)<EOL>self.transport.abortConnection()<EOL>return<EOL><DEDENT>packetDecoder = getattr(self, \"<STR_LIT>\" % packet_type_name, None)<EOL>if packetDecoder:<EOL><INDENT>packetDecoder(packet)<EOL><DEDENT>else:<EOL><INDENT>log.error(\"<STR_LIT>\" % packet_type_name)<EOL>self.transport.abortConnection()<EOL>return<EOL><DEDENT>", "docstring": "Generic MQTT packet decoder", "id": "f12836:c4:m2"}
{"signature": "def _set_metric(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__metric = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for metric, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv6_reachability/prefixes/prefix/state/metric (oc-isis-types:wide-metric)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_metric is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_metric() directly.\n\nYANG Description: ISIS metric value.", "id": "f22904:c0:m15"}
{"signature": "def _get_ipv4_interface_address(self):", "body": "return self.__ipv4_interface_address<EOL>", "docstring": "Getter method for ipv4_interface_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/ipv4_interface_address (container)\n\nYANG Description: This container defines sub-TLV 6.", "id": "f22782:c0:m11"}
{"signature": "def _get_max_prefixes(self):", "body": "return self.__max_prefixes<EOL>", "docstring": "Getter method for max_prefixes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/state/max_prefixes (uint32)\n\n    YANG Description: Maximum number of prefixes that will be accepted\nfrom the neighbour", "id": "f23291:c0:m2"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix/tlvs/tlv/sid_label_binding/tlvs/tlv/ero_path/segments/segment/unnumbered_hop/state (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_state is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_state() directly.\n\n    YANG Description: State parameters of the unnumbered interface\nsegment of the ERO", "id": "f23014:c1:m3"}
{"signature": "def _prompt_finished_hook(self):", "body": "pass<EOL>", "docstring": "Called immediately after a prompt is finished, i.e. when some input\n            will be processed and a new prompt displayed.", "id": "f21651:c0:m31"}
{"signature": "def genomic_features(store, case_obj, sample_name, genes_only):", "body": "g_features = []<EOL>build = case_obj['<STR_LIT>']<EOL>if not build in ['<STR_LIT>', '<STR_LIT>']:<EOL><INDENT>build = '<STR_LIT>'<EOL><DEDENT>else:<EOL><INDENT>build = '<STR_LIT>'+build<EOL><DEDENT>individual_pinned_snvs = list(store.sample_variants( variants=case_obj.get('<STR_LIT>'),<EOL>sample_name=sample_name))<EOL>gene_set = set()<EOL>for var in individual_pinned_snvs:<EOL><INDENT>hgnc_genes = var.get('<STR_LIT>')<EOL>if not hgnc_genes:<EOL><INDENT>continue<EOL><DEDENT>for hgnc_id in hgnc_genes:<EOL><INDENT>gene_obj = store.hgnc_gene(hgnc_id)<EOL>if not gene_obj:<EOL><INDENT>continue<EOL><DEDENT>g_feature = {<EOL>'<STR_LIT>': {'<STR_LIT:id>': gene_obj.get('<STR_LIT>')}<EOL>}<EOL>if genes_only and not hgnc_id in gene_set: <EOL><INDENT>gene_set.add(hgnc_id)<EOL>g_features.append(g_feature)<EOL>continue<EOL><DEDENT>g_feature['<STR_LIT>'] = {<EOL>'<STR_LIT>' : var['<STR_LIT>'],<EOL>'<STR_LIT:start>' : var['<STR_LIT>'],<EOL>'<STR_LIT:end>' : var['<STR_LIT:end>'],<EOL>'<STR_LIT>' : build,<EOL>'<STR_LIT>' :var['<STR_LIT>'],<EOL>'<STR_LIT>' : var['<STR_LIT>'],<EOL>'<STR_LIT>' : True<EOL>}<EOL>zygosity = None<EOL>zygosities = var['<STR_LIT>'] <EOL>for zyg in zygosities:<EOL><INDENT>if zyg.get('<STR_LIT>') == sample_name: <EOL><INDENT>zygosity = zyg['<STR_LIT>'].count('<STR_LIT:1>') + zyg['<STR_LIT>'].count('<STR_LIT:2>')<EOL><DEDENT><DEDENT>g_feature['<STR_LIT>'] = zygosity<EOL>g_features.append(g_feature)<EOL><DEDENT><DEDENT>return g_features<EOL>", "docstring": "Extract and parse matchmaker-like genomic features from pinned variants\n        of a patient\n    Args:\n        store(MongoAdapter) : connection to the database\n        case_obj(dict): a scout case object\n        sample_name(str): sample display name\n        genes_only(bool): if True only gene names will be included in genomic features\n\n    Returns:\n        g_features(list): a list of genomic feature objects that looks like this:\n            [\n              {\n                \"gene\": {\n                  \"id\": \"LIMS2\"\n                },\n                \"variant\": {\n                  \"alternateBases\": \"C\",\n                  \"assembly\": \"GRCh37\",\n                  \"end\": 128412081,\n                  \"referenceBases\": \"G\",\n                  \"referenceName\": \"2\",\n                  \"start\": 128412080\n                },\n                \"zygosity\": 1\n              },\n              ....\n            ]", "id": "f13845:m2"}
{"signature": "def _extract_base(self, element):", "body": "if isinstance(element, list):<EOL><INDENT>return [self._extract_base(x) for x in element]<EOL><DEDENT>base = self.checker.is_url_valid(url=element, return_base=True)<EOL>if base:<EOL><INDENT>return base<EOL><DEDENT>if \"<STR_LIT:/>\" in element:<EOL><INDENT>return element.split(\"<STR_LIT:/>\")[<NUM_LIT:0>]<EOL><DEDENT>return element<EOL>", "docstring": "Extract the base of the given element.\n\n.. example:\n    given \"hello/world?world=beautiful\" return \"hello\"\n\n:param element: The element we are working with.\n:type element: str|list", "id": "f8233:c0:m4"}
{"signature": "def null_default(x):", "body": "def null(y):<EOL><INDENT>return x<EOL><DEDENT>return null<EOL>", "docstring": "Null function. Used for default in functions that can apply a user-\nsupplied function to data before returning.", "id": "f7580:m4"}
{"signature": "def get_token(self, id):", "body": "return self.request(\"<STR_LIT>\", id, method=\"<STR_LIT>\").json()<EOL>", "docstring": "Retrieve specific token.\n\n            https://www.nomadproject.io/api/acl-tokens.html\n\n            returns: dict\n\n            raises:\n              - nomad.api.exceptions.BaseNomadException\n              - nomad.api.exceptions.URLNotFoundNomadException", "id": "f3538:c0:m6"}
{"signature": "def t_FRACTION(self, t):", "body": "t.endlexpos = t.lexpos + len(t.value)<EOL>return t<EOL>", "docstring": "r\"(((\\d*\\.\\d+)|(\\d+\\.)([eE][-+]?\\d+)?)|(\\d+([eE][-+]?\\d+)))[FfLl]?", "id": "f14752:c65:m11"}
{"signature": "def wasb_log_exists(self, remote_log_location):", "body": "try:<EOL><INDENT>return self.hook.check_for_blob(self.wasb_container, remote_log_location)<EOL><DEDENT>except Exception:<EOL><INDENT>pass<EOL><DEDENT>return False<EOL>", "docstring": "Check if remote_log_location exists in remote storage\n:param remote_log_location: log's location in remote storage\n:return: True if location exists else False", "id": "f9474:c0:m5"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config (container)\n\nYANG Description: Configuration data for the VRRP group", "id": "f21954:c0:m5"}
{"signature": "def gaussian(duration: int, amp: complex, sigma: float, name: str = None) -> SamplePulse:", "body": "center = duration/<NUM_LIT:2><EOL>zeroed_width = duration + <NUM_LIT:2><EOL>return _sampled_gaussian_pulse(duration, amp, center, sigma,<EOL>zeroed_width=zeroed_width, rescale_amp=True, name=name)<EOL>", "docstring": "r\"\"\"Generates unnormalized gaussian `SamplePulse`.\n\n    Centered at `duration/2` and zeroed at `t=-1` to prevent large initial discontinuity.\n\n    Applies `left` sampling strategy to generate discrete pulse from continuous function.\n\n    Integrated area under curve is $\\Omega_g(amp, sigma) = amp \\times np.sqrt(2\\pi \\sigma^2)$\n\n    Args:\n        duration: Duration of pulse. Must be greater than zero.\n        amp: Pulse amplitude at `duration/2`.\n        sigma: Width (standard deviation) of pulse.\n        name: Name of pulse.", "id": "f10752:m7"}
{"signature": "def get_ipython_dir():", "body": "env = os.environ<EOL>pjoin = os.path.join<EOL>ipdir_def = '<STR_LIT>'<EOL>xdg_def = '<STR_LIT>'<EOL>home_dir = get_home_dir()<EOL>xdg_dir = get_xdg_dir()<EOL>if '<STR_LIT>' in env:<EOL><INDENT>warnings.warn('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>ipdir = env.get('<STR_LIT>', env.get('<STR_LIT>', None))<EOL>if ipdir is None:<EOL><INDENT>home_ipdir = pjoin(home_dir, ipdir_def)<EOL>if xdg_dir:<EOL><INDENT>xdg_ipdir = pjoin(xdg_dir, xdg_def)<EOL>if _writable_dir(xdg_ipdir) or not _writable_dir(home_ipdir):<EOL><INDENT>ipdir = xdg_ipdir<EOL><DEDENT><DEDENT>if ipdir is None:<EOL><INDENT>ipdir = home_ipdir<EOL><DEDENT><DEDENT>ipdir = os.path.normpath(os.path.expanduser(ipdir))<EOL>if os.path.exists(ipdir) and not _writable_dir(ipdir):<EOL><INDENT>warnings.warn(\"<STR_LIT>\"<EOL>\"<STR_LIT>\"%ipdir)<EOL>ipdir = tempfile.mkdtemp()<EOL><DEDENT>elif not os.path.exists(ipdir):<EOL><INDENT>parent = ipdir.rsplit(os.path.sep, <NUM_LIT:1>)[<NUM_LIT:0>]<EOL>if not _writable_dir(parent):<EOL><INDENT>warnings.warn(\"<STR_LIT>\"<EOL>\"<STR_LIT>\"%parent)<EOL>ipdir = tempfile.mkdtemp()<EOL><DEDENT><DEDENT>return py3compat.cast_unicode(ipdir, fs_encoding)<EOL>", "docstring": "Get the IPython directory for this platform and user.\n\n    This uses the logic in `get_home_dir` to find the home directory\n    and then adds .ipython to the end of the path.", "id": "f21499:m8"}
{"signature": "def new_job(<EOL>self,<EOL>task,<EOL>person,<EOL>tank,<EOL>target_host,<EOL>target_port,<EOL>loadscheme=None,<EOL>detailed_time=None,<EOL>notify_list=None,<EOL>trace=False):", "body": "if not notify_list:<EOL><INDENT>notify_list = []<EOL><DEDENT>data = {<EOL>'<STR_LIT>': task,<EOL>'<STR_LIT>': person,<EOL>'<STR_LIT>': tank,<EOL>'<STR_LIT:host>': target_host,<EOL>'<STR_LIT:port>': target_port,<EOL>'<STR_LIT>': loadscheme,<EOL>'<STR_LIT>': detailed_time,<EOL>'<STR_LIT>': notify_list<EOL>}<EOL>logger.debug(\"<STR_LIT>\", data)<EOL>api_timeouts = self.api_timeouts()<EOL>while True:<EOL><INDENT>try:<EOL><INDENT>response = self.__post(<EOL>\"<STR_LIT>\", data, trace=trace)[<NUM_LIT:0>]<EOL>return response['<STR_LIT>'], response['<STR_LIT>']<EOL><DEDENT>except (self.NotAvailable, self.StoppedFromOnline) as e:<EOL><INDENT>try:<EOL><INDENT>timeout = next(api_timeouts)<EOL>logger.warn(\"<STR_LIT>\" % timeout)<EOL>time.sleep(timeout)<EOL>continue<EOL><DEDENT>except StopIteration:<EOL><INDENT>logger.warn('<STR_LIT>')<EOL>raise self.JobNotCreated(e.message)<EOL><DEDENT><DEDENT>except requests.HTTPError as e:<EOL><INDENT>raise self.JobNotCreated('<STR_LIT>'.format(e.response.content))<EOL><DEDENT>except Exception as e:<EOL><INDENT>logger.warn('<STR_LIT>')<EOL>logger.warn(repr(e), )<EOL>raise self.JobNotCreated()<EOL><DEDENT><DEDENT>", "docstring": ":return: job_nr, upload_token\n:rtype: tuple", "id": "f17586:c0:m19"}
{"signature": "def chebyu(n, monic=False):", "body": "base = jacobi(n, <NUM_LIT:0.5>, <NUM_LIT:0.5>, monic=monic)<EOL>if monic:<EOL><INDENT>return base<EOL><DEDENT>factor = sqrt(pi) / <NUM_LIT> * _gam(n + <NUM_LIT:2>) / _gam(n + <NUM_LIT>)<EOL>base._scale(factor)<EOL>return base<EOL>", "docstring": "Return nth order Chebyshev polynomial of second kind, Un(x).  Orthogonal\n    over [-1,1] with weight function (1-x**2)**(1/2).", "id": "f19467:m18"}
{"signature": "def list_by_home_region(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_home_region.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>', pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.asc_location, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.AllowedConnectionsResourcePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.AllowedConnectionsResourcePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the list of all possible traffic between resources for the\n        subscription and location.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of AllowedConnectionsResource\n        :rtype:\n         ~azure.mgmt.security.models.AllowedConnectionsResourcePaged[~azure.mgmt.security.models.AllowedConnectionsResource]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38746:c0:m2"}
{"signature": "def apply_async(self, f, *args, **kwargs):", "body": "return self._really_apply(f, args, kwargs, block=False)<EOL>", "docstring": "calls f(*args, **kwargs) on remote engines in a nonblocking manner.\n\n        returns AsyncResult", "id": "f21691:c0:m7"}
{"signature": "@subcontainer<EOL>def nFibPCOxGsrX():", "body": "return Injector.let(bar=(this << <NUM_LIT:1>).foo)<EOL>", "docstring": "Let notation.", "id": "f5024:m11"}
{"signature": "def getRd(self):", "body": "return self.intf.rd._sigInside<EOL>", "docstring": "get \"ready\" signal", "id": "f1368:c0:m3"}
{"signature": "def clear_all(self):", "body": "self.clear()<EOL>for ch in reversed(self.columns):<EOL><INDENT>del self[ch.name]<EOL><DEDENT>", "docstring": "Remove all items and column headings", "id": "f17387:c1:m13"}
{"signature": "def startLogging(console=True, filepath=None):", "body": "global logLevelFilterPredicate<EOL>observers = []<EOL>if console:<EOL><INDENT>observers.append( FilteringLogObserver(observer=textFileLogObserver(sys.stdout),  <EOL>predicates=[logLevelFilterPredicate] ))<EOL><DEDENT>if filepath is not None and filepath != \"<STR_LIT>\":<EOL><INDENT>observers.append( FilteringLogObserver(observer=textFileLogObserver(open(filepath,'<STR_LIT:a>')), <EOL>predicates=[logLevelFilterPredicate] ))<EOL><DEDENT>globalLogBeginner.beginLoggingTo(observers)<EOL>", "docstring": "Starts the global Twisted logger subsystem with maybe\nstdout and/or a file specified in the config file", "id": "f12853:m0"}
{"signature": "def HKY85(mu=<NUM_LIT:1.0>, pi=None, kappa=<NUM_LIT:0.1>, **kwargs):", "body": "if pi is None:<EOL><INDENT>pi=<NUM_LIT>*np.ones(<NUM_LIT:4>, dtype=float)<EOL><DEDENT>num_chars = len(alphabets['<STR_LIT>'])<EOL>if num_chars != pi.shape[<NUM_LIT:0>] :<EOL><INDENT>pi = np.ones((num_chars, ), dtype=float)<EOL>print (\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>W = _create_transversion_transition_W(kappa)<EOL>pi /= pi.sum()<EOL>gtr = GTR(alphabet=alphabets['<STR_LIT>'])<EOL>gtr.assign_rates(mu=mu, pi=pi, W=W)<EOL>return gtr<EOL>", "docstring": "Hasegawa, Kishino and Yano 1985 model. Allows different concentrations of the\nnucleotides (as in F81) + distinguishes between transition/transversionsubstitutions\n(similar to K80). Link:\nHasegawa, Kishino, Yano (1985), J. Mol. Evol. 22 (2): 160\u2013174. doi:10.1007/BF02101694\n\nCurrent implementation of the model does not account for the gaps\n\nParameters\n-----------\n\n\n mu : float\n    Substitution rate\n\n pi : numpy.array\n    Nucleotide concentrations\n\n kappa : float\n    Ratio of transversion/transition substitution rates", "id": "f2317:m3"}
{"signature": "def no_template_view(request):", "body": "return HttpResponse(\"<STR_LIT>\")<EOL>", "docstring": "A simple view that expects a GET request, and returns a rendered template", "id": "f20338:m0"}
{"signature": "def _setInsertFromTable(self, value):", "body": "self._insertFromTable = value<EOL>if value:<EOL><INDENT>self.insertElement = self.insertElementTable<EOL><DEDENT>else:<EOL><INDENT>self.insertElement = self.insertElementNormal<EOL><DEDENT>", "docstring": "Switch the function used to insert an element from the\n        normal one to the misnested table one and back again", "id": "f17205:c2:m11"}
{"signature": "def drop_record(self, msg_id):", "body": "del self._records[msg_id]<EOL>", "docstring": "Remove a record from the DB.", "id": "f21688:c2:m7"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/lsp/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: This container defines LSP PDU counters.", "id": "f22433:c0:m3"}
{"signature": "def __setstate__(self, state):", "body": "self.__dict__.update(state)<EOL>if '<STR_LIT>' not in self.__dict__:<EOL><INDENT>self._cookies_lock = threading.RLock()<EOL><DEDENT>", "docstring": "Unlike a normal CookieJar, this class is pickleable.", "id": "f16925:c3:m20"}
{"signature": "@asyncio.coroutine<EOL><INDENT>def _process_connect_init(self):<DEDENT>", "body": "self._status = Client.CONNECTING<EOL>connection_completed = self._io_reader.readline()<EOL>info_line = yield from asyncio.wait_for(connection_completed, self.options[\"<STR_LIT>\"])<EOL>if INFO_OP not in info_line:<EOL><INDENT>raise NatsError(\"<STR_LIT>\")<EOL><DEDENT>_, info = info_line.split(INFO_OP + _SPC_, <NUM_LIT:1>)<EOL>try:<EOL><INDENT>srv_info = json.loads(info.decode())<EOL><DEDENT>except:<EOL><INDENT>raise NatsError(\"<STR_LIT>\")<EOL><DEDENT>self._process_info(srv_info)<EOL>self._server_info = srv_info<EOL>if '<STR_LIT>' in self._server_info:<EOL><INDENT>self._max_payload = self._server_info[\"<STR_LIT>\"]<EOL><DEDENT>if '<STR_LIT>' in self._server_info and self._server_info['<STR_LIT>']:<EOL><INDENT>ssl_context = None<EOL>if \"<STR_LIT>\" in self.options:<EOL><INDENT>ssl_context = self.options.get('<STR_LIT>')<EOL><DEDENT>elif self._current_server.uri.scheme == '<STR_LIT>':<EOL><INDENT>ssl_context = ssl.create_default_context()<EOL><DEDENT>else:<EOL><INDENT>raise NatsError('<STR_LIT>')<EOL><DEDENT>transport = self._io_writer.transport<EOL>sock = transport.get_extra_info('<STR_LIT>')<EOL>if not sock:<EOL><INDENT>raise NatsError('<STR_LIT>')<EOL><DEDENT>yield from self._io_writer.drain()  <EOL>self._io_reader, self._io_writer =yield from asyncio.open_connection(<EOL>loop=self._loop,<EOL>limit=DEFAULT_BUFFER_SIZE,<EOL>sock=sock,<EOL>ssl=ssl_context,<EOL>server_hostname=self._current_server.uri.hostname,<EOL>)<EOL><DEDENT>if self.is_reconnecting:<EOL><INDENT>self._ps.reset()<EOL><DEDENT>connect_cmd = self._connect_command()<EOL>self._io_writer.write(connect_cmd)<EOL>self._io_writer.write(PING_PROTO)<EOL>yield from self._io_writer.drain()<EOL>next_op = yield from self._io_reader.readline()<EOL>if self.options[\"<STR_LIT>\"] and OK_OP in next_op:<EOL><INDENT>next_op = yield from self._io_reader.readline()<EOL><DEDENT>if ERR_OP in next_op:<EOL><INDENT>err_line = next_op.decode()<EOL>_, err_msg = err_line.split(\"<STR_LIT:U+0020>\", <NUM_LIT:1>)<EOL>raise NatsError(\"<STR_LIT>\" + err_msg.rstrip('<STR_LIT:\\r\\n>'))<EOL><DEDENT>if PONG_PROTO in next_op:<EOL><INDENT>self._status = Client.CONNECTED<EOL><DEDENT>self._reading_task = self._loop.create_task(self._read_loop())<EOL>self._pongs = []<EOL>self._pings_outstanding = <NUM_LIT:0><EOL>self._ping_interval_task = self._loop.create_task(<EOL>self._ping_interval())<EOL>self._flusher_task = self._loop.create_task(self._flusher())<EOL>", "docstring": "Process INFO received from the server and CONNECT to the server\nwith authentication.  It is also responsible of setting up the\nreading and ping interval tasks from the client.", "id": "f14034:c3:m46"}
{"signature": "def get_linked_files(self):", "body": "return self.media_descriptors<EOL>", "docstring": "Give all linked files.", "id": "f14843:c0:m43"}
{"signature": "@meta.add_method(functors.SkipIgnore)<EOL>def to_cython(self, genstate) -> fmt.indentable:", "body": "return '<STR_LIT:\\n>'<EOL>", "docstring": "TODO: A quite important part of C transform... rethink directive/decoration/etc...", "id": "f4948:m3"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/config/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: Whether the use of multiple paths for the same NLRI is\nenabled for the neighbor. This value is overridden by\nany more specific configuration value.", "id": "f23203:c0:m3"}
{"signature": "def remove_whitespace(sentences):", "body": "return [[w.rstrip() for w in sent] for sent in sentences]<EOL>", "docstring": "Clear out spaces and newlines\nfrom the list of list of strings.\n\nArguments:\n----------\n    sentences : list<list<str>>\n\nReturns:\n--------\n    list<list<str>> : same strings as input,\n        without spaces or newlines.", "id": "f16733:m2"}
{"signature": "def to_pickle(obj, filename, clean_memory=False):", "body": "path, filename = path_to_filename(filename)<EOL>create_dir(path)<EOL>with open(path + filename, \"<STR_LIT:wb>\") as output:<EOL><INDENT>pickle.dump(obj, output, pickle.HIGHEST_PROTOCOL)<EOL><DEDENT>if clean_memory:<EOL><INDENT>obj = None<EOL><DEDENT>return obj<EOL>", "docstring": "http://stackoverflow.com/questions/7900944/read-write-classes-to-files-in-an-efficent-way", "id": "f18908:m2"}
{"signature": "@any_form_field.register(forms.IntegerField)<EOL>def integer_field_data(field, **kwargs):", "body": "min_value = <NUM_LIT:0><EOL>max_value = <NUM_LIT:100><EOL>from django.core.validators import MinValueValidator, MaxValueValidator <EOL>for elem in field.validators:<EOL><INDENT>if isinstance(elem, MinValueValidator):<EOL><INDENT>min_value = elem.limit_value<EOL><DEDENT>if isinstance(elem, MaxValueValidator):<EOL><INDENT>max_value = elem.limit_value<EOL><DEDENT><DEDENT>min_value = kwargs.get('<STR_LIT>', min_value)<EOL>max_value = kwargs.get('<STR_LIT>', max_value)<EOL>return str(xunit.any_int(min_value=min_value, max_value=max_value))<EOL>", "docstring": "Return random value for IntegerField\n\n>>> result = any_form_field(forms.IntegerField(max_value=200, min_value=100))\n>>> type(result)\n<type 'str'>\n>>> int(result) >=100, int(result) <=200\n(True, True)", "id": "f10407:m10"}
{"signature": "def __init__(self, ptype='<STR_LIT>', legislature=None):", "body": "assert(ptype in ['<STR_LIT>', '<STR_LIT>'])<EOL>assert(legislature in ['<STR_LIT>', '<STR_LIT>', None])<EOL>self.legislature = legislature<EOL>self.ptype = ptype<EOL>self.ptype_plural = ptype + '<STR_LIT:s>'<EOL>self.base_url = '<STR_LIT>' % (legislature or '<STR_LIT>', self.ptype_plural)<EOL>", "docstring": "type: depute or senateur\nlegislature: 2007-2012 or None", "id": "f12079:c0:m0"}
{"signature": "def process_response(self, request, response):", "body": "if hasattr(request, \"<STR_LIT>\") and hasattr(request, \"<STR_LIT:user>\") and request.user.is_authenticated():<EOL><INDENT>msgs = get_messages(request.user)<EOL>if msgs:<EOL><INDENT>for msg, level in msgs:<EOL><INDENT>messages.add_message(request, level, msg)<EOL><DEDENT><DEDENT><DEDENT>return response<EOL>", "docstring": "Check for messages for this user and, if it exists,\ncall the messages API with it", "id": "f5:c0:m0"}
{"signature": "def nice_pair(pair):", "body": "start, end = pair<EOL>if start == end:<EOL><INDENT>return \"<STR_LIT>\" % start<EOL><DEDENT>else:<EOL><INDENT>return \"<STR_LIT>\" % (start, end)<EOL><DEDENT>", "docstring": "Make a nice string representation of a pair of numbers.\n\n    If the numbers are equal, just return the number, otherwise return the pair\n    with a dash between them, indicating the range.", "id": "f17079:m0"}
{"signature": "def client_random(self):", "body": "session = _lib.SSL_get_session(self._ssl)<EOL>if session == _ffi.NULL:<EOL><INDENT>return None<EOL><DEDENT>length = _lib.SSL_get_client_random(self._ssl, _ffi.NULL, <NUM_LIT:0>)<EOL>assert length > <NUM_LIT:0><EOL>outp = _no_zero_allocator(\"<STR_LIT>\", length)<EOL>_lib.SSL_get_client_random(self._ssl, outp, length)<EOL>return _ffi.buffer(outp, length)[:]<EOL>", "docstring": "Retrieve the random value used with the client hello message.\n\n:return: A string representing the state", "id": "f4636:c15:m33"}
{"signature": "def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):", "body": "conn = self.get_connection(request.url, proxies)<EOL>self.cert_verify(conn, request.url, verify, cert)<EOL>url = self.request_url(request, proxies)<EOL>self.add_headers(request)<EOL>chunked = not (request.body is None or '<STR_LIT>' in request.headers)<EOL>if isinstance(timeout, tuple):<EOL><INDENT>try:<EOL><INDENT>connect, read = timeout<EOL>timeout = TimeoutSauce(connect=connect, read=read)<EOL><DEDENT>except ValueError as e:<EOL><INDENT>err = (\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\".format(timeout))<EOL>raise ValueError(err)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>timeout = TimeoutSauce(connect=timeout, read=timeout)<EOL><DEDENT>try:<EOL><INDENT>if not chunked:<EOL><INDENT>resp = conn.urlopen(<EOL>method=request.method,<EOL>url=url,<EOL>body=request.body,<EOL>headers=request.headers,<EOL>redirect=False,<EOL>assert_same_host=False,<EOL>preload_content=False,<EOL>decode_content=False,<EOL>retries=self.max_retries,<EOL>timeout=timeout<EOL>)<EOL><DEDENT>else:<EOL><INDENT>if hasattr(conn, '<STR_LIT>'):<EOL><INDENT>conn = conn.proxy_pool<EOL><DEDENT>low_conn = conn._get_conn(timeout=timeout)<EOL>try:<EOL><INDENT>low_conn.putrequest(request.method,<EOL>url,<EOL>skip_accept_encoding=True)<EOL>for header, value in request.headers.items():<EOL><INDENT>low_conn.putheader(header, value)<EOL><DEDENT>low_conn.endheaders()<EOL>for i in request.body:<EOL><INDENT>low_conn.send(hex(len(i))[<NUM_LIT:2>:].encode('<STR_LIT:utf-8>'))<EOL>low_conn.send(b'<STR_LIT:\\r\\n>')<EOL>low_conn.send(i)<EOL>low_conn.send(b'<STR_LIT:\\r\\n>')<EOL><DEDENT>low_conn.send(b'<STR_LIT>')<EOL>r = low_conn.getresponse()<EOL>resp = HTTPResponse.from_httplib(<EOL>r,<EOL>pool=conn,<EOL>connection=low_conn,<EOL>preload_content=False,<EOL>decode_content=False<EOL>)<EOL><DEDENT>except:<EOL><INDENT>low_conn.close()<EOL>raise<EOL><DEDENT>else:<EOL><INDENT>conn._put_conn(low_conn)<EOL><DEDENT><DEDENT><DEDENT>except (ProtocolError, socket.error) as err:<EOL><INDENT>raise ConnectionError(err, request=request)<EOL><DEDENT>except MaxRetryError as e:<EOL><INDENT>if isinstance(e.reason, ConnectTimeoutError):<EOL><INDENT>raise ConnectTimeout(e, request=request)<EOL><DEDENT>if isinstance(e.reason, ResponseError):<EOL><INDENT>raise RetryError(e, request=request)<EOL><DEDENT>raise ConnectionError(e, request=request)<EOL><DEDENT>except _ProxyError as e:<EOL><INDENT>raise ProxyError(e)<EOL><DEDENT>except (_SSLError, _HTTPError) as e:<EOL><INDENT>if isinstance(e, _SSLError):<EOL><INDENT>raise SSLError(e, request=request)<EOL><DEDENT>elif isinstance(e, ReadTimeoutError):<EOL><INDENT>raise ReadTimeout(e, request=request)<EOL><DEDENT>else:<EOL><INDENT>raise<EOL><DEDENT><DEDENT>return self.build_response(request, resp)<EOL>", "docstring": "Sends PreparedRequest object. Returns Response object.\n\n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a (`connect timeout, read\n            timeout <user/advanced.html#timeouts>`_) tuple.\n        :type timeout: float or tuple\n        :param verify: (optional) Whether to verify SSL certificates.\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.", "id": "f17258:c1:m12"}
{"signature": "def _get_ipv4_unicast(self):", "body": "return self.__ipv4_unicast<EOL>", "docstring": "Getter method for ipv4_unicast, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast (container)\n\nYANG Description: IPv4 unicast configuration options", "id": "f23214:c0:m23"}
{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualWANPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualWANPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all the VirtualWANs in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualWAN\n        :rtype:\n         ~azure.mgmt.network.v2018_08_01.models.VirtualWANPaged[~azure.mgmt.network.v2018_08_01.models.VirtualWAN]\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_08_01.models.ErrorException>`", "id": "f31698:c0:m9"}
{"signature": "def monitors(self, **kwargs):", "body": "regs = regularizers.from_kwargs(self, **kwargs)<EOL>outputs, _ = self.build_graph(regs)<EOL>monitors = [('<STR_LIT>', self.losses[<NUM_LIT:0>](outputs))]<EOL>def matching(pattern):<EOL><INDENT>'''<STR_LIT>'''<EOL>for name, expr in util.outputs_matching(outputs, pattern):<EOL><INDENT>yield name, expr<EOL><DEDENT>for name, expr in util.params_matching(self.layers, pattern):<EOL><INDENT>yield name, expr<EOL><DEDENT><DEDENT>def parse_levels(levels):<EOL><INDENT>'''<STR_LIT>'''<EOL>if isinstance(levels, dict):<EOL><INDENT>levels = levels.items()<EOL><DEDENT>if isinstance(levels, (int, float)):<EOL><INDENT>levels = [levels]<EOL><DEDENT>for level in levels:<EOL><INDENT>if isinstance(level, (tuple, list)):<EOL><INDENT>label, call = level<EOL>yield '<STR_LIT>'.format(label), call<EOL><DEDENT>if isinstance(level, (int, float)):<EOL><INDENT>def call(expr):<EOL><INDENT>return (expr < level).mean()<EOL><DEDENT>yield '<STR_LIT>'.format(level), call<EOL><DEDENT><DEDENT><DEDENT>inputs = kwargs.get('<STR_LIT>', {})<EOL>if isinstance(inputs, dict):<EOL><INDENT>inputs = inputs.items()<EOL><DEDENT>for pattern, levels in inputs:<EOL><INDENT>for name, expr in matching(pattern):<EOL><INDENT>for key, value in parse_levels(levels):<EOL><INDENT>monitors.append(('<STR_LIT>'.format(name, key), value(expr)))<EOL><DEDENT><DEDENT><DEDENT>return monitors<EOL>", "docstring": "Return expressions that should be computed to monitor training.\n\n        Returns\n        -------\n        monitors : list of (name, expression) pairs\n            A list of named monitor expressions to compute for this network.", "id": "f7180:c0:m20"}
{"signature": "def _get_s_bit(self):", "body": "return self.__s_bit<EOL>", "docstring": "Getter method for s_bit, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv4_reachability/prefixes/prefix/state/s_bit (boolean)\n\n    YANG Description: The Sub-TLV present bit. If UNSET, the octets of Sub-TLVs are not\npresent. Otherwise, the bit is set and the octet following the prefix\nwill contain the length of the Sub-TLV portion of the structure.", "id": "f22678:c1:m5"}
{"signature": "def __call__(self, *args):", "body": "x_features = self.compose_input_data(args)<EOL>try:<EOL><INDENT>predictions = self.infer_method(x_features)<EOL><DEDENT>except TypeError or ValueError:<EOL><INDENT>if issparse(x_features):<EOL><INDENT>log.info(\"<STR_LIT>\".format(self.model_class))<EOL>predictions = self.infer_method(x_features.todense())<EOL><DEDENT>else:<EOL><INDENT>log.info(\"<STR_LIT>\".format(self.model_class))<EOL>predictions = self.infer_method(csr_matrix(x_features))<EOL><DEDENT><DEDENT>if isinstance(predictions, list):<EOL><INDENT>predictions_ = [[predictions[j][i][<NUM_LIT:1>] for j in range(len(predictions))] for i in range(x_features.shape[<NUM_LIT:0>])]<EOL>predictions = np.array(predictions_)<EOL><DEDENT>if self.ensure_list_output and len(predictions.shape) == <NUM_LIT:1>:<EOL><INDENT>predictions = predictions.reshape(-<NUM_LIT:1>, <NUM_LIT:1>)<EOL><DEDENT>if issparse(predictions):<EOL><INDENT>return predictions<EOL><DEDENT>else:<EOL><INDENT>return predictions.tolist()<EOL><DEDENT>", "docstring": "Infer on the given data according to given in the config infer method, \\\n    e.g. ``\"predict\", \"predict_proba\", \"transform\"``\n\nArgs:\n    *args: list of inputs\n\nReturns:\n    predictions, e.g. list of labels, array of probability distribution, sparse array of vectorized samples", "id": "f3077:c0:m2"}
{"signature": "def _create_sponge(self, index):<EOL>", "body": "seed = self.seed_as_trits[:]<EOL>sponge = Kerl()<EOL>sponge.absorb(add_trits(seed, trits_from_int(index)))<EOL>sponge.squeeze(seed)<EOL>sponge.reset()<EOL>sponge.absorb(seed)<EOL>return sponge<EOL>", "docstring": "Prepares the hash sponge for the generator.", "id": "f11419:c1:m4"}
{"signature": "def get(<EOL>self, resource_group_name, cluster_name, application_type_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", cluster_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", application_type_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorModelException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Returns an application type name resource.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param cluster_name: The name of the cluster resource\n        :type cluster_name: str\n        :param application_type_name: The name of the application type name\n         resource\n        :type application_type_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ApplicationTypeResource or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.servicefabric.models.ApplicationTypeResource or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorModelException<azure.mgmt.servicefabric.models.ErrorModelException>`", "id": "f23615:c0:m1"}
{"signature": "def _evaluate_objective_multiple(objective_function, arg_batch,<EOL>batch_evaluate_objective):", "body": "n_points = tf.shape(input=arg_batch)[<NUM_LIT:0>]<EOL>if batch_evaluate_objective:<EOL><INDENT>return objective_function(arg_batch), n_points<EOL><DEDENT>return tf.map_fn(objective_function, arg_batch), n_points<EOL>", "docstring": "Evaluates the objective function on a batch of points.\n\n    If `batch_evaluate_objective` is True, returns\n    `objective function(arg_batch)` else it maps the `objective_function`\n    across the `arg_batch`.\n\n    Args:\n      objective_function: A Python callable that accepts a single `Tensor` of\n        rank 'R > 1' and any shape 's' and returns a scalar `Tensor` of real dtype\n        containing the value of the function at that point. If\n        `batch a `Tensor` of shape `[batch_size] + s ` where `batch_size` is the\n        size of the batch of args. In this case, the expected return value is a\n        `Tensor` of shape `[batch_size]`.\n      arg_batch: A `Tensor` of real dtype. The batch of arguments at which to\n        evaluate the `objective_function`. If `batch_evaluate_objective` is False,\n        `arg_batch` will be unpacked along the zeroth axis and the\n        `objective_function` will be applied to each element.\n      batch_evaluate_objective: `bool`. Whether the `objective_function` can\n        evaluate a batch of arguments at once.\n\n    Returns:\n      A tuple containing:\n        objective_values: A `Tensor` of real dtype and shape `[batch_size]`.\n          The value of the objective function evaluated at the supplied\n          `arg_batch`.\n        num_evaluations: An `int32` scalar `Tensor`containing the number of\n          points on which the objective function was evaluated (i.e `batch_size`).", "id": "f15567:m14"}
{"signature": "@classmethod<EOL><INDENT>def from_yaml(cls, defaults, **kwargs):<DEDENT>", "body": "<EOL>if \"<STR_LIT>\" not in defaults:<EOL><INDENT>kwargs[\"<STR_LIT>\"] = None<EOL><DEDENT>defaults = copy.deepcopy(defaults)<EOL>return cls(<EOL>defaults=defaults,<EOL>token=kwargs.pop(\"<STR_LIT>\"),<EOL>directory=kwargs.pop(\"<STR_LIT>\"),<EOL>**kwargs<EOL>)<EOL>", "docstring": "Creates a new instance of a rule by merging two dictionaries.\n\n        This allows for independant configuration files to be merged\n        into the defaults.", "id": "f4091:c2:m0"}
{"signature": "def bbbb(self):", "body": "raise NotImplementedError()<EOL>", "docstring": "should be overridden in concrete class", "id": "f18535:c0:m1"}
{"signature": "def get_latex_expression(s, pos, **parse_flags):", "body": "return LatexWalker(s, **parse_flags).get_latex_expression(pos=pos)<EOL>", "docstring": "Reads a latex expression, e.g. macro argument. This may be a single char, an escape\nsequence, or a expression placed in braces.\n\nReturns a tuple `(<LatexNode instance>, pos, len)`. `pos` is the first char of the\nexpression, and `len` is its length.\n\n.. deprecated:: 1.0\n   Please use :py:meth:`LatexWalker.get_latex_expression()` instead.", "id": "f11675:m1"}
{"signature": "def list_configuration_snapshot_info_slot(<EOL>self, resource_group_name, name, slot, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_configuration_snapshot_info_slot.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", slot, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.SiteConfigurationSnapshotInfoPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.SiteConfigurationSnapshotInfoPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a list of web app configuration snapshots identifiers. Each\n        element of the list contains a timestamp and the ID of the snapshot.\n\n        Gets a list of web app configuration snapshots identifiers. Each\n        element of the list contains a timestamp and the ID of the snapshot.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param slot: Name of the deployment slot. If a slot is not specified,\n         the API will return configuration for the production slot.\n        :type slot: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of SiteConfigurationSnapshotInfo\n        :rtype:\n         ~azure.mgmt.web.models.SiteConfigurationSnapshotInfoPaged[~azure.mgmt.web.models.SiteConfigurationSnapshotInfo]\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44988:c0:m198"}
{"signature": "def evaluate_async_script(self, script, *args):", "body": "raise NotImplementedError()<EOL>", "docstring": "Evaluates the given JavaScript and obtains the result from a callback function.\n\nArgs:\n    script (str): A string of JavaScript to evaluate.\n    *args: Variable length argument list to pass to the executed JavaScript string.\n\nReturns:\n    object: The result of the evaluated JavaScript.", "id": "f16549:c0:m23"}
{"signature": "@property<EOL><INDENT>def role(self):<DEDENT>", "body": "if \"<STR_LIT>\" in self.data:<EOL><INDENT>return self.data[\"<STR_LIT>\"]<EOL><DEDENT>return None<EOL>", "docstring": "Gets the role of the device. This is the permissions level that the device has. It might\n        not be accessible depending on the permissions setup of ConnectorDB. Returns None if not accessible", "id": "f1694:c0:m10"}
{"signature": "def get_connection(self, request):", "body": "protocol = request.protocol_overrideif request.protocol_override else self.protocol<EOL>protocol = protocol.lower()<EOL>target_host = request.host<EOL>connection = _RequestsConnection(<EOL>target_host, protocol, self.request_session, self.timeout)<EOL>proxy_host = self.proxy_host<EOL>proxy_port = self.proxy_port<EOL>if self.proxy_host:<EOL><INDENT>headers = None<EOL>if self.proxy_user and self.proxy_password:<EOL><INDENT>auth = base64.b64encode(\"<STR_LIT>\".format(self.proxy_user, self.proxy_password).encode())<EOL>headers = {'<STR_LIT>': '<STR_LIT>'.format(auth.decode())}<EOL><DEDENT>connection.set_tunnel(proxy_host, int(proxy_port), headers)<EOL><DEDENT>return connection<EOL>", "docstring": "Create connection for the request.", "id": "f39494:c0:m3"}
{"signature": "def validate_kwargs(func, kwargs):", "body": "func_name = func.__name__<EOL>argspec = inspect.getargspec(func)<EOL>all_args = argspec.args[:]<EOL>defaults = list(argspec.defaults or [])<EOL>if inspect.ismethod(func) and all_args[:<NUM_LIT:1>] == ['<STR_LIT>']:<EOL><INDENT>all_args[:<NUM_LIT:1>] = []<EOL><DEDENT>if defaults:<EOL><INDENT>required = all_args[:-len(defaults)]<EOL><DEDENT>else:<EOL><INDENT>required = all_args[:]<EOL><DEDENT>trans = {<EOL>arg: arg.endswith('<STR_LIT:_>') and arg[:-<NUM_LIT:1>] or arg<EOL>for arg<EOL>in all_args<EOL>}<EOL>for key in list(kwargs):<EOL><INDENT>key_adj = '<STR_LIT>' % key<EOL>if key_adj in all_args:<EOL><INDENT>kwargs[key_adj] = kwargs.pop(key)<EOL><DEDENT><DEDENT>supplied = sorted(kwargs)<EOL>missing = [<EOL>trans.get(arg, arg) for arg in required<EOL>if arg not in supplied<EOL>]<EOL>if missing:<EOL><INDENT>raise MeteorError(<EOL><NUM_LIT>,<EOL>func.err,<EOL>'<STR_LIT>' % (<EOL>func_name,<EOL>'<STR_LIT:U+0020>'.join(missing),<EOL>),<EOL>)<EOL><DEDENT>extra = [<EOL>arg for arg in supplied<EOL>if arg not in all_args<EOL>]<EOL>if extra:<EOL><INDENT>raise MeteorError(<EOL><NUM_LIT>,<EOL>func.err,<EOL>'<STR_LIT>' % (func_name, '<STR_LIT:U+0020>'.join(extra)),<EOL>)<EOL><DEDENT>", "docstring": "Validate arguments to be supplied to func.", "id": "f1658:m2"}
{"signature": "@property<EOL><INDENT>def pos(self):<DEDENT>", "body": "return self._pos<EOL>", "docstring": "Property for accessing the position of the camera.\n\nThis property uses a setter to call the :py:meth:`on_move()` method if set and the new location is not equal to the old location.", "id": "f11152:c0:m4"}
{"signature": "@property<EOL><INDENT>def disks(self):<DEDENT>", "body": "if self._data is not None:<EOL><INDENT>disks = []<EOL>for disk in self._data[\"<STR_LIT>\"]:<EOL><INDENT>disks.append(disk[\"<STR_LIT:id>\"])<EOL><DEDENT>return disks<EOL><DEDENT>", "docstring": "Returns all available (internal) disks", "id": "f6343:c2:m11"}
{"signature": "def get(<EOL>self, resource_group_name, virtual_wan_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_wan_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves the details of a VirtualWAN.\n\n        :param resource_group_name: The resource group name of the VirtualWan.\n        :type resource_group_name: str\n        :param virtual_wan_name: The name of the VirtualWAN being retrieved.\n        :type virtual_wan_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: VirtualWAN or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_06_01.models.VirtualWAN or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_06_01.models.ErrorException>`", "id": "f30924:c0:m1"}
{"signature": "def _get_pc_covered(self):", "body": "if self.n_statements > <NUM_LIT:0>:<EOL><INDENT>pc_cov = (<NUM_LIT> * (self.n_executed + self.n_executed_branches) /<EOL>(self.n_statements + self.n_branches))<EOL><DEDENT>else:<EOL><INDENT>pc_cov = <NUM_LIT><EOL><DEDENT>return pc_cov<EOL>", "docstring": "Returns a single percentage value for coverage.", "id": "f17084:c1:m4"}
{"signature": "def _set_event(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT>\",<EOL>event.event,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__event = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for event, mapped from YANG variable /system/aaa/authorization/events/event (list)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_event is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_event() directly.\n\nYANG Description: List of events subject to AAA authorization", "id": "f21884:c0:m3"}
{"signature": "def merge_all_in_folder(folder, ext='<STR_LIT>',<EOL>dynamic_imports=None,<EOL>storage_service=None,<EOL>force=False,<EOL>ignore_data=(),<EOL>move_data=False,<EOL>delete_other_files=False,<EOL>keep_info=True,<EOL>keep_other_trajectory_info=True,<EOL>merge_config=True,<EOL>backup=True):", "body": "in_dir = os.listdir(folder)<EOL>all_files = []<EOL>for file in in_dir:<EOL><INDENT>full_file = os.path.join(folder, file)<EOL>if os.path.isfile(full_file):<EOL><INDENT>_, extension = os.path.splitext(full_file)<EOL>if extension == ext:<EOL><INDENT>all_files.append(full_file)<EOL><DEDENT><DEDENT><DEDENT>all_files = sorted(all_files)<EOL>trajs = []<EOL>for full_file in all_files:<EOL><INDENT>traj = load_trajectory(index=-<NUM_LIT:1>,<EOL>storage_service=storage_service,<EOL>filename=full_file,<EOL>load_data=<NUM_LIT:0>,<EOL>force=force,<EOL>dynamic_imports=dynamic_imports)<EOL>trajs.append(traj)<EOL><DEDENT>first_traj = trajs.pop(<NUM_LIT:0>)<EOL>first_traj.f_merge_many(trajs,<EOL>ignore_data=ignore_data,<EOL>move_data=move_data,<EOL>delete_other_trajectory=False,<EOL>keep_info=keep_info,<EOL>keep_other_trajectory_info=keep_other_trajectory_info,<EOL>merge_config=merge_config,<EOL>backup=backup)<EOL>if delete_other_files:<EOL><INDENT>for file in all_files[<NUM_LIT:1>:]:<EOL><INDENT>os.remove(file)<EOL><DEDENT><DEDENT>return first_traj<EOL>", "docstring": "Merges all files in a given folder.\n\n    IMPORTANT: Does not check if there are more than 1 trajectory in a file. Always\n    uses the last trajectory in file and ignores the other ones.\n\n    Trajectories are merged according to the alphabetical order of the files,\n    i.e. the resulting merged trajectory is found in the first file\n    (according to lexicographic ordering).\n\n    :param folder: folder (not recursive) where to look for files\n    :param ext: only files with the given extension are used\n    :param dynamic_imports: Dynamic imports for loading\n    :param storage_service: storage service to use, leave `None` to use the default one\n    :param force: If loading should be forced.\n    :param delete_other_files: Deletes files of merged trajectories\n\n    All other parameters as in `f_merge_many` of the trajectory.\n\n    :return: The merged traj", "id": "f4219:m0"}
{"signature": "def as_string(self, default_from=None):", "body": "encoding = self.charset or '<STR_LIT:utf-8>'<EOL>attachments = self.attachments or []<EOL>if len(attachments) == <NUM_LIT:0> and not self.html:<EOL><INDENT>msg = self._mimetext(self.body)<EOL><DEDENT>elif len(attachments) > <NUM_LIT:0> and not self.html:<EOL><INDENT>msg = MIMEMultipart()<EOL>msg.attach(self._mimetext(self.body))<EOL><DEDENT>else:<EOL><INDENT>msg = MIMEMultipart()<EOL>alternative = MIMEMultipart('<STR_LIT>')<EOL>alternative.attach(self._mimetext(self.body, '<STR_LIT>'))<EOL>alternative.attach(self._mimetext(self.html, '<STR_LIT:html>'))<EOL>msg.attach(alternative)<EOL><DEDENT>if self.charset:<EOL><INDENT>msg['<STR_LIT>'] = Header(self.subject, encoding)<EOL><DEDENT>else:<EOL><INDENT>msg['<STR_LIT>'] = self.subject<EOL><DEDENT>sender = self.sender or default_from<EOL>if sender is not None:<EOL><INDENT>msg['<STR_LIT>'] = sanitize_address(sender, encoding)<EOL><DEDENT>msg['<STR_LIT>'] = '<STR_LIT:U+002CU+0020>'.join(list(set(sanitize_addresses(self.recipients, encoding))))<EOL>msg['<STR_LIT>'] = formatdate(self.date, localtime=True)<EOL>msg['<STR_LIT>'] = self.msgId<EOL>if self.cc:<EOL><INDENT>msg['<STR_LIT>'] = '<STR_LIT:U+002CU+0020>'.join(list(set(sanitize_addresses(self.cc, encoding))))<EOL><DEDENT>if self.reply_to:<EOL><INDENT>msg['<STR_LIT>'] = sanitize_address(self.reply_to, encoding)<EOL><DEDENT>if self.extra_headers:<EOL><INDENT>for k, v in self.extra_headers.items():<EOL><INDENT>msg[k] = v<EOL><DEDENT><DEDENT>for attachment in attachments:<EOL><INDENT>f = MIMEBase(*attachment.content_type.split('<STR_LIT:/>'))<EOL>f.set_payload(attachment.data)<EOL>encode_base64(f)<EOL>try:<EOL><INDENT>attachment.filename and attachment.filename.encode('<STR_LIT:ascii>')<EOL><DEDENT>except UnicodeEncodeError:<EOL><INDENT>filename = attachment.filename<EOL>if not PY3:<EOL><INDENT>filename = filename.encode('<STR_LIT:utf8>')<EOL><DEDENT>f.add_header('<STR_LIT>', attachment.disposition,<EOL>filename=('<STR_LIT>', '<STR_LIT>', filename))<EOL><DEDENT>else:<EOL><INDENT>f.add_header('<STR_LIT>', '<STR_LIT>' %<EOL>(attachment.disposition, attachment.filename))<EOL><DEDENT>for key, value in attachment.headers:<EOL><INDENT>f.add_header(key, value)<EOL><DEDENT>msg.attach(f)<EOL><DEDENT>return msg.as_string()<EOL>", "docstring": "Creates the email", "id": "f3840:c4:m3"}
{"signature": "def description(self, options):", "body": "return \"<STR_LIT>\".join([describe(options) for describe in self.descriptions])<EOL>", "docstring": "Returns a description of the given filter options relevant to this selector.\n\nArgs:\n    options (Dict[str, Any]): The filter options to describe.\n\nReturns:\n    str: A description of the filter options.", "id": "f16551:c0:m2"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/config (container)\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23301:c1:m2"}
{"signature": "def _get_include_any_group(self):", "body": "return self.__include_any_group<EOL>", "docstring": "Getter method for include_any_group, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_secondary_paths/p2p_secondary_path/admin_groups/state/include_any_group (leafref)\n\n    YANG Description: list of references to named admin-groups of which one must\nbe included", "id": "f22258:c1:m8"}
{"signature": "@item_access<EOL>def dc4fedcd09d8():", "body": "class Container(Injector):<EOL><INDENT>foo = {(\"<STR_LIT:x>\", <NUM_LIT:1>): <NUM_LIT:1>}<EOL>bar = this.foo[(\"<STR_LIT:x>\", <NUM_LIT:1>)]<EOL><DEDENT>result = Container.bar<EOL>return result<EOL>", "docstring": "Get items from dict with tuple keys.", "id": "f5019:m9"}
{"signature": "def _setup_freqs(self, f_start=None, f_stop=None):", "body": "<EOL>f0 = self.header[b'<STR_LIT>']<EOL>f_delt = self.header[b'<STR_LIT>']<EOL>i_start, i_stop = <NUM_LIT:0>, self.header[b'<STR_LIT>']<EOL>if f_start:<EOL><INDENT>i_start = int((f_start - f0) / f_delt)<EOL><DEDENT>if f_stop:<EOL><INDENT>i_stop  = int((f_stop - f0)  / f_delt)<EOL><DEDENT>chan_start_idx = np.int(i_start)<EOL>chan_stop_idx  = np.int(i_stop)<EOL>if i_start < i_stop:<EOL><INDENT>i_vals = np.arange(chan_start_idx, chan_stop_idx)<EOL><DEDENT>else:<EOL><INDENT>i_vals = np.arange(chan_stop_idx, chan_start_idx)<EOL><DEDENT>self.freqs = f_delt * i_vals + f0<EOL><INDENT>if f_delt < <NUM_LIT:0>:<EOL><INDENT>self.freqs = self.freqs[::-<NUM_LIT:1>]<EOL><DEDENT><DEDENT>if chan_stop_idx < chan_start_idx:<EOL><INDENT>chan_stop_idx, chan_start_idx = chan_start_idx,chan_stop_idx<EOL><DEDENT>return i_start, i_stop, chan_start_idx, chan_stop_idx<EOL>", "docstring": "Setup frequency axis", "id": "f8176:c0:m3"}
{"signature": "def drop_matching_records(self, check):", "body": "matches = self._match(check)<EOL>for m in matches:<EOL><INDENT>del self._records[m['<STR_LIT>']]<EOL><DEDENT>", "docstring": "Remove a record from the DB.", "id": "f21688:c2:m6"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_reachability/prefixes/prefixes/subTLVs/subTLVs/ipv4_source_router_id/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of sub-TLV 11.", "id": "f22665:c0:m3"}
{"signature": "def _set_protocol(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=[<EOL>RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>],<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__protocol = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for protocol, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/ip/config/protocol (oc-pkt-match-types:ip-protocol-type)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_protocol is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_protocol() directly.\n\nYANG Description: Internet Protocol number.", "id": "f22153:c1:m21"}
{"signature": "@api_endpoint<EOL><INDENT>def collections(self, *params):<DEDENT>", "body": "return sorted(<EOL>set(<EOL>hasattr(qs, '<STR_LIT>') and model_name(qs.model) or qs[<NUM_LIT:1>]<EOL>for qs<EOL>in self.get_queries(False, *params)<EOL>)<EOL>)<EOL>", "docstring": "Return list of collections for this publication.", "id": "f1657:c5:m1"}
{"signature": "def send(self, payload):  ", "body": "raise NotImplementedError('<STR_LIT>')<EOL>", "docstring": "Sends the encoded payload over the transport.\n\n        :argument payload: encoded list of spans.", "id": "f12316:c0:m1"}
{"signature": "def _get_router_id(self):", "body": "return self.__router_id<EOL>", "docstring": "Getter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/router_capabilities/router_capability/state/router_id (inet:ipv4-address-no-zone)\n\nYANG Description: IPv4 router-id.", "id": "f22568:c1:m5"}
{"signature": "def coalesce(*args):", "body": "for arg in args:<EOL><INDENT>if arg is not None:<EOL><INDENT>return arg<EOL><DEDENT><DEDENT>", "docstring": "Return the first non-None argument\n\n>>> coalesce()\n\n>>> coalesce(0, 1)\n0\n>>> coalesce(None, 0)\n0", "id": "f1718:m0"}
{"signature": "def _broadcast_cat_event_and_params(event, params, base_dtype):", "body": "if dtype_util.is_integer(event.dtype):<EOL><INDENT>pass<EOL><DEDENT>elif dtype_util.is_floating(event.dtype):<EOL><INDENT>event = tf.cast(event, dtype=tf.int32)<EOL><DEDENT>else:<EOL><INDENT>raise TypeError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\".format(base_dtype))<EOL><DEDENT>shape_known_statically = (<EOL>tensorshape_util.rank(params.shape) is not None and<EOL>tensorshape_util.is_fully_defined(params.shape[:-<NUM_LIT:1>]) and<EOL>tensorshape_util.is_fully_defined(event.shape))<EOL>if not shape_known_statically or params.shape[:-<NUM_LIT:1>] != event.shape:<EOL><INDENT>params *= tf.ones_like(event[..., tf.newaxis],<EOL>dtype=params.dtype)<EOL>params_shape = tf.shape(input=params)[:-<NUM_LIT:1>]<EOL>event *= tf.ones(params_shape, dtype=event.dtype)<EOL>if tensorshape_util.rank(params.shape) is not None:<EOL><INDENT>tensorshape_util.set_shape(event, params.shape[:-<NUM_LIT:1>])<EOL><DEDENT><DEDENT>return event, params<EOL>", "docstring": "Broadcasts the event or distribution parameters.", "id": "f15671:m0"}
{"signature": "@long_circle_defs_bar<EOL>def mLsXYSzlYPRO():", "body": "@value<EOL>def Bar(baz):<EOL><INDENT>pass<EOL><DEDENT>return Bar<EOL>", "docstring": "Value.", "id": "f5028:m39"}
{"signature": "def write_lines(self, lines, encoding=None, errors='<STR_LIT:strict>',<EOL>linesep=os.linesep, append=False):", "body": "if append:<EOL><INDENT>mode = '<STR_LIT>'<EOL><DEDENT>else:<EOL><INDENT>mode = '<STR_LIT:wb>'<EOL><DEDENT>f = self.open(mode)<EOL>try:<EOL><INDENT>for line in lines:<EOL><INDENT>isUnicode = isinstance(line, str)<EOL>if linesep is not None:<EOL><INDENT>if isUnicode:<EOL><INDENT>if line[-<NUM_LIT:2>:] in ('<STR_LIT:\\r\\n>', '<STR_LIT>'):<EOL><INDENT>line = line[:-<NUM_LIT:2>]<EOL><DEDENT>elif line[-<NUM_LIT:1>:] in ('<STR_LIT:\\r>', '<STR_LIT:\\n>',<EOL>'<STR_LIT>', '<STR_LIT>'):<EOL><INDENT>line = line[:-<NUM_LIT:1>]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if line[-<NUM_LIT:2>:] == '<STR_LIT:\\r\\n>':<EOL><INDENT>line = line[:-<NUM_LIT:2>]<EOL><DEDENT>elif line[-<NUM_LIT:1>:] in ('<STR_LIT:\\r>', '<STR_LIT:\\n>'):<EOL><INDENT>line = line[:-<NUM_LIT:1>]<EOL><DEDENT><DEDENT>line += linesep<EOL><DEDENT>if isUnicode:<EOL><INDENT>if encoding is None:<EOL><INDENT>encoding = sys.getdefaultencoding()<EOL><DEDENT>line = line.encode(encoding, errors)<EOL><DEDENT>f.write(line)<EOL><DEDENT><DEDENT>finally:<EOL><INDENT>f.close()<EOL><DEDENT>", "docstring": "r\"\"\" Write the given lines of text to this file.\n\n        By default this overwrites any existing file at this path.\n\n        This puts a platform-specific newline sequence on every line.\n        See 'linesep' below.\n\n        lines - A list of strings.\n\n        encoding - A Unicode encoding to use.  This applies only if\n            'lines' contains any Unicode strings.\n\n        errors - How to handle errors in Unicode encoding.  This\n            also applies only to Unicode strings.\n\n        linesep - The desired line-ending.  This line-ending is\n            applied to every line.  If a line already has any\n            standard line ending ('\\r', '\\n', '\\r\\n', u'\\x85',\n            u'\\r\\x85', u'\\u2028'), that will be stripped off and\n            this will be used instead.  The default is os.linesep,\n            which is platform-dependent ('\\r\\n' on Windows, '\\n' on\n            Unix, etc.)  Specify None to write the lines as-is,\n            like file.writelines().\n\n        Use the keyword argument append=True to append lines to the\n        file.  The default is to overwrite the file.  Warning:\n        When you use this with Unicode data, if the encoding of the\n        existing data in the file is different from the encoding\n        you specify with the encoding= parameter, the result is\n        mixed-encoding data, which can really confuse someone trying\n        to read the file later.", "id": "f21322:c1:m40"}
{"signature": "def hadamard(n, dtype=int):", "body": "<EOL>if n < <NUM_LIT:1>:<EOL><INDENT>lg2 = <NUM_LIT:0><EOL><DEDENT>else:<EOL><INDENT>lg2 = int(math.log(n, <NUM_LIT:2>))<EOL><DEDENT>if <NUM_LIT:2> ** lg2 != n:<EOL><INDENT>raise ValueError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>H = np.array([[<NUM_LIT:1>]], dtype=dtype)<EOL>for i in range(<NUM_LIT:0>, lg2):<EOL><INDENT>H = np.vstack((np.hstack((H, H)), np.hstack((H, -H))))<EOL><DEDENT>return H<EOL>", "docstring": "Construct a Hadamard matrix.\n\nConstructs an n-by-n Hadamard matrix, using Sylvester's\nconstruction.  `n` must be a power of 2.\n\nParameters\n----------\nn : int\n    The order of the matrix.  `n` must be a power of 2.\ndtype : numpy dtype\n    The data type of the array to be constructed.\n\nReturns\n-------\nH : (n, n) ndarray\n    The Hadamard matrix.\n\nNotes\n-----\n.. versionadded:: 0.8.0\n\nExamples\n--------\n>>> from scipy.linalg import hadamard\n>>> hadamard(2, dtype=complex)\narray([[ 1.+0.j,  1.+0.j],\n       [ 1.+0.j, -1.-0.j]])\n>>> hadamard(4)\narray([[ 1,  1,  1,  1],\n       [ 1, -1,  1, -1],\n       [ 1,  1, -1, -1],\n       [ 1, -1, -1,  1]])", "id": "f19328:m6"}
{"signature": "def duplicates(*iterables, **kwargs):", "body": "key = kwargs.pop('<STR_LIT:key>', lambda x: x)<EOL>assert not kwargs<EOL>zipped = more_itertools.collate(*iterables, key=key)<EOL>grouped = itertools.groupby(zipped, key=key)<EOL>groups = (<EOL>tuple(g)<EOL>for k, g in grouped<EOL>)<EOL>def has_dupes(group):<EOL><INDENT>return len(group) > <NUM_LIT:1><EOL><DEDENT>return filter(has_dupes, groups)<EOL>", "docstring": "Yield duplicate items from any number of sorted iterables of items\n\n>>> items_a = [1, 2, 3]\n>>> items_b = [0, 3, 4, 5, 6]\n>>> list(duplicates(items_a, items_b))\n[(3, 3)]\n\nIt won't behave as you expect if the iterables aren't ordered\n\n>>> items_b.append(1)\n>>> list(duplicates(items_a, items_b))\n[(3, 3)]\n>>> list(duplicates(items_a, sorted(items_b)))\n[(1, 1), (3, 3)]\n\nThis function is most interesting when it's operating on a key\nof more complex objects.\n\n>>> items_a = [dict(email='joe@example.com', id=1)]\n>>> items_b = [dict(email='joe@example.com', id=2), dict(email='other')]\n>>> dupe, = duplicates(items_a, items_b, key=operator.itemgetter('email'))\n>>> dupe[0]['email'] == dupe[1]['email'] == 'joe@example.com'\nTrue\n>>> dupe[0]['id']\n1\n>>> dupe[1]['id']\n2", "id": "f11047:m28"}
{"signature": "def t_ID(self, t):", "body": "t.endlexpos = t.lexpos + len(t.value)<EOL>value = t.value.upper()<EOL>if value in self.keywords:<EOL><INDENT>t.type = value<EOL><DEDENT>return t<EOL>", "docstring": "r\"[a-zA-Z_][0-9a-zA-Z_]*|[a-zA-Z][0-9a-zA-Z_]*[0-9a-zA-Z_]+", "id": "f14752:c65:m10"}
{"signature": "@classmethod<EOL><INDENT>def models(cls, api_version=DEFAULT_API_VERSION):<DEDENT>", "body": "if api_version == '<STR_LIT>':<EOL><INDENT>from .v2015_06_01 import models<EOL>return models<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2015_07_01 import models<EOL>return models<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_01_01_preview import models<EOL>return models<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_07_01_preview import models<EOL>return models<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_09_01_preview import models<EOL>return models<EOL><DEDENT>raise NotImplementedError(\"<STR_LIT>\".format(api_version))<EOL>", "docstring": "Module depends on the API version:\n\n           * 2015-06-01: :mod:`v2015_06_01.models<azure.mgmt.authorization.v2015_06_01.models>`\n           * 2015-07-01: :mod:`v2015_07_01.models<azure.mgmt.authorization.v2015_07_01.models>`\n           * 2018-01-01-preview: :mod:`v2018_01_01_preview.models<azure.mgmt.authorization.v2018_01_01_preview.models>`\n           * 2018-07-01-preview: :mod:`v2018_07_01_preview.models<azure.mgmt.authorization.v2018_07_01_preview.models>`\n           * 2018-09-01-preview: :mod:`v2018_09_01_preview.models<azure.mgmt.authorization.v2018_09_01_preview.models>`", "id": "f45538:c1:m2"}
{"signature": "def __isub__(self, other):", "body": "m = getmask(other)<EOL>if self._mask is nomask:<EOL><INDENT>if m is not nomask and m.any():<EOL><INDENT>self._mask = make_mask_none(self.shape, self.dtype)<EOL>self._mask += m<EOL><DEDENT><DEDENT>elif m is not nomask:<EOL><INDENT>self._mask += m<EOL><DEDENT>ndarray.__isub__(self._data, np.where(self._mask, <NUM_LIT:0>, getdata(other)))<EOL>return self<EOL>", "docstring": "Subtract other from self in-place.", "id": "f18992:c13:m44"}
{"signature": "def require_oauth(self, *scopes):", "body": "def wrapper(f):<EOL><INDENT>@wraps(f)<EOL>def decorated(*args, **kwargs):<EOL><INDENT>for func in self._before_request_funcs:<EOL><INDENT>func()<EOL><DEDENT>if hasattr(request, '<STR_LIT>') and request.oauth:<EOL><INDENT>return f(*args, **kwargs)<EOL><DEDENT>valid, req = self.verify_request(scopes)<EOL>for func in self._after_request_funcs:<EOL><INDENT>valid, req = func(valid, req)<EOL><DEDENT>if not valid:<EOL><INDENT>if self._invalid_response:<EOL><INDENT>return self._invalid_response(req)<EOL><DEDENT>return abort(<NUM_LIT>)<EOL><DEDENT>request.oauth = req<EOL>return f(*args, **kwargs)<EOL><DEDENT>return decorated<EOL><DEDENT>return wrapper<EOL>", "docstring": "Protect resource with specified scopes.", "id": "f16094:c0:m20"}
{"signature": "def __getstate__(self):", "body": "return {'<STR_LIT:name>': self.name, '<STR_LIT>': self.seg}<EOL>", "docstring": "Serializes into a dict for the pickle protocol.\n\n:returns: The dict to pickle.", "id": "f6454:c0:m28"}
{"signature": "def extend(self, *args, **kwargs):", "body": "if len(args) > <NUM_LIT:1>:<EOL><INDENT>raise TypeError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\".format(len(args)))<EOL><DEDENT>other = args[<NUM_LIT:0>] if len(args) >= <NUM_LIT:1> else ()<EOL>if isinstance(other, HTTPHeaderDict):<EOL><INDENT>for key, val in other.iteritems():<EOL><INDENT>self.add(key, val)<EOL><DEDENT><DEDENT>elif isinstance(other, Mapping):<EOL><INDENT>for key in other:<EOL><INDENT>self.add(key, other[key])<EOL><DEDENT><DEDENT>elif hasattr(other, \"<STR_LIT>\"):<EOL><INDENT>for key in other.keys():<EOL><INDENT>self.add(key, other[key])<EOL><DEDENT><DEDENT>else:<EOL><INDENT>for key, value in other:<EOL><INDENT>self.add(key, value)<EOL><DEDENT><DEDENT>for key, value in kwargs.items():<EOL><INDENT>self.add(key, value)<EOL><DEDENT>", "docstring": "Generic import function for any type of header-like object.\nAdapted version of MutableMapping.update in order to insert items\nwith self.add instead of self.__setitem__", "id": "f11878:c0:m13"}
{"signature": "def get(<EOL>self, resource_group_name, interface_endpoint_name, expand=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", interface_endpoint_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if expand is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", expand, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified interface endpoint by resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param interface_endpoint_name: The name of the interface endpoint.\n        :type interface_endpoint_name: str\n        :param expand: Expands referenced resources.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: InterfaceEndpoint or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_12_01.models.InterfaceEndpoint or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29226:c0:m3"}
{"signature": "def get_critical(self):", "body": "return _lib.X509_EXTENSION_get_critical(self._extension)<EOL>", "docstring": "Returns the critical field of this X.509 extension.\n\n:return: The critical field.", "id": "f4638:c5:m4"}
{"signature": "def is_mountable(self):", "body": "return True<EOL>", "docstring": "Determine if a wheel is asserted as mountable by its metadata.", "id": "f17272:c1:m17"}
{"signature": "def list_by_region(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_region.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>', pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.asc_location, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.JitNetworkAccessPolicyPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.JitNetworkAccessPolicyPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Policies for protecting resources using Just-in-Time access control for\n        the subscription, location.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of JitNetworkAccessPolicy\n        :rtype:\n         ~azure.mgmt.security.models.JitNetworkAccessPolicyPaged[~azure.mgmt.security.models.JitNetworkAccessPolicy]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38741:c0:m2"}
{"signature": "def meth17(self):", "body": "", "docstring": "hehehe", "id": "f18448:c0:m17"}
{"signature": "def _get_default_import_policy(self):", "body": "return self.__default_import_policy<EOL>", "docstring": "Getter method for default_import_policy, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/state/default_import_policy (default-policy-type)\n\n    YANG Description: explicitly set a default policy if no policy definition\nin the import policy chain is satisfied.", "id": "f23211:c1:m5"}
{"signature": "def get_conn(self):", "body": "conn_config = self._get_conn_params()<EOL>conn = snowflake.connector.connect(**conn_config)<EOL>return conn<EOL>", "docstring": "Returns a snowflake.connection object", "id": "f9131:c0:m3"}
{"signature": "@line_magic<EOL><INDENT>def unalias(self, parameter_s='<STR_LIT>'):<DEDENT>", "body": "aname = parameter_s.strip()<EOL>self.shell.alias_manager.undefine_alias(aname)<EOL>stored = self.shell.db.get('<STR_LIT>', {} )<EOL>if aname in stored:<EOL><INDENT>print(\"<STR_LIT>\",aname)<EOL>del stored[aname]<EOL>self.shell.db['<STR_LIT>'] = stored<EOL><DEDENT>", "docstring": "Remove an alias", "id": "f21432:c0:m1"}
{"signature": "def fromrecords(reclist, dtype=None, shape=None, formats=None, names=None,<EOL>titles=None, aligned=False, byteorder=None,<EOL>fill_value=None, mask=nomask):", "body": "<EOL>_mask = getattr(reclist, '<STR_LIT>', None)<EOL>try:<EOL><INDENT>nfields = len(reclist[<NUM_LIT:0>])<EOL><DEDENT>except TypeError:<EOL><INDENT>nfields = len(reclist[<NUM_LIT:0>].dtype)<EOL><DEDENT>if isinstance(reclist, ndarray):<EOL><INDENT>if isinstance(reclist, MaskedArray):<EOL><INDENT>reclist = reclist.filled().view(ndarray)<EOL><DEDENT>if dtype is None:<EOL><INDENT>dtype = reclist.dtype<EOL><DEDENT>reclist = reclist.tolist()<EOL><DEDENT>mrec = recfromrecords(reclist, dtype=dtype, shape=shape, formats=formats,<EOL>names=names, titles=titles,<EOL>aligned=aligned, byteorder=byteorder).view(mrecarray)<EOL>if fill_value is not None:<EOL><INDENT>mrec.fill_value = fill_value<EOL><DEDENT>if mask is not nomask:<EOL><INDENT>mask = np.array(mask, copy=False)<EOL>maskrecordlength = len(mask.dtype)<EOL>if maskrecordlength:<EOL><INDENT>mrec._mask.flat = mask<EOL><DEDENT>elif len(mask.shape) == <NUM_LIT:2>:<EOL><INDENT>mrec._mask.flat = [tuple(m) for m in mask]<EOL><DEDENT>else:<EOL><INDENT>mrec.__setmask__(mask)<EOL><DEDENT><DEDENT>if _mask is not None:<EOL><INDENT>mrec._mask[:] = _mask<EOL><DEDENT>return mrec<EOL>", "docstring": "Creates a MaskedRecords from a list of records.\n\n    Parameters\n    ----------\n    reclist : sequence\n        A list of records. Each element of the sequence is first converted\n        to a masked array if needed. If a 2D array is passed as argument, it is\n        processed line by line\n    dtype : {None, dtype}, optional\n        Data type descriptor.\n    shape : {None,int}, optional\n        Number of records. If None, ``shape`` is defined from the shape of the\n        first array in the list.\n    formats : {None, sequence}, optional\n        Sequence of formats for each individual field. If None, the formats will\n        be autodetected by inspecting the fields and selecting the highest dtype\n        possible.\n    names : {None, sequence}, optional\n        Sequence of the names of each field.\n    fill_value : {None, sequence}, optional\n        Sequence of data to be used as filling values.\n    mask : {nomask, sequence}, optional.\n        External mask to apply on the data.\n\n    Notes\n    -----\n    Lists of tuples should be preferred over lists of lists for faster processing.", "id": "f18990:m5"}
{"signature": "def list(<EOL>self, filter=None, select=None, expand=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>', pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>if select is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", select, '<STR_LIT:str>')<EOL><DEDENT>if expand is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", expand, '<STR_LIT:str>')<EOL><DEDENT><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.AlertPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.AlertPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "List all the alerts that are associated with the subscription.\n\n        :param filter: OData filter. Optional.\n        :type filter: str\n        :param select: OData select. Optional.\n        :type select: str\n        :param expand: OData expand. Optional.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Alert\n        :rtype:\n         ~azure.mgmt.security.models.AlertPaged[~azure.mgmt.security.models.Alert]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38749:c0:m1"}
{"signature": "def _insert_many(self, i, j, x):", "body": "order = np.argsort(i, kind='<STR_LIT>')  <EOL>i = i.take(order, mode='<STR_LIT>')<EOL>j = j.take(order, mode='<STR_LIT>')<EOL>x = x.take(order, mode='<STR_LIT>')<EOL>do_sort = self.has_sorted_indices<EOL>idx_dtype = get_index_dtype((self.indices, self.indptr),<EOL>maxval=(self.indptr[-<NUM_LIT:1>] + x.size))<EOL>self.indptr = np.asarray(self.indptr, dtype=idx_dtype)<EOL>self.indices = np.asarray(self.indices, dtype=idx_dtype)<EOL>i = np.asarray(i, dtype=idx_dtype)<EOL>j = np.asarray(j, dtype=idx_dtype)<EOL>indices_parts = []<EOL>data_parts = []<EOL>ui, ui_indptr = _compat_unique(i, return_index=True)<EOL>ui_indptr = np.append(ui_indptr, len(j))<EOL>new_nnzs = np.diff(ui_indptr)<EOL>prev = <NUM_LIT:0><EOL>for c, (ii, js, je) in enumerate(izip(ui, ui_indptr, ui_indptr[<NUM_LIT:1>:])):<EOL><INDENT>start = self.indptr[prev]<EOL>stop = self.indptr[ii]<EOL>indices_parts.append(self.indices[start:stop])<EOL>data_parts.append(self.data[start:stop])<EOL>uj, uj_indptr = _compat_unique(j[js:je][::-<NUM_LIT:1>], return_index=True)<EOL>if len(uj) == je - js:<EOL><INDENT>indices_parts.append(j[js:je])<EOL>data_parts.append(x[js:je])<EOL><DEDENT>else:<EOL><INDENT>indices_parts.append(j[js:je][::-<NUM_LIT:1>][uj_indptr])<EOL>data_parts.append(x[js:je][::-<NUM_LIT:1>][uj_indptr])<EOL>new_nnzs[c] = len(uj)<EOL><DEDENT>prev = ii<EOL><DEDENT>start = self.indptr[ii]<EOL>indices_parts.append(self.indices[start:])<EOL>data_parts.append(self.data[start:])<EOL>self.indices = np.concatenate(indices_parts)<EOL>self.data = np.concatenate(data_parts)<EOL>nnzs = np.asarray(np.ediff1d(self.indptr, to_begin=<NUM_LIT:0>), dtype=idx_dtype)<EOL>nnzs[<NUM_LIT:1>:][ui] += new_nnzs<EOL>self.indptr = np.cumsum(nnzs, out=nnzs)<EOL>if do_sort:<EOL><INDENT>self.has_sorted_indices = False<EOL>self.sort_indices()<EOL><DEDENT>self.check_format(full_check=False)<EOL>", "docstring": "Inserts new nonzero at each (i, j) with value x\n\n        Here (i,j) index major and minor respectively.\n        i, j and x must be non-empty, 1d arrays.\n        Inserts each major group (e.g. all entries per row) at a time.\n        Maintains has_sorted_indices property.\n        Modifies i, j, x in place.", "id": "f19581:c0:m30"}
{"signature": "def __repr__(self):", "body": "if np.any(list(map(np.iscomplexobj, self.param_columns))):<EOL><INDENT>is_complex = \"<STR_LIT>\"<EOL><DEDENT>else:<EOL><INDENT>is_complex = \"<STR_LIT>\"<EOL><DEDENT>if self.dataname:<EOL><INDENT>return \"<STR_LIT>\" % (self.func.__name__, is_complex,<EOL>os.path.basename(self.dataname))<EOL><DEDENT>else:<EOL><INDENT>return \"<STR_LIT>\" % (self.func.__name__, is_complex)<EOL><DEDENT>", "docstring": "Pretty-printing, esp. for Nose output", "id": "f19449:c0:m3"}
{"signature": "def add_sms_spec_to_request(self, req, federation='<STR_LIT>', loes=None,<EOL>context='<STR_LIT>', url='<STR_LIT>'):", "body": "<EOL>if federation:<EOL><INDENT>if not isinstance(federation, list):<EOL><INDENT>federation = [federation]<EOL><DEDENT><DEDENT>if not url:<EOL><INDENT>url = \"<STR_LIT>\".format(self.mdss_endpoint, context,<EOL>quote_plus(self.entity_id))<EOL><DEDENT>http_resp = self.httpcli(method='<STR_LIT:GET>', url=url, verify=self.verify_ssl)<EOL>if http_resp.status_code >= <NUM_LIT>:<EOL><INDENT>raise ConnectionError('<STR_LIT>'.format(http_resp.text))<EOL><DEDENT>msg = JsonWebToken().from_jwt(http_resp.text, keyjar=self.mdss_keys)<EOL>if msg['<STR_LIT>'] != self.mdss_owner:<EOL><INDENT>raise KeyError('<STR_LIT>')<EOL><DEDENT>if federation:<EOL><INDENT>_sms = dict(<EOL>[(fo, _ms) for fo, _ms in msg.items() if fo in federation])<EOL><DEDENT>else:<EOL><INDENT>_sms = msg.extra()<EOL>try:<EOL><INDENT>del _sms['<STR_LIT>']<EOL><DEDENT>except KeyError:<EOL><INDENT>pass<EOL><DEDENT><DEDENT>req.update({'<STR_LIT>': _sms})<EOL>return req<EOL>", "docstring": "Add signed metadata statements to the request\n\n:param req: The request so far\n:param federation: If only signed metadata statements from a specific\n    set of federations should be included this is the set.\n:param loes: - not used -\n:param context: What kind of request/response it is: 'registration',\n    'discovery' or 'response'. The later being registration response.\n:param url: Just for testing !!\n:return: A possibly augmented request.", "id": "f14439:c3:m1"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/hello_authentication/config (container)\n\nYANG Description: This container defines ISIS authentication configuration.", "id": "f22414:c1:m2"}
{"signature": "def add_entity(<EOL>self, app_id, version_id, name=None, custom_headers=None, raw=False, **operation_config):", "body": "model_create_object = models.ModelCreateObject(name=name)<EOL>url = self.add_entity.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", app_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", version_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>body_content = self._serialize.body(model_create_object, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT:str>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Adds a simple entity extractor to a version of the application.\n\n        :param app_id: The application ID.\n        :type app_id: str\n        :param version_id: The version ID.\n        :type version_id: str\n        :param name: Name of the new entity extractor.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: str or ClientRawResponse if raw=true\n        :rtype: str or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException>`", "id": "f43227:c0:m3"}
{"signature": "def resize_image_to_fit(image, dest_w, dest_h):", "body": "dest_w = float(dest_w)<EOL>dest_h = float(dest_h)<EOL>dest_ratio = dest_w / dest_h<EOL>src_w = float(image.size[<NUM_LIT:0>])<EOL>src_h = float(image.size[<NUM_LIT:1>])<EOL>src_ratio = src_w / src_h<EOL>if src_ratio < dest_ratio:<EOL><INDENT>scale = dest_h / src_h<EOL>scaled_h = dest_h<EOL>scaled_w = src_w * scale<EOL><DEDENT>else:<EOL><INDENT>scale = dest_w / src_w<EOL>scaled_w = dest_w<EOL>scaled_h = src_h * scale<EOL><DEDENT>scaled_image = image.resize((int(scaled_w), int(scaled_h)), PIL.Image.ANTIALIAS)<EOL>return scaled_image<EOL>", "docstring": "Resize the image to fit inside dest rectangle.  Resultant image may be smaller than target\n:param image: PIL.Image\n:param dest_w: Target width\n:param dest_h: Target height\n:return: Scaled image", "id": "f7523:m0"}
{"signature": "def decode(self, input, errors='<STR_LIT:strict>'):", "body": "raise NotImplementedError<EOL>", "docstring": "Decodes the object input and returns a tuple (output\n            object, length consumed).\n\n            input must be an object which provides the bf_getreadbuf\n            buffer slot. Python strings, buffer objects and memory\n            mapped files are examples of objects providing this slot.\n\n            errors defines the error handling to apply. It defaults to\n            'strict' handling.\n\n            The method may not store state in the Codec instance. Use\n            StreamReader for codecs which have to keep state in order to\n            make decoding efficient.\n\n            The decoder must be able to handle zero length input and\n            return an empty object of the output object type in this\n            situation.", "id": "f16912:c1:m1"}
{"signature": "def _bits_in_condition(self, cond):", "body": "all_bits = []<EOL>if cond is not None:<EOL><INDENT>all_bits.extend([(cond[<NUM_LIT:0>], j) for j in range(self.cregs[cond[<NUM_LIT:0>].name].size)])<EOL><DEDENT>return all_bits<EOL>", "docstring": "Return a list of bits in the given condition.\n\n        Args:\n            cond (tuple or None): optional condition (ClassicalRegister, int)\n\n        Returns:\n            list[(ClassicalRegister, idx)]: list of bits", "id": "f10770:c0:m16"}
{"signature": "def _get_max_prefixes(self):", "body": "return self.__max_prefixes<EOL>", "docstring": "Getter method for max_prefixes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/config/max_prefixes (uint32)\n\n    YANG Description: Maximum number of prefixes that will be accepted\nfrom the neighbour", "id": "f23182:c1:m2"}
{"signature": "def send_sms(request, to_number, body, callback_urlname=\"<STR_LIT>\"):", "body": "client = TwilioRestClient(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)<EOL>from_number = settings.TWILIO_PHONE_NUMBER<EOL>message = OutgoingSMS.objects.create(<EOL>from_number=from_number,<EOL>to_number=to_number,<EOL>body=body,<EOL>)<EOL>status_callback = None<EOL>if callback_urlname:<EOL><INDENT>status_callback = build_callback_url(request, callback_urlname, message)<EOL><DEDENT>logger.debug(\"<STR_LIT>\",<EOL>to_number, status_callback, body)<EOL>if not getattr(settings, \"<STR_LIT>\", False):<EOL><INDENT>sent = client.sms.messages.create(<EOL>to=to_number,<EOL>from_=from_number,<EOL>body=body,<EOL>status_callback=status_callback<EOL>)<EOL>logger.debug(\"<STR_LIT>\", sent.__dict__)<EOL>message.sms_sid = sent.sid<EOL>message.account_sid = sent.account_sid<EOL>message.status = sent.status<EOL>message.to_parsed = sent.to<EOL>if sent.price:<EOL><INDENT>message.price = Decimal(force_text(sent.price))<EOL>message.price_unit = sent.price_unit<EOL><DEDENT>message.sent_at = sent.date_created<EOL>message.save(update_fields=[<EOL>\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT:status>\", \"<STR_LIT>\",<EOL>\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"<EOL>])<EOL><DEDENT>else:<EOL><INDENT>logger.info(\"<STR_LIT>\", from_number, to_number, body)<EOL><DEDENT>return message<EOL>", "docstring": "Create :class:`OutgoingSMS` object and send SMS using Twilio.", "id": "f12860:m1"}
{"signature": "@staticmethod<EOL><INDENT>def parse_questions(raw_page):<DEDENT>", "body": "raw_questions = json.loads(raw_page)<EOL>questions = raw_questions['<STR_LIT>']<EOL>for question in questions:<EOL><INDENT>yield question<EOL><DEDENT>", "docstring": "Parse a StackExchange API raw response.\n\n        The method parses the API response retrieving the\n        questions from the received items\n\n        :param items: items from where to parse the questions\n\n        :returns: a generator of questions", "id": "f13171:c0:m8"}
{"signature": "def generate_uri(<EOL>self, resource_group_name, automation_account_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.generate_uri.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", automation_account_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT:str>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Generates a Uri for use in creating a webhook.\n\n        :param resource_group_name: Name of an Azure Resource group.\n        :type resource_group_name: str\n        :param automation_account_name: The name of the automation account.\n        :type automation_account_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: str or ClientRawResponse if raw=true\n        :rtype: str or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.automation.models.ErrorResponseException>`", "id": "f43592:c0:m1"}
{"signature": "def add_handler(log_handler_level, handler, formatter=None, log_filter=None):", "body": "handler.setLevel(log_handler_level)<EOL>if formatter is not None:<EOL><INDENT>handler.setFormatter(formatter)<EOL><DEDENT>if log_filter is not None:<EOL><INDENT>handler.addFilter(log_filter)<EOL><DEDENT>log.addHandler(handler)<EOL>", "docstring": ":param log_handler_level:   str of the level to set for the handler\n:param handler:             logging.Handler handler to add\n:param formatter:           logging.Formatter instance to use\n:param log_filter:          logging.filter instance to add to handler\n:return:                    None", "id": "f4673:m5"}
{"signature": "def encode_key_as_entity(obj):", "body": "<EOL>return obj.get_async()<EOL>", "docstring": "Get the Entity from the ndb.Key for further encoding.", "id": "f2282:m2"}
{"signature": "def create_queue(self, queue_name, queue=None, fail_on_exist=False):", "body": "_validate_not_none('<STR_LIT>', queue_name)<EOL>request = HTTPRequest()<EOL>request.method = '<STR_LIT>'<EOL>request.host = self._get_host()<EOL>request.path = '<STR_LIT:/>' + _str(queue_name) + '<STR_LIT>'<EOL>request.body = _get_request_body(_convert_queue_to_xml(queue))<EOL>request.path, request.query = self._httpclient._update_request_uri_query(request)  <EOL>request.headers = self._update_service_bus_header(request)<EOL>if not fail_on_exist:<EOL><INDENT>try:<EOL><INDENT>self._perform_request(request)<EOL>return True<EOL><DEDENT>except AzureHttpError as ex:<EOL><INDENT>_dont_fail_on_exist(ex)<EOL>return False<EOL><DEDENT><DEDENT>else:<EOL><INDENT>self._perform_request(request)<EOL>return True<EOL><DEDENT>", "docstring": "Creates a new queue. Once created, this queue's resource manifest is\nimmutable.\n\nqueue_name:\n    Name of the queue to create.\nqueue:\n    Queue object to create.\nfail_on_exist:\n    Specify whether to throw an exception when the queue exists.", "id": "f39500:c0:m13"}
{"signature": "def delete(self, resource_id):", "body": "self.logger.debug('<STR_LIT>'.format(resource_id))<EOL>if self.driver._es.exists(<EOL>index=self.driver._index,<EOL>id=resource_id,<EOL>doc_type='<STR_LIT>'<EOL>) == False:<EOL><INDENT>raise ValueError(\"<STR_LIT>\".format(resource_id))<EOL><DEDENT>return self.driver._es.delete(<EOL>index=self.driver._index,<EOL>id=resource_id,<EOL>doc_type='<STR_LIT>'<EOL>)<EOL>", "docstring": "Delete an object from elasticsearch.\n        :param resource_id: id of the object to be deleted.\n        :return:", "id": "f6004:c0:m5"}
{"signature": "def _get_name(self):", "body": "return self.__name<EOL>", "docstring": "Getter method for name, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/config/name (string)\n\n    YANG Description: [adapted from IETF interfaces model (RFC 7223)]\n\nThe name of the interface.\n\nA device MAY restrict the allowed values for this leaf,\npossibly depending on the type of the interface.\nFor system-controlled interfaces, this leaf is the\ndevice-specific name of the interface.  The 'config false'\nlist interfaces/interface[name]/state contains the currently\nexisting interfaces on the device.\n\nIf a client tries to create configuration for a\nsystem-controlled interface that is not present in the\ncorresponding state list, the server MAY reject\nthe request if the implementation does not support\npre-provisioning of interfaces or if the name refers to\nan interface that can never exist in the system.  A\nNETCONF server MUST reply with an rpc-error with the\nerror-tag 'invalid-value' in this case.\n\nThe IETF model in RFC 7223 provides YANG features for the\nfollowing (i.e., pre-provisioning and arbitrary-names),\nhowever they are omitted here:\n\n If the device supports pre-provisioning of interface\n configuration, the 'pre-provisioning' feature is\n advertised.\n\n If the device allows arbitrarily named user-controlled\n interfaces, the 'arbitrary-names' feature is advertised.\n\nWhen a configured user-controlled interface is created by\nthe system, it is instantiated with the same name in the\n/interfaces/interface[name]/state list.", "id": "f21968:c0:m5"}
{"signature": "def get_plot_data(self):", "body": "json_dic = {\"<STR_LIT>\": []}<EOL>sample_dic = {}<EOL>sample_assembly_map = {}<EOL>for entry in self.storage.values():<EOL><INDENT>sample_id = re.match(\"<STR_LIT>\", entry[\"<STR_LIT>\"]).groups()[<NUM_LIT:0>]<EOL>if sample_id not in sample_dic:<EOL><INDENT>sample_dic[sample_id] = {}<EOL><DEDENT>contig_id = self._get_contig_id(entry[\"<STR_LIT>\"])<EOL>database = entry[\"<STR_LIT>\"]<EOL>if database not in sample_dic[sample_id]:<EOL><INDENT>sample_dic[sample_id][database] = []<EOL><DEDENT>if sample_id not in sample_assembly_map:<EOL><INDENT>sample_assembly_map[sample_id] = entry[\"<STR_LIT>\"]<EOL><DEDENT>sample_dic[sample_id][database].append(<EOL>{\"<STR_LIT>\": contig_id,<EOL>\"<STR_LIT>\": entry[\"<STR_LIT>\"],<EOL>\"<STR_LIT>\": entry[\"<STR_LIT>\"].replace(\"<STR_LIT:'>\", \"<STR_LIT>\"),<EOL>\"<STR_LIT>\": entry[\"<STR_LIT>\"],<EOL>\"<STR_LIT>\": entry[\"<STR_LIT>\"],<EOL>\"<STR_LIT>\": entry[\"<STR_LIT>\"],<EOL>},<EOL>)<EOL><DEDENT>for sample, data in sample_dic.items():<EOL><INDENT>json_dic[\"<STR_LIT>\"].append(<EOL>{<EOL>\"<STR_LIT>\": sample,<EOL>\"<STR_LIT:data>\": {\"<STR_LIT>\": data},<EOL>\"<STR_LIT>\": sample_assembly_map[sample]<EOL>}<EOL>)<EOL><DEDENT>return json_dic<EOL>", "docstring": "Generates the JSON report to plot the gene boxes\n\n        Following the convention of the reports platform, this method returns\n        a list of JSON/dict objects with the information about each entry in\n        the abricate file. The information contained in this JSON is::\n\n            {contig_id: <str>,\n             seqRange: [<int>, <int>],\n             gene: <str>,\n             accession: <str>,\n             coverage: <float>,\n             identity: <float>\n             }\n\n        Note that the `seqRange` entry contains the position in the\n        corresponding contig, not the absolute position in the whole assembly.\n\n        Returns\n        -------\n        json_dic : list\n            List of JSON/dict objects with the report data.", "id": "f6615:c1:m2"}
{"signature": "def _set_send_default_route(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__send_default_route = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for send_default_route, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/config/send_default_route (boolean)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_send_default_route is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_send_default_route() directly.\n\nYANG Description: If set to true, send the default-route to the neighbour(s)", "id": "f23336:c1:m3"}
{"signature": "def get_video_frames(<EOL>self, team_name, review_id, start_seed=None, no_of_records=None, filter=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_video_frames.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", team_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", review_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if start_seed is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", start_seed, '<STR_LIT:int>')<EOL><DEDENT>if no_of_records is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", no_of_records, '<STR_LIT:int>')<EOL><DEDENT>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.APIErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "The reviews created would show up for Reviewers on your team. As\n        Reviewers complete reviewing, results of the Review would be POSTED\n        (i.e. HTTP POST) on the specified CallBackEndpoint.\n        <h3>CallBack Schemas </h3>\n        <h4>Review Completion CallBack Sample</h4>\n        <p>\n        {<br/>\n        \"ReviewId\": \"<Review Id>\",<br/>\n        \"ModifiedOn\": \"2016-10-11T22:36:32.9934851Z\",<br/>\n        \"ModifiedBy\": \"<Name of the Reviewer>\",<br/>\n        \"CallBackType\": \"Review\",<br/>\n        \"ContentId\": \"<The ContentId that was specified input>\",<br/>\n        \"Metadata\": {<br/>\n        \"adultscore\": \"0.xxx\",<br/>\n        \"a\": \"False\",<br/>\n        \"racyscore\": \"0.xxx\",<br/>\n        \"r\": \"True\"<br/>\n        },<br/>\n        \"ReviewerResultTags\": {<br/>\n        \"a\": \"False\",<br/>\n        \"r\": \"True\"<br/>\n        }<br/>\n        }<br/>\n        </p>.\n\n        :param team_name: Your team name.\n        :type team_name: str\n        :param review_id: Id of the review.\n        :type review_id: str\n        :param start_seed: Time stamp of the frame from where you want to\n         start fetching the frames.\n        :type start_seed: int\n        :param no_of_records: Number of frames to fetch.\n        :type no_of_records: int\n        :param filter: Get frames filtered by tags.\n        :type filter: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Frames or ClientRawResponse if raw=true\n        :rtype: ~azure.cognitiveservices.vision.contentmoderator.models.Frames\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`APIErrorException<azure.cognitiveservices.vision.contentmoderator.models.APIErrorException>`", "id": "f41559:c0:m6"}
{"signature": "def register_loader_type(loader_type, provider_factory):", "body": "_provider_factories[loader_type] = provider_factory<EOL>", "docstring": "Register `provider_factory` to make providers for `loader_type`\n\n    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,\n    and `provider_factory` is a function that, passed a *module* object,\n    returns an ``IResourceProvider`` for that module.", "id": "f16923:m9"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/graceful_restart/state (container)\n\nYANG Description: State information for BGP graceful-restart", "id": "f23386:c1:m5"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv4_external_reachability/prefixes/prefixes/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of IPv4 standard prefix.", "id": "f22554:c1:m3"}
{"signature": "def random_adjspecies_pair(maxlen=None, prevent_stutter=True):", "body": "while True:<EOL><INDENT>pair = _random_adjspecies_pair()<EOL>if maxlen and len('<STR_LIT>'.join(pair)) > maxlen:<EOL><INDENT>continue<EOL><DEDENT>if prevent_stutter and pair[<NUM_LIT:0>][-<NUM_LIT:1>] == pair[<NUM_LIT:1>][<NUM_LIT:0>]:<EOL><INDENT>continue<EOL><DEDENT>return pair<EOL><DEDENT>", "docstring": "Return an ordered 2-tuple containing a species and a describer.\nThe letter-count of the pair is guarantee to not exceed `maxlen` if\nit is given. If `prevent_stutter` is True, the last letter of the\nfirst item of the pair will be different from the first letter of\nthe second item.", "id": "f15325:m5"}
{"signature": "def list_by_resource_group(<EOL>self, resource_group_name, top=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_resource_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>', min_length=<NUM_LIT:1>)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>', min_length=<NUM_LIT:1>)<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ZonePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ZonePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists the DNS zones within a resource group.\n\n        :param resource_group_name: The name of the resource group. The name\n         is case insensitive.\n        :type resource_group_name: str\n        :param top: The maximum number of record sets to return. If not\n         specified, returns up to 100 record sets.\n        :type top: int\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Zone\n        :rtype:\n         ~azure.mgmt.dns.v2018_03_01_preview.models.ZonePaged[~azure.mgmt.dns.v2018_03_01_preview.models.Zone]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f26166:c0:m6"}
{"signature": "def parse_display_name(chrom, pos, ref, alt, variant_type):", "body": "return '<STR_LIT:_>'.join([chrom, pos, ref, alt, variant_type])<EOL>", "docstring": "Parse the variant id for a variant\n\n    This is used to display the variant in scout.\n\n    Args:\n        chrom(str)\n        pos(str)\n        ref(str)\n        alt(str)\n        variant_type(str): 'clinical' or 'research'\n\n    Returns:\n        variant_id(str): The variant id in human readable format", "id": "f13826:m3"}
{"signature": "def _set_retranmission_queue_length(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__retranmission_queue_length = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for retranmission_queue_length, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/virtual_links/virtual_link/state/retranmission_queue_length (uint32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_retranmission_queue_length is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_retranmission_queue_length() directly.\n\n    YANG Description: The number of LSAs that are currently in the queue to be\nretransmitted to the neighbor", "id": "f23127:c1:m30"}
{"signature": "@memoized_property<EOL><INDENT>def uncharge(self):<DEDENT>", "body": "return Uncharger(acid_base_pairs=self.acid_base_pairs)<EOL>", "docstring": ":returns: A callable :class:`~molvs.charge.Uncharger` instance.", "id": "f16466:c0:m13"}
{"signature": "def delete(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Delete schedule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param name: The name of the schedule.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f45878:c0:m5"}
{"signature": "def _build_tensor(self, ndarray):", "body": "ndarray = np.asarray(ndarray).astype(self.dtype)<EOL>return tf.compat.v1.placeholder_with_default(<EOL>input=ndarray, shape=ndarray.shape if self.use_static_shape else None)<EOL>", "docstring": "Convert a numpy array to a TF placeholder.\n\n        Args:\n          ndarray: any object convertible to a numpy array via `np.asarray()`.\n\n        Returns:\n          placeholder: a TensorFlow `placeholder` with default value given by the\n          provided `ndarray`, dtype given by `self.dtype`, and shape specified\n          statically only if `self.use_static_shape` is `True`.", "id": "f15485:c1:m7"}
{"signature": "@_to_bits(<NUM_LIT:1>)<EOL>@_op_expand(<NUM_LIT:1>)<EOL>def iden(self, q):", "body": "return self.append(IdGate(), [q], [])<EOL>", "docstring": "Apply Identity to q.", "id": "f10833:m0"}
{"signature": "def _get_flags(self):", "body": "return self.__flags<EOL>", "docstring": "Getter method for flags, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/is_reachability/neighbors/neighbors/expense_metric/state/flags (isis-metric-flags)\n\nYANG Description: ISIS Expense Metric Flags.", "id": "f22963:c0:m5"}
{"signature": "def postdraw(self):", "body": "pass<EOL>", "docstring": "Called after calling the :py:meth:`draw()` Method.\n\nUseful for unsetting OpenGL state.", "id": "f11163:c1:m5"}
{"signature": "def list_all(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_all.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ApplicationGatewayPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ApplicationGatewayPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the application gateways in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ApplicationGateway\n        :rtype:\n         ~azure.mgmt.network.v2018_02_01.models.ApplicationGatewayPaged[~azure.mgmt.network.v2018_02_01.models.ApplicationGateway]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f35260:c0:m9"}
{"signature": "def ready(self):", "body": "pass<EOL>", "docstring": "Initialisation (setup lookups and signal handlers).", "id": "f1657:c1:m3"}
{"signature": "def redeploy(<EOL>self, resource_group_name, vm_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._redeploy_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "The operation to redeploy a virtual machine.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns OperationStatusResponse\n         or ClientRawResponse<OperationStatusResponse> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2017_12_01.models.OperationStatusResponse]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2017_12_01.models.OperationStatusResponse]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24370:c0:m28"}
{"signature": "@date_of_cessation.setter<EOL><INDENT>def date_of_cessation(self, date_of_cessation):<DEDENT>", "body": "self._date_of_cessation = date_of_cessation<EOL>", "docstring": "Sets the date_of_cessation of this AuthorizedSignatory.\n\n\n:param date_of_cessation: The date_of_cessation of this AuthorizedSignatory.\n:type: str", "id": "f16308:c0:m18"}
{"signature": "def fetchone(self):", "body": "self._check_executed()<EOL>if self.rownumber >= len(self._rows): return None<EOL>result = self._rows[self.rownumber]<EOL>self.rownumber = self.rownumber+<NUM_LIT:1><EOL>return result<EOL>", "docstring": "Fetches a single row from the cursor. None indicates that\n        no more rows are available.", "id": "f21303:c1:m3"}
{"signature": "def _get_interface_id(self):", "body": "return self.__interface_id<EOL>", "docstring": "Getter method for interface_id, mapped from YANG variable /network_instances/network_instance/mpls/global/interface_attributes/interface/state/interface_id (oc-if:interface-id)\n\nYANG Description: Indentifier for the MPLS interface", "id": "f22193:c1:m2"}
{"signature": "def get(<EOL>self, vault_name, resource_group_name, fabric_name, container_name, protected_item_name, operation_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", vault_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", fabric_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", container_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", protected_item_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", operation_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Fetches the result of any operation on the backup item.\n\n        :param vault_name: The name of the recovery services vault.\n        :type vault_name: str\n        :param resource_group_name: The name of the resource group where the\n         recovery services vault is present.\n        :type resource_group_name: str\n        :param fabric_name: Fabric name associated with the backup item.\n        :type fabric_name: str\n        :param container_name: Container name associated with the backup item.\n        :type container_name: str\n        :param protected_item_name: Backup item name whose details are to be\n         fetched.\n        :type protected_item_name: str\n        :param operation_id: OperationID which represents the operation whose\n         result needs to be fetched.\n        :type operation_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ProtectedItemResource or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.recoveryservicesbackup.models.ProtectedItemResource or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f42770:c0:m1"}
{"signature": "def clean_markup(self, orig_str):", "body": "for val in self.get_markup_vars():<EOL><INDENT>orig_str = orig_str.replace(val, '<STR_LIT>')<EOL><DEDENT>return orig_str<EOL>", "docstring": "clean markup from string", "id": "f17592:c1:m1"}
{"signature": "def delete(<EOL>self, resource_group_name, image_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>image_name=image_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes an Image.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param image_name: The name of the image.\n        :type image_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24625:c0:m6"}
{"signature": "def from_astropy_table(table):", "body": "import vaex.file.other<EOL>return vaex.file.other.DatasetAstropyTable(table=table)<EOL>", "docstring": "Create a vaex DataFrame from an Astropy Table.", "id": "f6963:m5"}
{"signature": "def _get_received_system_id(self):", "body": "return self.__received_system_id<EOL>", "docstring": "Getter method for received_system_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/purge_oi/state/received_system_id (oc-isis-types:system-id)\n\n    YANG Description: System ID of the Intermediate System from which the purge was\nreceived.", "id": "f22888:c0:m11"}
{"signature": "@asyncio.coroutine<EOL><INDENT>def flush(self, timeout=<NUM_LIT>):<DEDENT>", "body": "if timeout <= <NUM_LIT:0>:<EOL><INDENT>raise ErrBadTimeout<EOL><DEDENT>if self.is_closed:<EOL><INDENT>raise ErrConnectionClosed<EOL><DEDENT>future = asyncio.Future(loop=self._loop)<EOL>try:<EOL><INDENT>yield from self._send_ping(future)<EOL>yield from asyncio.wait_for(future, timeout, loop=self._loop)<EOL><DEDENT>except asyncio.TimeoutError:<EOL><INDENT>future.cancel()<EOL>raise ErrTimeout<EOL><DEDENT>", "docstring": "Sends a ping to the server expecting a pong back ensuring\nwhat we have written so far has made it to the server and\nalso enabling measuring of roundtrip time.\nIn case a pong is not returned within the allowed timeout,\nthen it will raise ErrTimeout.", "id": "f14034:c3:m19"}
{"signature": "def delete(filename):", "body": "OggOpus(filename).delete()<EOL>", "docstring": "Remove tags from a file.", "id": "f2191:m0"}
{"signature": "def hankel(c, r=None):", "body": "c = np.asarray(c).ravel()<EOL>if r is None:<EOL><INDENT>r = np.zeros_like(c)<EOL><DEDENT>else:<EOL><INDENT>r = np.asarray(r).ravel()<EOL><DEDENT>vals = np.concatenate((c, r[<NUM_LIT:1>:]))<EOL>a, b = np.ogrid[<NUM_LIT:0>:len(c), <NUM_LIT:0>:len(r)]<EOL>indx = a + b<EOL>return vals[indx]<EOL>", "docstring": "Construct a Hankel matrix.\n\nThe Hankel matrix has constant anti-diagonals, with `c` as its\nfirst column and `r` as its last row.  If `r` is not given, then\n`r = zeros_like(c)` is assumed.\n\nParameters\n----------\nc : array_like\n    First column of the matrix.  Whatever the actual shape of `c`, it\n    will be converted to a 1-D array.\nr : array_like\n    Last row of the matrix. If None, ``r = zeros_like(c)`` is assumed.\n    r[0] is ignored; the last row of the returned matrix is\n    ``[c[-1], r[1:]]``.  Whatever the actual shape of `r`, it will be\n    converted to a 1-D array.\n\nReturns\n-------\nA : (len(c), len(r)) ndarray\n    The Hankel matrix. Dtype is the same as ``(c[0] + r[0]).dtype``.\n\nSee also\n--------\ntoeplitz : Toeplitz matrix\ncirculant : circulant matrix\n\nExamples\n--------\n>>> from scipy.linalg import hankel\n>>> hankel([1, 17, 99])\narray([[ 1, 17, 99],\n       [17, 99,  0],\n       [99,  0,  0]])\n>>> hankel([1,2,3,4], [4,7,7,8,9])\narray([[1, 2, 3, 4, 7],\n       [2, 3, 4, 7, 7],\n       [3, 4, 7, 7, 8],\n       [4, 7, 7, 8, 9]])", "id": "f19328:m5"}
{"signature": "def iter_attribute(iterable_name) -> Union[Iterable, Callable]:", "body": "def create_new_class(decorated_class) -> Union[Iterable, Callable]:<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>assert inspect.isclass(decorated_class), '<STR_LIT>'<EOL>assert isinstance(iterable_name, str), '<STR_LIT>'<EOL>decorated_class.iterator_attr_index = <NUM_LIT:0><EOL>def __iter__(instance) -> Iterable:<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>return instance<EOL><DEDENT>def __next__(instance) -> Any:<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>assert hasattr(instance, iterable_name),'<STR_LIT>'.format(iterable_name)<EOL>assert isinstance(getattr(instance, iterable_name), collections.Iterable),'<STR_LIT>'.format(iterable_name, instance.__class__.__name__)<EOL>ind = instance.iterator_attr_index<EOL>while ind < len(getattr(instance, iterable_name)):<EOL><INDENT>val = getattr(instance, iterable_name)[ind]<EOL>instance.iterator_attr_index += <NUM_LIT:1><EOL>return val<EOL><DEDENT>instance.iterator_attr_index = <NUM_LIT:0><EOL>raise StopIteration<EOL><DEDENT>dct = dict(decorated_class.__dict__)<EOL>dct['<STR_LIT>'] = __iter__<EOL>dct['<STR_LIT>'] = __next__<EOL>dct['<STR_LIT>'] = decorated_class.iterator_attr_index<EOL>return type(decorated_class.__name__, (collections.Iterable,), dct)<EOL><DEDENT>return create_new_class<EOL>", "docstring": "Decorator implementing Iterator interface with nicer manner.\n\n    Example\n    -------\n\n    @iter_attribute('my_attr'):\n    class DecoratedClass:\n        ...\n\n    Warning:\n    ========\n\n    When using PyCharm or MYPY you'll probably see issues with decorated class not being recognized as Iterator.\n    That's an issue which I could not overcome yet, it's probably due to the fact that interpretation of object\n    is being done statically rather than dynamically. MYPY checks for definition of methods in class code which\n    changes at runtime. Since __iter__ and __next__ are added dynamically MYPY cannot find those\n    defined in objects before object of a class is created. Possible workarounds for this issue are:\n\n        1. Define ``dummy`` __iter__ class like:\n\n            @iter_attribute('attr')\n            class Test:\n                def __init__(self) -> None:\n                    self.attr = [1, 2, 3]\n\n                def __iter__(self):\n                    pass\n\n        2. After creating object use cast or assert function denoting that particular instance inherits\n            from collections.Iterator:\n\n            assert isinstance(my_object, collections.Iterator)\n\n\n    :param iterable_name: string representing attribute name which has to be iterated\n    :return: DecoratedClass with implemented '__iter__' and '__next__' methods.", "id": "f1885:m0"}
{"signature": "def next_sibling(self, name=None):", "body": "if name is None:<EOL><INDENT>return XMLElement(lib.lsl_next_sibling(self.e))<EOL><DEDENT>else:<EOL><INDENT>return XMLElement(lib.lsl_next_sibling_n(self.e, str.encode(name)))<EOL><DEDENT>", "docstring": "Get the next sibling in the children list of the parent node.\n\n        If a name is provided, the next sibling with the given name is returned.", "id": "f12888:c3:m4"}
{"signature": "def falcon_app(port):", "body": "from web.apps.falcon_app import FalconApplication<EOL>app = FalconApplication()<EOL>class Home(Handler):<EOL><INDENT>def get(self, req, resp):<EOL><INDENT>resp.body = HELLO_WORLD<EOL><DEDENT><DEDENT>class Landing(Handler):<EOL><INDENT>def get(self, req, resp):<EOL><INDENT>resp.body = LANDING_PAGE<EOL><DEDENT><DEDENT>app.add_route('<STR_LIT:/>', Home())<EOL>app.add_route('<STR_LIT>', Landing())<EOL>app.add_static_route('<STR_LIT>', STATIC_PATH)<EOL>app.start(port=port)<EOL>", "docstring": "With logging\n\n    Running 30s test @ http://127.0.0.1:8888/\n      12 threads and 400 connections\n      Thread Stats   Avg      Stdev     Max   +/- Stdev\n        Latency    62.65ms   10.04ms 189.96ms   87.87%\n        Req/Sec   526.93    159.98     1.00k    64.25%\n      188860 requests in 30.06s, 23.41MB read\n    Requests/sec:   6283.35\n    Transfer/sec:    797.69KB", "id": "f3757:m2"}
{"signature": "def _get_igp_ldp_sync(self):", "body": "return self.__igp_ldp_sync<EOL>", "docstring": "Getter method for igp_ldp_sync, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls/igp_ldp_sync (container)\n\n    YANG Description: Configuration and operational state relating to synchronisation\nbetween the LDP and IS-IS", "id": "f22502:c0:m2"}
{"signature": "def _get_instant(self):", "body": "return self.__instant<EOL>", "docstring": "Getter method for instant, mapped from YANG variable /components/component/transceiver/physical_channels/channel/state/input_power/instant (decimal64)\n\nYANG Description: The instantaneous value of the statistic.", "id": "f22073:c0:m2"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, circuit_name, peering_name, peering_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>circuit_name=circuit_name,<EOL>peering_name=peering_name,<EOL>peering_parameters=peering_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a peering in the specified express route circuits.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param peering_name: The name of the peering.\n        :type peering_name: str\n        :param peering_parameters: Parameters supplied to the create or update\n         express route circuit peering operation.\n        :type peering_parameters:\n         ~azure.mgmt.network.v2017_08_01.models.ExpressRouteCircuitPeering\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         ExpressRouteCircuitPeering or\n         ClientRawResponse<ExpressRouteCircuitPeering> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_08_01.models.ExpressRouteCircuitPeering]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_08_01.models.ExpressRouteCircuitPeering]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33420:c0:m5"}
{"signature": "def tdist95conf_level(df):", "body": "df = int(round(df))<EOL>highest_table_df = len(_T_DIST_95_CONF_LEVELS)<EOL>if df >= <NUM_LIT:200>:<EOL><INDENT>return <NUM_LIT><EOL><DEDENT>if df >= <NUM_LIT:100>:<EOL><INDENT>return <NUM_LIT><EOL><DEDENT>if df >= <NUM_LIT>:<EOL><INDENT>return <NUM_LIT><EOL><DEDENT>if df >= <NUM_LIT>:<EOL><INDENT>return <NUM_LIT><EOL><DEDENT>if df >= <NUM_LIT:50>:<EOL><INDENT>return <NUM_LIT><EOL><DEDENT>if df >= <NUM_LIT>:<EOL><INDENT>return <NUM_LIT><EOL><DEDENT>if df >= highest_table_df:<EOL><INDENT>return _T_DIST_95_CONF_LEVELS[highest_table_df - <NUM_LIT:1>]<EOL><DEDENT>return _T_DIST_95_CONF_LEVELS[df]<EOL>", "docstring": "Approximate the 95% confidence interval for Student's T distribution.\n\n    Given the degrees of freedom, returns an approximation to the 95%\n    confidence interval for the Student's T distribution.\n\n    Args:\n        df: An integer, the number of degrees of freedom.\n\n    Returns:\n        A float.", "id": "f11112:m1"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/segment_routing/config (container)\n\n    YANG Description: Configuration parameters relating to the configuration of segment\nrouting for the IGP instance.", "id": "f22509:c0:m2"}
{"signature": "def _get_ip_version(self):", "body": "return self.__ip_version<EOL>", "docstring": "Getter method for ip_version, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/ip/state/ip_version (inet:ip-version)\n\nYANG Description: IP version of the header.", "id": "f22152:c0:m2"}
{"signature": "def _get_type(self):", "body": "return self.__type<EOL>", "docstring": "Getter method for type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/state/type (identityref)\n\n    YANG Description: The type of TLV being described. The type of TLV is\nexpressed as a canonical name.", "id": "f22547:c0:m2"}
{"signature": "def split_by_3(self, number):", "body": "blocks = ()<EOL>length = len(number)<EOL>if length < <NUM_LIT:3>:<EOL><INDENT>blocks += ((number,),)<EOL><DEDENT>else:<EOL><INDENT>len_of_first_block = length % <NUM_LIT:3><EOL>if len_of_first_block > <NUM_LIT:0>:<EOL><INDENT>first_block = number[<NUM_LIT:0>:len_of_first_block],<EOL>blocks += first_block,<EOL><DEDENT>for i in range(len_of_first_block, length, <NUM_LIT:3>):<EOL><INDENT>next_block = (number[i:i + <NUM_LIT:3>],),<EOL>blocks += next_block<EOL><DEDENT><DEDENT>return blocks<EOL>", "docstring": "starting here, it groups the number by three from the tail\n'1234567' -> (('1',),('234',),('567',))\n:param number:str\n:rtype:tuple", "id": "f1801:c0:m1"}
{"signature": "def _get_cleanup_delay(self):", "body": "return self.__cleanup_delay<EOL>", "docstring": "Getter method for cleanup_delay, mapped from YANG variable /network_instances/network_instance/mpls/te_global_attributes/te_lsp_timers/config/cleanup_delay (uint16)\n\n    YANG Description: delay the removal of old te lsp for a specified\namount of time", "id": "f22190:c1:m5"}
{"signature": "def list_metric_definitions(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list_metric_definitions.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get global metric definitions of an App Service Environment.\n\n        Get global metric definitions of an App Service Environment.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the App Service Environment.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: MetricDefinition or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.web.models.MetricDefinition or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44995:c0:m15"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, local_network_gateway_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>local_network_gateway_name=local_network_gateway_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a local network gateway in the specified resource\n        group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param local_network_gateway_name: The name of the local network\n         gateway.\n        :type local_network_gateway_name: str\n        :param parameters: Parameters supplied to the create or update local\n         network gateway operation.\n        :type parameters:\n         ~azure.mgmt.network.v2018_06_01.models.LocalNetworkGateway\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns LocalNetworkGateway or\n         ClientRawResponse<LocalNetworkGateway> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_06_01.models.LocalNetworkGateway]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_06_01.models.LocalNetworkGateway]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30930:c0:m2"}
{"signature": "def run_profilers(run_object, prof_config, verbose=False):", "body": "if len(prof_config) > len(set(prof_config)):<EOL><INDENT>raise AmbiguousConfigurationError(<EOL>'<STR_LIT>' % prof_config)<EOL><DEDENT>available_profilers = {opt for opt, _ in _PROFILERS}<EOL>for option in prof_config:<EOL><INDENT>if option not in available_profilers:<EOL><INDENT>raise BadOptionError('<STR_LIT>' % option)<EOL><DEDENT><DEDENT>run_stats = OrderedDict()<EOL>present_profilers = ((o, p) for o, p in _PROFILERS if o in prof_config)<EOL>for option, prof in present_profilers:<EOL><INDENT>curr_profiler = prof(run_object)<EOL>if verbose:<EOL><INDENT>print('<STR_LIT>' % curr_profiler.__class__.__name__)<EOL><DEDENT>run_stats[option] = curr_profiler.run()<EOL><DEDENT>return run_stats<EOL>", "docstring": "Runs profilers on run_object.\n\n    Args:\n        run_object: An object (string or tuple) for profiling.\n        prof_config: A string with profilers configuration.\n        verbose: True if info about running profilers should be shown.\n    Returns:\n        An ordered dictionary with collected stats.\n    Raises:\n        AmbiguousConfigurationError: when prof_config is ambiguous.\n        BadOptionError: when unknown options are present in configuration.", "id": "f15321:m0"}
{"signature": "def flush(self):", "body": "self.file.flush()<EOL>self.ostream.flush()<EOL>", "docstring": "Flush both channels.", "id": "f21557:c2:m3"}
{"signature": "def _get_hop_limit(self):", "body": "return self.__hop_limit<EOL>", "docstring": "Getter method for hop_limit, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/ip/state/hop_limit (uint8)\n\n    YANG Description: The IP packet's hop limit -- known as TTL (in hops) in\nIPv4 packets, and hop limit in IPv6", "id": "f22152:c1:m23"}
{"signature": "def inverted(arg):", "body": "inv = getattr(arg, '<STR_LIT>', None)<EOL>if callable(inv):<EOL><INDENT>return inv()<EOL><DEDENT>return ((val, key) for (key, val) in _iteritems_mapping_or_iterable(arg))<EOL>", "docstring": "Yield the inverse items of the provided object.\n\n    If *arg* has a :func:`callable` ``__inverted__`` attribute,\n    return the result of calling it.\n\n    Otherwise, return an iterator over the items in `arg`,\n    inverting each item on the fly.\n\n    *See also* :attr:`bidict.BidirectionalMapping.__inverted__`", "id": "f12424:m2"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration parameters for P2P LSPs", "id": "f22275:c1:m3"}
{"signature": "def _get_prevent_teardown(self):", "body": "return self.__prevent_teardown<EOL>", "docstring": "Getter method for prevent_teardown, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/state/prevent_teardown (boolean)\n\n    YANG Description: Do not tear down the BGP session when the maximum\nprefix limit is exceeded, but rather only log a\nwarning. The default of this leaf is false, such\nthat when it is not specified, the session is torn\ndown.", "id": "f23389:c1:m5"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, network_interface_name, tap_configuration_name, tap_configuration_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_interface_name=network_interface_name,<EOL>tap_configuration_name=tap_configuration_name,<EOL>tap_configuration_parameters=tap_configuration_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a Tap configuration in the specified\n        NetworkInterface.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_interface_name: The name of the network interface.\n        :type network_interface_name: str\n        :param tap_configuration_name: The name of the tap configuration.\n        :type tap_configuration_name: str\n        :param tap_configuration_parameters: Parameters supplied to the create\n         or update tap configuration operation.\n        :type tap_configuration_parameters:\n         ~azure.mgmt.network.v2019_02_01.models.NetworkInterfaceTapConfiguration\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         NetworkInterfaceTapConfiguration or\n         ClientRawResponse<NetworkInterfaceTapConfiguration> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2019_02_01.models.NetworkInterfaceTapConfiguration]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2019_02_01.models.NetworkInterfaceTapConfiguration]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34880:c0:m5"}
{"signature": "def __repr__(self):", "body": "return '<STR_LIT>' % (self.start, self.uid)<EOL>", "docstring": "Return a string representation of an artist object.\n\n        :return: String representation of object.", "id": "f11785:c4:m8"}
{"signature": "def _set_segment_routing_algorithm(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=segment_routing_algorithm.segment_routing_algorithm,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__segment_routing_algorithm = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for segment_routing_algorithm, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/router_capabilities/router_capability/subtlvs/subtlvs/segment_routing_algorithm (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_segment_routing_algorithm is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_segment_routing_algorithm() directly.\n\nYANG Description: This container defines SR algorithm sub-TLV 19.", "id": "f22564:c1:m9"}
{"signature": "def _get_neighbor(self):", "body": "return self.__neighbor<EOL>", "docstring": "Getter method for neighbor, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor (list)\n\n    YANG Description: List of BGP neighbors configured on the local system,\nuniquely identified by peer IPv[46] address", "id": "f23373:c1:m2"}
{"signature": "def _get_prefix(self):", "body": "return self.__prefix<EOL>", "docstring": "Getter method for prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/static_routes/static/config/prefix (inet:ip-prefix)\n\n    YANG Description: Destination prefix for the static route, either IPv4 or\nIPv6.", "id": "f22382:c1:m2"}
{"signature": "def _get_mask(self):", "body": "return self.__mask<EOL>", "docstring": "Getter method for mask, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/as_external_lsa/state/mask (uint8)\n\nYANG Description: The subnet mask for the advertised destination", "id": "f23089:c0:m2"}
{"signature": "def _set_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:type>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv6_reachability/state/type (identityref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_type() directly.\n\n    YANG Description: The type of TLV being described. The type of TLV is\nexpressed as a canonical name.", "id": "f22903:c1:m3"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/fdb/mac_table/entries/entry/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: Operational state data for MAC table entries", "id": "f22105:c1:m9"}
{"signature": "def list(<EOL>self, resource_group_name, route_table_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", route_table_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.RoutePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.RoutePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all routes in a route table.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_table_name: The name of the route table.\n        :type route_table_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Route\n        :rtype:\n         ~azure.mgmt.network.v2018_01_01.models.RoutePaged[~azure.mgmt.network.v2018_01_01.models.Route]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32025:c0:m6"}
{"signature": "def _get_reserved(self):", "body": "return self.__reserved<EOL>", "docstring": "Getter method for reserved, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/bandwidth_constraints/state/reserved (uint32)\n\n    YANG Description: Should be set to zero by the LSR generating the sub-TLV and\nshould be ignored by the LSR receiving the sub-TLV.", "id": "f22606:c1:m8"}
{"signature": "def _get_restart_timer(self):", "body": "return self.__restart_timer<EOL>", "docstring": "Getter method for restart_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/state/restart_timer (decimal64)\n\n    YANG Description: Time interval in seconds after which the BGP session\nis re-established after being torn down due to exceeding\nthe max-prefix limit.", "id": "f23287:c1:m11"}
{"signature": "def delete(self, url, **kwargs):", "body": "return self.request('<STR_LIT>', url, **kwargs)<EOL>", "docstring": "Sends a DELETE request. Returns :class:`Response` object.\n\n        :param url: URL for the new :class:`Request` object.\n        :param \\*\\*kwargs: Optional arguments that ``request`` takes.", "id": "f16999:c1:m11"}
{"signature": "def _get_up_thresholds(self):", "body": "return self.__up_thresholds<EOL>", "docstring": "Getter method for up_thresholds, mapped from YANG variable /network_instances/network_instance/mpls/te_interface_attributes/interface/igp_flooding_bandwidth/config/up_thresholds (oc-types:percentage)\n\n    YANG Description: The thresholds (expressed as a percentage of the maximum\nreservable bandwidth) at which bandwidth updates are to be\ntriggered when the bandwidth is increasing.", "id": "f22214:c1:m11"}
{"signature": "@staticmethod<EOL><INDENT>def calc_fwhm(distribution, is_neg_log=True):<DEDENT>", "body": "if isinstance(distribution, interp1d):<EOL><INDENT>if is_neg_log:<EOL><INDENT>ymin = distribution.y.min()<EOL>log_prob = distribution.y-ymin<EOL><DEDENT>else:<EOL><INDENT>log_prob = -np.log(distribution.y)<EOL>log_prob -= log_prob.min()<EOL><DEDENT>xvals = distribution.x<EOL><DEDENT>elif isinstance(distribution, Distribution):<EOL><INDENT>xvals = distribution._func.x<EOL>log_prob = distribution._func.y<EOL><DEDENT>else:<EOL><INDENT>raise TypeError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\");<EOL><DEDENT>L = xvals.shape[<NUM_LIT:0>]<EOL>tmp = np.where(log_prob < <NUM_LIT>)[<NUM_LIT:0>]<EOL>x_l, x_u = tmp[<NUM_LIT:0>], tmp[-<NUM_LIT:1>]<EOL>if L < <NUM_LIT:2>:<EOL><INDENT>print (\"<STR_LIT>\")<EOL>return min(TINY_NUMBER, distribution.xmax - distribution.xmin)<EOL><DEDENT>else:<EOL><INDENT>return max(TINY_NUMBER, xvals[min(x_u+<NUM_LIT:1>,L-<NUM_LIT:1>)] - xvals[max(<NUM_LIT:0>,x_l-<NUM_LIT:1>)])<EOL><DEDENT>", "docstring": "Assess the width of the probability distribution. This returns\nfull-width-half-max", "id": "f2312:c0:m0"}
{"signature": "def delete(<EOL>self, resource_group_name, route_filter_name, rule_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>route_filter_name=route_filter_name,<EOL>rule_name=rule_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified rule from a route filter.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_filter_name: The name of the route filter.\n        :type route_filter_name: str\n        :param rule_name: The name of the rule.\n        :type rule_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f28641:c0:m2"}
{"signature": "def _get_next_hop(self):", "body": "return self.__next_hop<EOL>", "docstring": "Getter method for next_hop, mapped from YANG variable /network_instances/network_instance/mpls/lsps/static_lsps/static_lsp/transit/config/next_hop (inet:ip-address)\n\nYANG Description: next hop IP address for the LSP", "id": "f22227:c1:m2"}
{"signature": "def visit_functiondef(self, node):", "body": "node_doc = utils.docstringify(node.doc, self.config.default_docstring_type)<EOL>self.check_functiondef_params(node, node_doc)<EOL>self.check_functiondef_returns(node, node_doc)<EOL>self.check_functiondef_yields(node, node_doc)<EOL>", "docstring": "Called for function and method definitions (def).\n\n        :param node: Node for a function or method definition in the AST\n        :type node: :class:`astroid.scoped_nodes.Function`", "id": "f18334:c0:m0"}
{"signature": "def _get(self, url, params=None):", "body": "if not params:<EOL><INDENT>params = {}<EOL><DEDENT>params.update({'<STR_LIT>': self.login, '<STR_LIT:key>': self.key})<EOL>response_json = requests.get(self.api_url + url, params).json()<EOL>return self._process_response(response_json)<EOL>", "docstring": "Used by every other method, it makes a GET request with the given params.\n\n        Args:\n            url (str): relative path of a specific service (account_info, ...).\n            params (:obj:`dict`, optional): contains parameters to be sent in the GET request.\n\n        Returns:\n            dict: results of the response of the GET request.", "id": "f5237:c0:m3"}
{"signature": "def default_image_tag(match, path = None, format = \"<STR_LIT>\"):", "body": "return '<STR_LIT>'<EOL>", "docstring": "Return (X)HTML mark-up for the image-tag given by match.\n\n    This default implementation merely removes the image, and exists mostly\n    for documentation purposes. More information than is present in the Qt\n    HTML is required to supply the images.\n\n    Parameters\n    ----------\n    match : re.SRE_Match\n        A match to an HTML image tag as exported by Qt, with match.group(\"Name\")\n        containing the matched image ID.\n\n    path : string|None, optional [default None]\n        If not None, specifies a path to which supporting files may be written\n        (e.g., for linked images).  If None, all images are to be included\n        inline.\n\n    format : \"png\"|\"svg\", optional [default \"png\"]\n        Format for returned or referenced images.", "id": "f21660:m2"}
{"signature": "@abc.abstractmethod<EOL><INDENT>def save(self):<DEDENT>", "body": "", "docstring": "Called only once per request.\n\nShould implement a mechanism for setting the the session\n**cookie** and saving the session **data** to storage.", "id": "f5362:c0:m0"}
{"signature": "def flatten_mapping(mapping):", "body": "return {<EOL>key: value<EOL>for keys, value in mapping.items()<EOL>for key in always_iterable(keys)<EOL>}<EOL>", "docstring": "For every key that has an __iter__ method, assign the values\nto a key for each.\n\n>>> flatten_mapping({'ab': 3, ('c','d'): 4}) == {'ab': 3, 'c': 4, 'd': 4}\nTrue", "id": "f2365:m1"}
{"signature": "def get(<EOL>self, app_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", app_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the application info.\n\n        :param app_id: The application ID.\n        :type app_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ApplicationInfoResponse or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.cognitiveservices.language.luis.authoring.models.ApplicationInfoResponse\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException>`", "id": "f43230:c0:m9"}
{"signature": "@property<EOL><INDENT>def parameters(self):<DEDENT>", "body": "return self._parameters<EOL>", "docstring": "Return `dict` of ``__init__`` arguments and their values.", "id": "f15524:c0:m7"}
{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list.metadata['<STR_LIT:url>']<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all of the available Data Lake Analytics REST API operations.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: OperationListResult or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.datalake.analytics.account.models.OperationListResult or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44192:c0:m1"}
{"signature": "def Bin(self):", "body": "err = _Bin(self.transit, self.limbdark, self.settings, self.arrays)<EOL>if err != _ERR_NONE: RaiseError(err)<EOL>", "docstring": "Bins the light curve model to the provided time array", "id": "f6024:c4:m4"}
{"signature": "def open_store(self):", "body": "service = self._traj.v_storage_service<EOL>if service.is_open:<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>service.store(pypetconstants.OPEN_FILE, None,<EOL>trajectory_name=self._traj.v_name)<EOL>", "docstring": "Opens store manually not needed if used with `with`", "id": "f4215:c0:m4"}
{"signature": "def rotate(self):", "body": "if self._prev_yank:<EOL><INDENT>text = self._ring.rotate()<EOL>if text:<EOL><INDENT>self._skip_cursor = True<EOL>cursor = self._text_edit.textCursor()<EOL>cursor.movePosition(QtGui.QTextCursor.Left,<EOL>QtGui.QTextCursor.KeepAnchor,<EOL>n = len(self._prev_yank))<EOL>cursor.insertText(text)<EOL>self._prev_yank = text<EOL><DEDENT><DEDENT>", "docstring": "Rotate the kill ring, then yank back the new top.", "id": "f21638:c1:m5"}
{"signature": "def _set_aggregation(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=aggregation.aggregation,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__aggregation = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for aggregation, mapped from YANG variable /interfaces/interface/aggregation (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_aggregation is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_aggregation() directly.\n\n    YANG Description: Options for logical interfaces representing\naggregates", "id": "f22057:c0:m21"}
{"signature": "def reimage_all(<EOL>self, resource_group_name, vm_scale_set_name, instance_id, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._reimage_all_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_scale_set_name=vm_scale_set_name,<EOL>instance_id=instance_id,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Allows you to re-image all the disks ( including data disks ) in the a\n        VM scale set instance. This operation is only supported for managed\n        disks.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_scale_set_name: The name of the VM scale set.\n        :type vm_scale_set_name: str\n        :param instance_id: The instance ID of the virtual machine.\n        :type instance_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24905:c0:m4"}
{"signature": "def send(msg_type, send_async=False, *args, **kwargs):", "body": "message = message_factory(msg_type, *args, **kwargs)<EOL>try:<EOL><INDENT>if send_async:<EOL><INDENT>message.send_async()<EOL><DEDENT>else:<EOL><INDENT>message.send()<EOL><DEDENT><DEDENT>except MessageSendError as e:<EOL><INDENT>err_exit(\"<STR_LIT>\", e)<EOL><DEDENT>", "docstring": "Constructs a message class and sends the message.\nDefaults to sending synchronously.  Set send_async=True to send\nasynchronously.\n\nArgs:\n    :msg_type: (str) the type of message to send, i.e. 'Email'\n    :send_async: (bool) default is False, set True to send asynchronously.\n    :kwargs: (dict) keywords arguments that are required for the\n        various message types.  See docstrings for each type.\n        i.e. help(messages.Email), help(messages.Twilio), etc.\n\nExample:\n    >>> kwargs = {\n              from_: 'me@here.com',\n              to: 'you@there.com',\n              auth: 'yourPassword',\n              subject: 'Email Subject',\n              body: 'Your message to send',\n              attachments: ['filepath1', 'filepath2'],\n        }\n    >>> messages.send('email', **kwargs)\n    Message sent...", "id": "f6685:m0"}
{"signature": "def list(self, **kwargs):", "body": "path = self._get_path('<STR_LIT:list>')<EOL>response = self._GET(path, kwargs)<EOL>self._set_attrs_to_values(response)<EOL>return response<EOL>", "docstring": "Get the list of supported timezones for the API methods that support\nthem.\n\nReturns:\n    A dict respresentation of the JSON returned from the API.", "id": "f279:c2:m0"}
{"signature": "def _get_maximum_delay(self):", "body": "return self.__maximum_delay<EOL>", "docstring": "Getter method for maximum_delay, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/global/timers/spf/state/maximum_delay (uint32)\n\n    YANG Description: The value of this leaf specifies the maximum delay between\na topology change being detected and the SPF algorithm\nrunning. This value is used for implementations that support\nincreasing the wait time between SPF runs.", "id": "f23137:c1:m5"}
{"signature": "def _check_failure(population_values):", "body": "return tf.math.reduce_all(input_tensor=tf.math.is_inf(population_values))<EOL>", "docstring": "Checks if all the population values are NaN/infinite.", "id": "f15549:m3"}
{"signature": "def variant_export_lines(store, case_obj, variants_query):", "body": "export_variants = []<EOL>for variant in variants_query:<EOL><INDENT>variant_line = []<EOL>position = variant['<STR_LIT>']<EOL>change = variant['<STR_LIT>']+'<STR_LIT:>>'+variant['<STR_LIT>']<EOL>variant_line.append(variant['<STR_LIT>'])<EOL>variant_line.append(variant['<STR_LIT>'])<EOL>variant_line.append(position)<EOL>variant_line.append(change)<EOL>variant_line.append('<STR_LIT:_>'.join([str(position), change]))<EOL>gene_list = variant.get('<STR_LIT>') <EOL>gene_ids = []<EOL>gene_names = []<EOL>hgvs_c = []<EOL>if len(gene_list) > <NUM_LIT:0>:<EOL><INDENT>for gene_obj in gene_list:<EOL><INDENT>hgnc_id = gene_obj['<STR_LIT>']<EOL>gene_name = gene(store, hgnc_id)['<STR_LIT>']<EOL>gene_ids.append(hgnc_id)<EOL>gene_names.append(gene_name)<EOL>hgvs_nucleotide = '<STR_LIT:->'<EOL>transcripts_list = gene_obj.get('<STR_LIT>')<EOL>for transcript_obj in transcripts_list:<EOL><INDENT>if transcript_obj.get('<STR_LIT>') and transcript_obj.get('<STR_LIT>') is True:<EOL><INDENT>hgvs_nucleotide = str(transcript_obj.get('<STR_LIT>'))<EOL><DEDENT><DEDENT>hgvs_c.append(hgvs_nucleotide)<EOL><DEDENT>variant_line.append('<STR_LIT:;>'.join( str(x) for x in  gene_ids))<EOL>variant_line.append('<STR_LIT:;>'.join( str(x) for x in  gene_names))<EOL>variant_line.append('<STR_LIT:;>'.join( str(x) for x in  hgvs_c))<EOL><DEDENT>else:<EOL><INDENT>while i < <NUM_LIT:4>:<EOL><INDENT>variant_line.append('<STR_LIT:->') <EOL>i = i+<NUM_LIT:1><EOL><DEDENT><DEDENT>variant_gts = variant['<STR_LIT>'] <EOL>for individual in case_obj['<STR_LIT>']:<EOL><INDENT>for variant_gt in variant_gts:<EOL><INDENT>if individual['<STR_LIT>'] == variant_gt['<STR_LIT>']:<EOL><INDENT>variant_line.append(variant_gt['<STR_LIT>'][<NUM_LIT:0>]) <EOL>variant_line.append(variant_gt['<STR_LIT>'][<NUM_LIT:1>]) <EOL>variant_line.append(variant_gt['<STR_LIT>'])<EOL><DEDENT><DEDENT><DEDENT>variant_line = [str(i) for i in variant_line]<EOL>export_variants.append(\"<STR_LIT:U+002C>\".join(variant_line))<EOL><DEDENT>return export_variants<EOL>", "docstring": "Get variants info to be exported to file, one list (line) per variant.\n\n        Args:\n            store(scout.adapter.MongoAdapter)\n            case_obj(scout.models.Case)\n            variants_query: a list of variant objects, each one is a dictionary\n\n        Returns:\n            export_variants: a list of strings. Each string  of the list corresponding to the fields\n                             of a variant to be exported to file, separated by comma", "id": "f13696:m6"}
{"signature": "@_log<EOL><INDENT>def gradient_plots(self, analytes=None, win=<NUM_LIT:15>, samples=None, ranges=False,<EOL>focus=None, outdir=None,<EOL>figsize=[<NUM_LIT:10>, <NUM_LIT:4>], subset='<STR_LIT>'):<DEDENT>", "body": "if focus is None:<EOL><INDENT>focus = self.focus_stage<EOL><DEDENT>if outdir is None:<EOL><INDENT>outdir = self.report_dir + '<STR_LIT:/>' + focus + '<STR_LIT>'<EOL><DEDENT>if not os.path.isdir(outdir):<EOL><INDENT>os.mkdir(outdir)<EOL><DEDENT>if subset is not None:<EOL><INDENT>samples = self._get_samples(subset)<EOL><DEDENT>elif samples is None:<EOL><INDENT>samples = self.subsets['<STR_LIT>']<EOL><DEDENT>elif isinstance(samples, str):<EOL><INDENT>samples = [samples]<EOL><DEDENT>with self.pbar.set(total=len(samples), desc='<STR_LIT>') as prog:<EOL><INDENT>for s in samples:<EOL><INDENT>f, a = self.data[s].gplot(analytes=analytes, win=win, figsize=figsize,<EOL>ranges=ranges, focus_stage=focus)<EOL>f.savefig(outdir + '<STR_LIT:/>' + s + '<STR_LIT>')<EOL>plt.close(f)<EOL>prog.update()<EOL><DEDENT><DEDENT>return<EOL>", "docstring": "Plot analyte gradients as a function of time.\n\nParameters\n----------\nanalytes : optional, array_like or str\n    The analyte(s) to plot. Defaults to all analytes.\nsamples: optional, array_like or str\n    The sample(s) to plot. Defaults to all samples.\nranges : bool\n    Whether or not to show the signal/backgroudn regions\n    identified by 'autorange'.\nfocus : str\n    The focus 'stage' of the analysis to plot. Can be\n    'rawdata', 'despiked':, 'signal', 'background',\n    'bkgsub', 'ratios' or 'calibrated'.\noutdir : str\n    Path to a directory where you'd like the plots to be\n    saved. Defaults to 'reports/[focus]' in your data directory.\nfilt : str, dict or bool\n    Either logical filter expression contained in a str,\n    a dict of expressions specifying the filter string to\n    use for each analyte or a boolean. Passed to `grab_filt`.\nscale : str\n    If 'log', plots the data on a log scale.\nfigsize : array_like\n    Array of length 2 specifying figure [width, height] in\n    inches.\nstats : bool\n    Whether or not to overlay the mean and standard deviations\n    for each trace.\nstat, err: str\n    The names of the statistic and error components to plot.\n    Deafaults to 'nanmean' and 'nanstd'.\n\n\nReturns\n-------\nNone", "id": "f2444:c0:m51"}
{"signature": "@properties.ClassProperty<EOL><INDENT>@classmethod<EOL>def priority(self):<DEDENT>", "body": "try:<EOL><INDENT>__import__('<STR_LIT>')<EOL><DEDENT>except ImportError:     <EOL><INDENT>raise RuntimeError(\"<STR_LIT>\")<EOL><DEDENT>try:<EOL><INDENT>__import__('<STR_LIT>')<EOL><DEDENT>except ImportError:     <EOL><INDENT>raise RuntimeError(\"<STR_LIT>\")<EOL><DEDENT>if not json:            <EOL><INDENT>raise RuntimeError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>return <NUM_LIT><EOL>", "docstring": "Applicable for all platforms, where the schemes, that are integrated\nwith your environment, does not fit.", "id": "f386:c1:m0"}
{"signature": "@abc.abstractmethod<EOL><INDENT>def version(self):<DEDENT>", "body": "", "docstring": "\u7248\u672c\u4fe1\u606f\n\n:return: \u8fd4\u56de\u5305\u540d\uff0c\u7248\u672c\u53f7\u5143\u7ec4\n:rtype: (str, str)", "id": "f2928:c0:m1"}
{"signature": "def find_version(filename):", "body": "with io.open(filename, encoding=\"<STR_LIT:utf-8>\") as version_file:<EOL><INDENT>version_match = re.search(r'<STR_LIT>',<EOL>version_file.read(), re.M)<EOL><DEDENT>if version_match:<EOL><INDENT>return version_match.group(<NUM_LIT:1>)<EOL><DEDENT>return \"<STR_LIT>\"<EOL>", "docstring": "Uses re to pull out the assigned value to __version__ in filename.", "id": "f11920:m0"}
{"signature": "def ignore_blanks(self) -> bool:", "body": "self._stream.save_context()<EOL>if not self.read_eof() and self._stream.peek_char in \"<STR_LIT>\":<EOL><INDENT>while (not self.read_eof()<EOL>and self._stream.peek_char in \"<STR_LIT>\"):<EOL><INDENT>self._stream.incpos()<EOL><DEDENT>return self._stream.validate_context()<EOL><DEDENT>return self._stream.validate_context()<EOL>", "docstring": "Consume whitespace characters.", "id": "f4936:c1:m28"}
{"signature": "def _set_static_lsp(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT:name>\",<EOL>static_lsp.static_lsp,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT:name>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__static_lsp = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for static_lsp, mapped from YANG variable /network_instances/network_instance/mpls/lsps/static_lsps/static_lsp (list)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_static_lsp is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_static_lsp() directly.\n\nYANG Description: list of defined static LSPs", "id": "f22229:c1:m3"}
{"signature": "def get_private_key(platform, service, purpose, key_use, version, private_key, keys_folder):", "body": "private_key_data = get_file_contents(keys_folder, private_key)<EOL>private_key = load_pem_private_key(private_key_data.encode(), None, backend=backend)<EOL>pub_key = private_key.public_key()<EOL>pub_bytes = pub_key.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo)<EOL>kid = _generate_kid_from_key(pub_bytes.decode())<EOL>key = _create_key(platform=platform, service=service, key_use=key_use,<EOL>key_type=\"<STR_LIT>\", purpose=purpose, version=version,<EOL>public_key=pub_bytes.decode(), private_key=private_key_data)<EOL>return kid, key<EOL>", "docstring": "Loads a private key from the file system and adds it to a dict of keys\n:param keys: A dict of keys\n:param platform the platform the key is for\n:param service the service the key is for\n:param key_use what the key is used for\n:param version the version of the key\n:param purpose: The purpose of the private key\n:param private_key: The name of the private key to add\n:param keys_folder: The location on disk where the key exists\n:param kid_override: This allows the caller to override the generated KID value\n:return: None", "id": "f5591:m5"}
{"signature": "def exists(self, path):", "body": "<EOL>if sys.version_info[<NUM_LIT:0>] >= <NUM_LIT:3>:<EOL><INDENT>from urllib.request import urlopen<EOL>from urllib.error import URLError<EOL><DEDENT>else:<EOL><INDENT>from urllib2 import urlopen<EOL>from urllib2 import URLError<EOL><DEDENT>if os.path.exists(path):<EOL><INDENT>return True<EOL><DEDENT>upath = self.abspath(path)<EOL>if os.path.exists(upath):<EOL><INDENT>return True<EOL><DEDENT>if self._isurl(path):<EOL><INDENT>try:<EOL><INDENT>netfile = urlopen(path)<EOL>netfile.close()<EOL>del(netfile)<EOL>return True<EOL><DEDENT>except URLError:<EOL><INDENT>return False<EOL><DEDENT><DEDENT>return False<EOL>", "docstring": "Test if path exists.\n\nTest if `path` exists as (and in this order):\n\n- a local file.\n- a remote URL that has been downloaded and stored locally in the\n  `DataSource` directory.\n- a remote URL that has not been downloaded, but is valid and\n  accessible.\n\nParameters\n----------\npath : str\n    Can be a local file or a remote URL.\n\nReturns\n-------\nout : bool\n    True if `path` exists.\n\nNotes\n-----\nWhen `path` is an URL, `exists` will return True if it's either\nstored locally in the `DataSource` directory, or is a valid remote\nURL.  `DataSource` does not discriminate between the two, the file\nis accessible if it exists in either location.", "id": "f19087:c1:m11"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkWatcherPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkWatcherPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all network watchers by resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkWatcher\n        :rtype:\n         ~azure.mgmt.network.v2017_03_01.models.NetworkWatcherPaged[~azure.mgmt.network.v2017_03_01.models.NetworkWatcher]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31210:c0:m5"}
{"signature": "def unblock(self):", "body": "return self._rdd.flatMap(lambda x: list(x))<EOL>", "docstring": "Flattens the blocks. Returns as list.", "id": "f16797:c0:m10"}
{"signature": "def _get_value(self):", "body": "return self.__value<EOL>", "docstring": "Getter method for value, mapped from YANG variable /network_instances/network_instance/mpls/te_global_attributes/srlgs/srlg/config/value (uint32)\n\nYANG Description: group ID for the SRLG", "id": "f22181:c1:m5"}
{"signature": "def delete(<EOL>self, resource_group_name, express_route_gateway_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>express_route_gateway_name=express_route_gateway_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified ExpressRoute gateway in a resource group. An\n        ExpressRoute gateway resource can only be deleted when there are no\n        connection subresources.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param express_route_gateway_name: The name of the ExpressRoute\n         gateway.\n        :type express_route_gateway_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30271:c0:m7"}
{"signature": "def __init__(self,<EOL>total_count,<EOL>logits=None,<EOL>probs=None,<EOL>validate_args=False,<EOL>allow_nan_stats=True,<EOL>name=\"<STR_LIT>\"):", "body": "parameters = dict(locals())<EOL>with tf.name_scope(name) as name:<EOL><INDENT>dtype = dtype_util.common_dtype([total_count, logits, probs], tf.float32)<EOL>self._total_count = tf.convert_to_tensor(<EOL>value=total_count, name=\"<STR_LIT>\", dtype=dtype)<EOL>if validate_args:<EOL><INDENT>self._total_count = (<EOL>distribution_util.embed_check_nonnegative_integer_form(<EOL>self._total_count))<EOL><DEDENT>self._logits, self._probs = distribution_util.get_logits_and_probs(<EOL>logits=logits,<EOL>probs=probs,<EOL>multidimensional=True,<EOL>validate_args=validate_args,<EOL>name=name,<EOL>dtype=dtype)<EOL>self._mean_val = self._total_count[..., tf.newaxis] * self._probs<EOL><DEDENT>super(Multinomial, self).__init__(<EOL>dtype=dtype,<EOL>reparameterization_type=reparameterization.NOT_REPARAMETERIZED,<EOL>validate_args=validate_args,<EOL>allow_nan_stats=allow_nan_stats,<EOL>parameters=parameters,<EOL>graph_parents=[self._total_count, self._logits, self._probs],<EOL>name=name)<EOL>", "docstring": "Initialize a batch of Multinomial distributions.\n\n        Args:\n          total_count: Non-negative floating point tensor with shape broadcastable\n            to `[N1,..., Nm]` with `m >= 0`. Defines this as a batch of\n            `N1 x ... x Nm` different Multinomial distributions. Its components\n            should be equal to integer values.\n          logits: Floating point tensor representing unnormalized log-probabilities\n            of a positive event with shape broadcastable to\n            `[N1,..., Nm, K]` `m >= 0`, and the same dtype as `total_count`. Defines\n            this as a batch of `N1 x ... x Nm` different `K` class Multinomial\n            distributions. Only one of `logits` or `probs` should be passed in.\n          probs: Positive floating point tensor with shape broadcastable to\n            `[N1,..., Nm, K]` `m >= 0` and same dtype as `total_count`. Defines\n            this as a batch of `N1 x ... x Nm` different `K` class Multinomial\n            distributions. `probs`'s components in the last portion of its shape\n            should sum to `1`. Only one of `logits` or `probs` should be passed in.\n          validate_args: Python `bool`, default `False`. When `True` distribution\n            parameters are checked for validity despite possibly degrading runtime\n            performance. When `False` invalid inputs may silently render incorrect\n            outputs.\n          allow_nan_stats: Python `bool`, default `True`. When `True`, statistics\n            (e.g., mean, mode, variance) use the value \"`NaN`\" to indicate the\n            result is undefined. When `False`, an exception is raised if one or\n            more of the statistic's batch members are undefined.\n          name: Python `str` name prefixed to Ops created by this class.", "id": "f15675:c0:m0"}
{"signature": "def _get_is_type(self):", "body": "return self.__is_type<EOL>", "docstring": "Getter method for is_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/type_block/state/is_type (oc-isis-types:level-number)\n\nYANG Description: Type of neighboring system.", "id": "f22895:c1:m5"}
{"signature": "def update_case(self, case_obj):", "body": "<EOL>LOG.info(\"<STR_LIT>\".format(case_obj['<STR_LIT>']))<EOL>old_case = self.case_collection.find_one(<EOL>{'<STR_LIT>': case_obj['<STR_LIT>']}<EOL>)<EOL>updated_case = self.case_collection.find_one_and_update(<EOL>{'<STR_LIT>': case_obj['<STR_LIT>']},<EOL>{<EOL>'<STR_LIT>': {<EOL>'<STR_LIT>': {'<STR_LIT>': case_obj['<STR_LIT>']},<EOL>'<STR_LIT>': {<EOL>'<STR_LIT:date>': old_case['<STR_LIT>'],<EOL>'<STR_LIT>': old_case.get('<STR_LIT>')<EOL>}<EOL>},<EOL>'<STR_LIT>': {<EOL>'<STR_LIT>': case_obj['<STR_LIT>'],<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj['<STR_LIT>'],<EOL>'<STR_LIT>': datetime.datetime.now(),<EOL>'<STR_LIT>': False,<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>', []),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>', '<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>', False),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>', False),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>'<STR_LIT>': case_obj.get('<STR_LIT>'),<EOL>}<EOL>},<EOL>return_document=pymongo.ReturnDocument.AFTER<EOL>)<EOL>LOG.info(\"<STR_LIT>\")<EOL>return updated_case<EOL>", "docstring": "Update a case in the database\n\n        The following will be updated:\n            - collaborators: If new collaborators these will be added to the old ones\n            - analysis_date: Is updated to the new date\n            - analyses: The new analysis date will be added to old runs\n            - individuals: There could be new individuals\n            - updated_at: When the case was updated in the database\n            - rerun_requested: Is set to False since that is probably what happened\n            - panels: The new gene panels are added\n            - genome_build: If there is a new genome build\n            - genome_version: - || -\n            - rank_model_version: If there is a new rank model\n            - madeline_info: If there is a new pedigree\n            - vcf_files: paths to the new files\n            - has_svvariants: If there are new svvariants\n            - has_strvariants: If there are new strvariants\n            - multiqc: If there's an updated multiqc report location\n            - mme_submission: If case was submitted to MatchMaker Exchange\n\n            Args:\n                case_obj(dict): The new case information\n\n            Returns:\n                updated_case(dict): The updated case information", "id": "f13782:c0:m8"}
{"signature": "def get(<EOL>self, resource_group_name, load_balancer_name, inbound_nat_rule_name, expand=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", load_balancer_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", inbound_nat_rule_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if expand is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", expand, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified load balancer inbound nat rule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param load_balancer_name: The name of the load balancer.\n        :type load_balancer_name: str\n        :param inbound_nat_rule_name: The name of the inbound nat rule.\n        :type inbound_nat_rule_name: str\n        :param expand: Expands referenced resources.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: InboundNatRule or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_07_01.models.InboundNatRule or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34210:c0:m4"}
{"signature": "def _set_set_tag(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=[<EOL>RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>),<EOL>],<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__set_tag = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for set_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/local_aggregates/aggregate/state/set_tag (oc-pt:tag-type)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_set_tag is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_set_tag() directly.\n\n    YANG Description: Set a generic tag value on the route. This tag can be\nused for filtering routes that are distributed to other\nrouting protocols.", "id": "f22377:c1:m9"}
{"signature": "def _set_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=int, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}, int_size=<NUM_LIT:8><EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:type>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/undefined_subtlvs/undefined_subtlv/state/type (uint8)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_type is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_type() directly.\n\nYANG Description: TLV Type.", "id": "f22630:c0:m3"}
{"signature": "def _get_p2p_primary_path(self):", "body": "return self.__p2p_primary_path<EOL>", "docstring": "Getter method for p2p_primary_path, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_primary_path/p2p_primary_path (list)\n\nYANG Description: List of p2p primary paths for a tunnel", "id": "f22273:c0:m2"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/nsr/config (container)\n\nYANG Description: This container defines Non-Stop-Routing configuration.", "id": "f22473:c0:m2"}
{"signature": "def build_hpo_term(hpo_info):", "body": "try:<EOL><INDENT>hpo_id = hpo_info['<STR_LIT>']<EOL><DEDENT>except KeyError:<EOL><INDENT>raise KeyError(\"<STR_LIT>\")<EOL><DEDENT>LOG.debug(\"<STR_LIT>\", hpo_id)<EOL>try:<EOL><INDENT>description = hpo_info['<STR_LIT:description>']<EOL><DEDENT>except KeyError:<EOL><INDENT>raise KeyError(\"<STR_LIT>\")<EOL><DEDENT>hpo_obj = HpoTerm(<EOL>hpo_id = hpo_id,<EOL>description = description<EOL>)<EOL>hgnc_ids = hpo_info.get('<STR_LIT>', set())<EOL>if hgnc_ids:<EOL><INDENT>hpo_obj['<STR_LIT>'] = list(hgnc_ids)<EOL><DEDENT>return hpo_obj<EOL>", "docstring": "Build a hpo_term object\n\n    Check that the information is correct and add the correct hgnc ids to the \n    array of genes.\n\n        Args:\n            hpo_info(dict)\n\n        Returns:\n            hpo_obj(scout.models.HpoTerm): A dictionary with hpo information", "id": "f13638:m0"}
{"signature": "def get_cluster_manifest(<EOL>self, timeout=<NUM_LIT>, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>url = self.get_cluster_manifest.metadata['<STR_LIT:url>']<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>if timeout is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", timeout, '<STR_LIT>', maximum=<NUM_LIT>, minimum=<NUM_LIT:1>)<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.FabricErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get the Service Fabric cluster manifest.\n\n        Get the Service Fabric cluster manifest. The cluster manifest contains\n        properties of the cluster that include different node types on the\n        cluster,\n        security configurations, fault, and upgrade domain topologies, etc.\n        These properties are specified as part of the ClusterConfig.JSON file\n        while deploying a stand-alone cluster. However, most of the information\n        in the cluster manifest\n        is generated internally by service fabric during cluster deployment in\n        other deployment scenarios (e.g. when using Azure portal).\n        The contents of the cluster manifest are for informational purposes\n        only and users are not expected to take a dependency on the format of\n        the file contents or its interpretation.\n\n        :param timeout: The server timeout for performing the operation in\n         seconds. This timeout specifies the time duration that the client is\n         willing to wait for the requested operation to complete. The default\n         value for this parameter is 60 seconds.\n        :type timeout: long\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ClusterManifest or ClientRawResponse if raw=true\n        :rtype: ~azure.servicefabric.models.ClusterManifest or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`FabricErrorException<azure.servicefabric.models.FabricErrorException>`", "id": "f27460:c1:m1"}
{"signature": "def _get_dup_addr_detect_transmits(self):", "body": "return self.__dup_addr_detect_transmits<EOL>", "docstring": "Getter method for dup_addr_detect_transmits, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/config/dup_addr_detect_transmits (uint32)\n\n    YANG Description: [adapted from IETF IP model RFC 7277]\n\nThe number of consecutive Neighbor Solicitation messages\nsent while performing Duplicate Address Detection on a\ntentative address.  A value of zero indicates that\nDuplicate Address Detection is not performed on\ntentative addresses.  A value of one indicates a single\ntransmission with no follow-up retransmissions.", "id": "f21977:c0:m8"}
{"signature": "def start(self, n):", "body": "return super(WindowsHPCEngineSetLauncher, self).start(n)<EOL>", "docstring": "Start the controller by profile_dir.", "id": "f21671:c26:m2"}
{"signature": "def gen_new_seed(seed, salt):", "body": "if seed is None:<EOL><INDENT>return None<EOL><DEDENT>string = (str(seed) + salt).encode(\"<STR_LIT:utf-8>\")<EOL>return int(hashlib.md5(string).hexdigest()[:<NUM_LIT:8>], <NUM_LIT:16>) & <NUM_LIT><EOL>", "docstring": "Generate a new seed, from the given seed and salt.", "id": "f15574:m34"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, application_gateway_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>application_gateway_name=application_gateway_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates the specified application gateway.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param application_gateway_name: The name of the application gateway.\n        :type application_gateway_name: str\n        :param parameters: Parameters supplied to the create or update\n         application gateway operation.\n        :type parameters:\n         ~azure.mgmt.network.v2017_09_01.models.ApplicationGateway\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns ApplicationGateway or\n         ClientRawResponse<ApplicationGateway> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_09_01.models.ApplicationGateway]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_09_01.models.ApplicationGateway]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29796:c0:m5"}
{"signature": "def get(<EOL>self, resource_group_name, managed_instance_name, restorable_dropped_database_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", managed_instance_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", restorable_dropped_database_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.policy_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a dropped database's short term retention policy.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param managed_instance_name: The name of the managed instance.\n        :type managed_instance_name: str\n        :param restorable_dropped_database_id:\n        :type restorable_dropped_database_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ManagedBackupShortTermRetentionPolicy or ClientRawResponse if\n         raw=true\n        :rtype: ~azure.mgmt.sql.models.ManagedBackupShortTermRetentionPolicy\n         or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38373:c0:m1"}
{"signature": "def bot(self, id):", "body": "json = self.skype.conn(\"<STR_LIT:GET>\", \"<STR_LIT>\".format(SkypeConnection.API_BOT), params={\"<STR_LIT>\": id},<EOL>auth=SkypeConnection.Auth.SkypeToken).json().get(\"<STR_LIT>\", [])<EOL>return self.merge(SkypeBotUser.fromRaw(self.skype, json[<NUM_LIT:0>])) if json else None<EOL>", "docstring": "Retrieve a single bot.\n\nArgs:\n    id (str): UUID or username of the bot\n\nReturns:\n    SkypeBotUser: resulting bot user object", "id": "f11798:c3:m8"}
{"signature": "def copy(self):", "body": "new_cj = RequestsCookieJar()<EOL>new_cj.update(self)<EOL>return new_cj<EOL>", "docstring": "Return a copy of this RequestsCookieJar.", "id": "f16925:c3:m21"}
{"signature": "def save_iopub_message(self, topics, msg):", "body": "<EOL>try:<EOL><INDENT>msg = self.session.unserialize(msg, content=True)<EOL><DEDENT>except Exception:<EOL><INDENT>self.log.error(\"<STR_LIT>\", exc_info=True)<EOL>return<EOL><DEDENT>parent = msg['<STR_LIT>']<EOL>if not parent:<EOL><INDENT>self.log.warn(\"<STR_LIT>\", msg)<EOL>return<EOL><DEDENT>msg_id = parent['<STR_LIT>']<EOL>msg_type = msg['<STR_LIT>']['<STR_LIT>']<EOL>content = msg['<STR_LIT:content>']<EOL>try:<EOL><INDENT>rec = self.db.get_record(msg_id)<EOL><DEDENT>except KeyError:<EOL><INDENT>rec = empty_record()<EOL>rec['<STR_LIT>'] = msg_id<EOL>self.db.add_record(msg_id, rec)<EOL><DEDENT>d = {}<EOL>if msg_type == '<STR_LIT>':<EOL><INDENT>name = content['<STR_LIT:name>']<EOL>s = rec[name] or '<STR_LIT>'<EOL>d[name] = s + content['<STR_LIT:data>']<EOL><DEDENT>elif msg_type == '<STR_LIT>':<EOL><INDENT>d['<STR_LIT>'] = content<EOL><DEDENT>elif msg_type == '<STR_LIT>':<EOL><INDENT>d['<STR_LIT>'] = content['<STR_LIT:code>']<EOL><DEDENT>elif msg_type in ('<STR_LIT>', '<STR_LIT>'):<EOL><INDENT>d[msg_type] = content<EOL><DEDENT>elif msg_type == '<STR_LIT:status>':<EOL><INDENT>pass<EOL><DEDENT>else:<EOL><INDENT>self.log.warn(\"<STR_LIT>\", msg_type)<EOL><DEDENT>if not d:<EOL><INDENT>return<EOL><DEDENT>try:<EOL><INDENT>self.db.update_record(msg_id, d)<EOL><DEDENT>except Exception:<EOL><INDENT>self.log.error(\"<STR_LIT>\", msg_id, exc_info=True)<EOL><DEDENT>", "docstring": "save an iopub message into the db", "id": "f21689:c2:m14"}
{"signature": "def _set_description(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:description>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:string>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:string>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__description = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for description, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/state/description (string)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_description is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_description() directly.\n\n    YANG Description: An optional textual description (intended primarily for use\nwith a peer or group", "id": "f23273:c0:m33"}
{"signature": "def __init__(self, host, port, timeout=<NUM_LIT:20>, debug=False, logger=None):", "body": "self.host = host<EOL>self.port = port<EOL>self.timeout = timeout<EOL>self._client = None<EOL>self.connected = False<EOL>self._buffer = bytearray()<EOL>self._id = None<EOL>self.logger = guac_logger<EOL>if logger:<EOL><INDENT>self.logger = logger<EOL><DEDENT>if debug:<EOL><INDENT>self.logger.setLevel(logging.DEBUG)<EOL><DEDENT>", "docstring": "Guacamole Client class. This class can handle communication with guacd\nserver.\n\n:param host: guacd server host.\n\n:param port: guacd server port.\n\n:param timeout: socket connection timeout.\n\n:param debug: if True, default logger will switch to Debug level.", "id": "f11733:c0:m0"}
{"signature": "def purge():", "body": "_cache.clear()<EOL>_cache_repl.clear()<EOL>", "docstring": "Clear the regular expression cache", "id": "f17322:m7"}
{"signature": "def get_conn(self):", "body": "<EOL>effective_user = self.proxy_user<EOL>autoconfig = self.autoconfig<EOL>use_sasl = configuration.conf.get('<STR_LIT>', '<STR_LIT>') == '<STR_LIT>'<EOL>try:<EOL><INDENT>connections = self.get_connections(self.hdfs_conn_id)<EOL>if not effective_user:<EOL><INDENT>effective_user = connections[<NUM_LIT:0>].login<EOL><DEDENT>if not autoconfig:<EOL><INDENT>autoconfig = connections[<NUM_LIT:0>].extra_dejson.get('<STR_LIT>',<EOL>False)<EOL><DEDENT>hdfs_namenode_principal = connections[<NUM_LIT:0>].extra_dejson.get(<EOL>'<STR_LIT>')<EOL><DEDENT>except AirflowException:<EOL><INDENT>if not autoconfig:<EOL><INDENT>raise<EOL><DEDENT><DEDENT>if autoconfig:<EOL><INDENT>client = AutoConfigClient(effective_user=effective_user,<EOL>use_sasl=use_sasl)<EOL><DEDENT>elif len(connections) == <NUM_LIT:1>:<EOL><INDENT>client = Client(connections[<NUM_LIT:0>].host, connections[<NUM_LIT:0>].port,<EOL>effective_user=effective_user, use_sasl=use_sasl,<EOL>hdfs_namenode_principal=hdfs_namenode_principal)<EOL><DEDENT>elif len(connections) > <NUM_LIT:1>:<EOL><INDENT>nn = [Namenode(conn.host, conn.port) for conn in connections]<EOL>client = HAClient(nn, effective_user=effective_user,<EOL>use_sasl=use_sasl,<EOL>hdfs_namenode_principal=hdfs_namenode_principal)<EOL><DEDENT>else:<EOL><INDENT>raise HDFSHookException(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>return client<EOL>", "docstring": "Returns a snakebite HDFSClient object.", "id": "f9515:c1:m1"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/router_capabilities/router_capability/subtlvs/subtlvs/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of IS Router Capabilities", "id": "f22564:c0:m6"}
{"signature": "def function4():", "body": "return TESTLIST['<STR_LIT:0>']<EOL>", "docstring": "list index is a str constant", "id": "f18452:m3"}
{"signature": "def itemfreq(a):", "body": "items, inv = np.unique(a, return_inverse=True)<EOL>freq = np.bincount(inv)<EOL>return np.array([items, freq]).T<EOL>", "docstring": "Returns a 2-D array of item frequencies.\n\nParameters\n----------\na : (N,) array_like\n    Input array.\n\nReturns\n-------\nitemfreq : (K, 2) ndarray\n    A 2-D frequency table.  Column 1 contains sorted, unique values from\n    `a`, column 2 contains their respective counts.\n\nExamples\n--------\n>>> a = np.array([1, 1, 5, 0, 1, 2, 2, 0, 1, 4])\n>>> stats.itemfreq(a)\narray([[ 0.,  2.],\n       [ 1.,  4.],\n       [ 2.,  2.],\n       [ 4.,  1.],\n       [ 5.,  1.]])\n>>> np.bincount(a)\narray([2, 4, 2, 0, 1, 1])\n\n>>> stats.itemfreq(a/10.)\narray([[ 0. ,  2. ],\n       [ 0.1,  4. ],\n       [ 0.2,  2. ],\n       [ 0.4,  1. ],\n       [ 0.5,  1. ]])", "id": "f19697:m27"}
{"signature": "def _set_refresh_reduction(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:true>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__refresh_reduction = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for refresh_reduction, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/hellos/config/refresh_reduction (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_refresh_reduction is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_refresh_reduction() directly.\n\n    YANG Description: enables all RSVP refresh reduction message\nbundling, RSVP message ID, reliable message delivery\nand summary refresh", "id": "f22297:c0:m6"}
{"signature": "def run(self):", "body": "with Popen(self.command, stdout=PIPE, shell=True) as process:<EOL><INDENT>while True:<EOL><INDENT>current_line = process.stdout.readline().rstrip()<EOL>if not current_line:<EOL><INDENT>break<EOL><DEDENT>yield self._decode_output(current_line)<EOL><DEDENT><DEDENT>", "docstring": "Run the given command and yield each line(s) one by one.\n\n.. note::\n    The difference between this method and :code:`self.execute()`\n    is that :code:`self.execute()` wait for the process to end\n    in order to return its output.", "id": "f8240:c1:m3"}
{"signature": "def hermroots(c):", "body": "<EOL>[c] = pu.as_series([c])<EOL>if len(c) <= <NUM_LIT:1>:<EOL><INDENT>return np.array([], dtype=c.dtype)<EOL><DEDENT>if len(c) == <NUM_LIT:2>:<EOL><INDENT>return np.array([-<NUM_LIT>*c[<NUM_LIT:0>]/c[<NUM_LIT:1>]])<EOL><DEDENT>m = hermcompanion(c)<EOL>r = la.eigvals(m)<EOL>r.sort()<EOL>return r<EOL>", "docstring": "Compute the roots of a Hermite series.\n\nReturn the roots (a.k.a. \"zeros\") of the polynomial\n\n.. math:: p(x) = \\\\sum_i c[i] * H_i(x).\n\nParameters\n----------\nc : 1-D array_like\n    1-D array of coefficients.\n\nReturns\n-------\nout : ndarray\n    Array of the roots of the series. If all the roots are real,\n    then `out` is also real, otherwise it is complex.\n\nSee Also\n--------\npolyroots, legroots, lagroots, chebroots, hermeroots\n\nNotes\n-----\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton's method.\n\nThe Hermite series basis polynomials aren't powers of `x` so the\nresults of this function may seem unintuitive.\n\nExamples\n--------\n>>> from numpy.polynomial.hermite import hermroots, hermfromroots\n>>> coef = hermfromroots([-1, 0, 1])\n>>> coef\narray([ 0.   ,  0.25 ,  0.   ,  0.125])\n>>> hermroots(coef)\narray([ -1.00000000e+00,  -1.38777878e-17,   1.00000000e+00])", "id": "f18934:m22"}
{"signature": "def _get_id_length(self):", "body": "return self.__id_length<EOL>", "docstring": "Getter method for id_length, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/state/id_length (uint8)\n\n    YANG Description: Length of the ID field of NSAP addresses and NETs used in this\nrouting domain.", "id": "f22539:c0:m14"}
{"signature": "def from_b64(path, bcontent, format):", "body": "decoders = {<EOL>'<STR_LIT>': lambda path, bcontent: (bcontent.decode('<STR_LIT:ascii>'), '<STR_LIT>'),<EOL>'<STR_LIT:text>': _decode_text_from_base64,<EOL>None: _decode_unknown_from_base64,<EOL>}<EOL>try:<EOL><INDENT>content, real_format = decoders[format](path, bcontent)<EOL><DEDENT>except HTTPError:<EOL><INDENT>raise<EOL><DEDENT>except Exception as e:<EOL><INDENT>raise CorruptedFile(e)<EOL><DEDENT>default_mimes = {<EOL>'<STR_LIT:text>': '<STR_LIT>',<EOL>'<STR_LIT>': '<STR_LIT>',<EOL>}<EOL>mimetype = mimetypes.guess_type(path)[<NUM_LIT:0>] or default_mimes[real_format]<EOL>return content, real_format, mimetype<EOL>", "docstring": "Decode base64 content for a file.\n\nformat:\n  If 'text', the contents will be decoded as UTF-8.\n  If 'base64', do nothing.\n  If not specified, try to decode as UTF-8, and fall back to base64\n\nReturns a triple of decoded_content, format, and mimetype.", "id": "f5573:m12"}
{"signature": "def describe(self, verbose=True):", "body": "center = titlecase(target_names.get(self.center, '<STR_LIT>'))<EOL>target = titlecase(target_names.get(self.target, '<STR_LIT>'))<EOL>text = ('<STR_LIT>'<EOL>'<STR_LIT>'.format(self, center, target))<EOL>if verbose:<EOL><INDENT>text += ('<STR_LIT>'<EOL>.format(self, self.source.decode('<STR_LIT:ascii>')))<EOL><DEDENT>return text<EOL>", "docstring": "Return a textual description of the segment.", "id": "f18284:c1:m2"}
{"signature": "def sensible_axes(self):", "body": "<EOL>axes = [<NUM_LIT:1>, <NUM_LIT:1>, <NUM_LIT:1>]<EOL>if self.v0.x == self.v1.x == self.v2.x:<EOL><INDENT>axes[<NUM_LIT:0>] = <NUM_LIT:0><EOL><DEDENT>if self.v0.y == self.v1.y == self.v2.y:<EOL><INDENT>axes[<NUM_LIT:1>] = <NUM_LIT:0><EOL><DEDENT>if self.v0.z == self.v1.z == self.v2.z:<EOL><INDENT>axes[<NUM_LIT:2>] = <NUM_LIT:0><EOL><DEDENT>u = [<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>]<EOL>for i in range(<NUM_LIT:3>):<EOL><INDENT>if axes[i] == <NUM_LIT:1>:<EOL><INDENT>u[i] = <NUM_LIT:1><EOL>axes[i] = <NUM_LIT:0><EOL>break<EOL><DEDENT><DEDENT>v = [<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>]<EOL>for i in range(<NUM_LIT:3>):<EOL><INDENT>if axes[i] == <NUM_LIT:1>:<EOL><INDENT>v[i] = -<NUM_LIT:1><EOL>break<EOL><DEDENT><DEDENT>uaxis = Axis(u[<NUM_LIT:0>], u[<NUM_LIT:1>], u[<NUM_LIT:2>])<EOL>vaxis = Axis(v[<NUM_LIT:0>], v[<NUM_LIT:1>], v[<NUM_LIT:2>])<EOL>return (uaxis, vaxis)<EOL>", "docstring": "Returns a sensible uaxis and vaxis for this plane.", "id": "f3342:c5:m2"}
{"signature": "def shortDescription(self):", "body": "doc = self.id()[self.id().rfind('<STR_LIT:.>')+<NUM_LIT:1>:]<EOL>return \"<STR_LIT>\" % (self.__class__.__name__, doc)<EOL>", "docstring": "Get's the one liner description to be displayed.\nSource:\nhttp://erikzaadi.com/2012/09/13/inheritance-within-python-unit-tests/", "id": "f3845:c0:m0"}
{"signature": "@line_magic<EOL><INDENT>def aimport(self, parameter_s='<STR_LIT>', stream=None):<DEDENT>", "body": "modname = parameter_s<EOL>if not modname:<EOL><INDENT>to_reload = self._reloader.modules.keys()<EOL>to_reload.sort()<EOL>to_skip = self._reloader.skip_modules.keys()<EOL>to_skip.sort()<EOL>if stream is None:<EOL><INDENT>stream = sys.stdout<EOL><DEDENT>if self._reloader.check_all:<EOL><INDENT>stream.write(\"<STR_LIT>\")<EOL><DEDENT>else:<EOL><INDENT>stream.write(\"<STR_LIT>\" % '<STR_LIT:U+0020>'.join(to_reload))<EOL><DEDENT>stream.write(\"<STR_LIT>\" % '<STR_LIT:U+0020>'.join(to_skip))<EOL><DEDENT>elif modname.startswith('<STR_LIT:->'):<EOL><INDENT>modname = modname[<NUM_LIT:1>:]<EOL>self._reloader.mark_module_skipped(modname)<EOL><DEDENT>else:<EOL><INDENT>top_module, top_name = self._reloader.aimport_module(modname)<EOL>self.shell.push({top_name: top_module})<EOL><DEDENT>", "docstring": "%aimport => Import modules for automatic reloading.\n\n        %aimport\n        List modules to automatically import and not to import.\n\n        %aimport foo\n        Import module 'foo' and mark it to be autoreloaded for %autoreload 1\n\n        %aimport -foo\n        Mark module 'foo' to not be autoreloaded for %autoreload 1", "id": "f21476:c2:m2"}
{"signature": "@property<EOL><INDENT>def spread(self):<DEDENT>", "body": "return (self.ask_price - self.bid_price)<EOL>", "docstring": "Compute the difference between bid and ask prices", "id": "f5625:c2:m3"}
{"signature": "def remove_linked_files(self, file_path=None, relpath=None, mimetype=None,<EOL>time_origin=None, ex_from=None):", "body": "for attrib in self.media_descriptors[:]:<EOL><INDENT>if file_path is not None and attrib['<STR_LIT>'] != file_path:<EOL><INDENT>continue<EOL><DEDENT>if relpath is not None and attrib['<STR_LIT>'] != relpath:<EOL><INDENT>continue<EOL><DEDENT>if mimetype is not None and attrib['<STR_LIT>'] != mimetype:<EOL><INDENT>continue<EOL><DEDENT>if time_origin is not None andattrib['<STR_LIT>'] != time_origin:<EOL><INDENT>continue<EOL><DEDENT>if ex_from is not None and attrib['<STR_LIT>'] != ex_from:<EOL><INDENT>continue<EOL><DEDENT>del(self.media_descriptors[self.media_descriptors.index(attrib)])<EOL><DEDENT>", "docstring": "Remove all linked files that match all the criteria, criterias that\n        are ``None`` are ignored.\n\n        :param str file_path: Path of the file.\n        :param str relpath: Relative filepath.\n        :param str mimetype: Mimetype of the file.\n        :param int time_origin: Time origin.\n        :param str ex_from: Extracted from.", "id": "f14843:c0:m70"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/lan_adjacency_sid/sid/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of LAN Adjacency-SID.", "id": "f22806:c0:m3"}
{"signature": "@property<EOL><INDENT>def tags(self):<DEDENT>", "body": "tags = self.parsed_filename.groupdict()<EOL>for pyver in tags['<STR_LIT>'].split('<STR_LIT:.>'):<EOL><INDENT>for abi in tags['<STR_LIT>'].split('<STR_LIT:.>'):<EOL><INDENT>for plat in tags['<STR_LIT>'].split('<STR_LIT:.>'):<EOL><INDENT>yield (pyver, abi, plat)<EOL><DEDENT><DEDENT><DEDENT>", "docstring": "A wheel file is compatible with the Cartesian product of the\n        period-delimited tags in its filename.\n        To choose a wheel file among several candidates having the same\n        distribution version 'ver', an installer ranks each triple of\n        (pyver, abi, plat) that its Python installation can run, sorting\n        the wheels by the best-ranked tag it supports and then by their\n        arity which is just len(list(compatibility_tags)).", "id": "f17122:c1:m6"}
{"signature": "def _should_trace_with_reason(self, filename, frame):", "body": "if not filename:<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT>if filename.startswith('<STR_LIT:<>'):<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT>self._check_for_packages()<EOL>dunder_file = frame.f_globals.get('<STR_LIT>')<EOL>if dunder_file:<EOL><INDENT>filename = self._source_for_file(dunder_file)<EOL><DEDENT>if filename.endswith(\"<STR_LIT>\"):<EOL><INDENT>filename = filename[:-<NUM_LIT:9>] + \"<STR_LIT>\"<EOL><DEDENT>canonical = self.file_locator.canonical_filename(filename)<EOL>if self.source_match:<EOL><INDENT>if not self.source_match.match(canonical):<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT><DEDENT>elif self.include_match:<EOL><INDENT>if not self.include_match.match(canonical):<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if self.pylib_match and self.pylib_match.match(canonical):<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT>if self.cover_match and self.cover_match.match(canonical):<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT><DEDENT>if self.omit_match and self.omit_match.match(canonical):<EOL><INDENT>return None, \"<STR_LIT>\"<EOL><DEDENT>return canonical, \"<STR_LIT>\"<EOL>", "docstring": "Decide whether to trace execution in `filename`, with a reason.\n\n        This function is called from the trace function.  As each new file name\n        is encountered, this function determines whether it is traced or not.\n\n        Returns a pair of values:  the first indicates whether the file should\n        be traced: it's a canonicalized filename if it should be traced, None\n        if it should not.  The second value is a string, the resason for the\n        decision.", "id": "f17076:c0:m3"}
{"signature": "@fluent<EOL><INDENT>def content(self, name):<DEDENT>", "body": "self._headers['<STR_LIT:Content-Type>'] = TYPES.get(name, name)<EOL>", "docstring": "Defines the response ``Content-Type`` header.\n\nYou can pass one of the following type aliases instead of the full\nMIME type representation:\n\n- ``json`` = ``application/json``\n- ``xml`` = ``application/xml``\n- ``html`` = ``text/html``\n- ``text`` = ``text/plain``\n- ``urlencoded`` = ``application/x-www-form-urlencoded``\n- ``form`` = ``application/x-www-form-urlencoded``\n- ``form-data`` = ``application/x-www-form-urlencoded``\n\nArguments:\n    value (str): type alias or header value to match.\n\nReturns:\n    self: ``pook.Response`` current instance.", "id": "f11910:c0:m6"}
{"signature": "@docsubst<EOL><INDENT>def covar(self, x, y, binby=[], limits=None, shape=default_shape, selection=False, delay=False, progress=None):<DEDENT>", "body": "@delayed<EOL>def cov(mean_x, mean_y, mean_xy):<EOL><INDENT>return mean_xy - mean_x * mean_y<EOL><DEDENT>waslist, [xlist, ylist] = vaex.utils.listify(x, y)<EOL>limits = self.limits(binby, limits, selection=selection, delay=True)<EOL>@delayed<EOL>def calculate(limits):<EOL><INDENT>results = []<EOL>for x, y in zip(xlist, ylist):<EOL><INDENT>mx = self.mean(x, binby=binby, limits=limits, shape=shape, selection=selection, delay=True, progress=progressbar)<EOL>my = self.mean(y, binby=binby, limits=limits, shape=shape, selection=selection, delay=True, progress=progressbar)<EOL>cxy = self.mean(\"<STR_LIT>\" % (x, y), binby=binby, limits=limits, shape=shape, selection=selection,<EOL>delay=True, progress=progressbar)<EOL>results.append(cov(mx, my, cxy))<EOL><DEDENT>return results<EOL><DEDENT>progressbar = vaex.utils.progressbars(progress)<EOL>covars = calculate(limits)<EOL>@delayed<EOL>def finish(covars):<EOL><INDENT>value = np.array(vaex.utils.unlistify(waslist, covars))<EOL>return value<EOL><DEDENT>return self._delay(delay, finish(delayed_list(covars)))<EOL>", "docstring": "Calculate the covariance cov[x,y] between and x and y, possibly on a grid defined by binby.\n\n        Example:\n\n        >>> df.covar(\"x**2+y**2+z**2\", \"-log(-E+1)\")\n        array(52.69461456005138)\n        >>> df.covar(\"x**2+y**2+z**2\", \"-log(-E+1)\")/(df.std(\"x**2+y**2+z**2\") * df.std(\"-log(-E+1)\"))\n        0.63666373822156686\n        >>> df.covar(\"x**2+y**2+z**2\", \"-log(-E+1)\", binby=\"Lz\", shape=4)\n        array([ 10.17387143,  51.94954078,  51.24902796,  20.2163929 ])\n\n\n\n        :param x: {expression}\n        :param y: {expression}\n        :param binby: {binby}\n        :param limits: {limits}\n        :param shape: {shape}\n        :param selection: {selection}\n        :param delay: {delay}\n        :param progress: {progress}\n        :return: {return_stat_scalar}", "id": "f6914:c0:m33"}
{"signature": "def create_firewall_rule(self, server_name, name, start_ip_address,<EOL>end_ip_address):", "body": "_validate_not_none('<STR_LIT>', server_name)<EOL>_validate_not_none('<STR_LIT:name>', name)<EOL>_validate_not_none('<STR_LIT>', start_ip_address)<EOL>_validate_not_none('<STR_LIT>', end_ip_address)<EOL>return self._perform_post(<EOL>self._get_firewall_rules_path(server_name),<EOL>_SqlManagementXmlSerializer.create_firewall_rule_to_xml(<EOL>name, start_ip_address, end_ip_address<EOL>)<EOL>)<EOL>", "docstring": "Creates an Azure SQL Database server firewall rule.\n\nserver_name:\n    Name of the server to set the firewall rule on. \nname:\n    The name of the new firewall rule.\nstart_ip_address:\n    The lowest IP address in the range of the server-level firewall\n    setting. IP addresses equal to or greater than this can attempt to\n    connect to the server. The lowest possible IP address is 0.0.0.0.\nend_ip_address:\n    The highest IP address in the range of the server-level firewall\n    setting. IP addresses equal to or less than this can attempt to\n    connect to the server. The highest possible IP address is\n    255.255.255.255.", "id": "f41511:c0:m7"}
{"signature": "def register_context_middleware(self, *middleware):", "body": "for m in middleware:<EOL><INDENT>if not is_generator(m):<EOL><INDENT>raise Exception('<STR_LIT>'.format(m))<EOL><DEDENT><DEDENT>self._middleware.extend(middleware)<EOL>", "docstring": ":param middleware: Middleware in order of execution", "id": "f2797:c1:m1"}
{"signature": "def list_worker_pools(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_worker_pools.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.WorkerPoolResourcePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.WorkerPoolResourcePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get all worker pools of an App Service Environment.\n\n        Get all worker pools of an App Service Environment.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the App Service Environment.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of WorkerPoolResource\n        :rtype:\n         ~azure.mgmt.web.models.WorkerPoolResourcePaged[~azure.mgmt.web.models.WorkerPoolResource]\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44995:c0:m37"}
{"signature": "def get_azure_reachability_report(<EOL>self, resource_group_name, network_watcher_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._get_azure_reachability_report_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_watcher_name=network_watcher_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Gets the relative latency score for internet service providers from a\n        specified location to Azure regions.\n\n        :param resource_group_name: The name of the network watcher resource\n         group.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the network watcher resource.\n        :type network_watcher_name: str\n        :param parameters: Parameters that determine Azure reachability report\n         configuration.\n        :type parameters:\n         ~azure.mgmt.network.v2018_06_01.models.AzureReachabilityReportParameters\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns AzureReachabilityReport\n         or ClientRawResponse<AzureReachabilityReport> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_06_01.models.AzureReachabilityReport]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_06_01.models.AzureReachabilityReport]]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.network.v2018_06_01.models.ErrorResponseException>`", "id": "f30952:c0:m26"}
{"signature": "def clear(self, nolock=False):", "body": "pass<EOL>", "docstring": "tqdm api compatibility. does nothing", "id": "f404:c0:m7"}
{"signature": "def set_label(self, label, bigdl_type=\"<STR_LIT:float>\"):", "body": "return callBigDlFunc(bigdl_type,<EOL>\"<STR_LIT>\", label, self.value)<EOL>", "docstring": "set label for imageframe", "id": "f13265:c3:m12"}
{"signature": "def _get_auto_bandwidth(self):", "body": "return self.__auto_bandwidth<EOL>", "docstring": "Getter method for auto_bandwidth, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/bandwidth/auto_bandwidth (container)\n\nYANG Description: Parameters related to auto-bandwidth", "id": "f22252:c0:m8"}
{"signature": "def _purge_headers_cb(headers):", "body": "header_list = []<EOL>for item in headers:<EOL><INDENT>if not isinstance(item, tuple):<EOL><INDENT>item = (item, None)<EOL><DEDENT>header_list.append(item[<NUM_LIT:0>:<NUM_LIT:2>])  <EOL><DEDENT>def before_record_response_cb(response):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>for (header, value) in header_list:<EOL><INDENT>with suppress(KeyError):<EOL><INDENT>if value:<EOL><INDENT>response['<STR_LIT>'][header] = value<EOL><DEDENT>else:<EOL><INDENT>del response['<STR_LIT>'][header]<EOL><DEDENT><DEDENT><DEDENT>return response<EOL><DEDENT>return before_record_response_cb<EOL>", "docstring": "Remove headers from the response.\n\n    Args:\n        headers (list): headers to remove from the response\n\n    Returns:\n        callable: for been used in before_record_response VCR constructor.", "id": "f10852:m1"}
{"signature": "def _recurse(self, inputs, output):", "body": "if inputs:<EOL><INDENT>my_input = inputs[<NUM_LIT:0>]<EOL>name = my_input.name<EOL>if my_input.state:<EOL><INDENT>my_options = my_input.options(self.state)<EOL><DEDENT>else:<EOL><INDENT>my_options = my_input.options<EOL><DEDENT>for option in my_options:<EOL><INDENT>my_output = list(output)<EOL>my_output.append({name: option})<EOL>self._recurse(inputs[<NUM_LIT:1>:], my_output)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>try:<EOL><INDENT>valid, result = self._function(output)<EOL><DEDENT>except ValueError:<EOL><INDENT>raise RuntimeError(\"<STR_LIT>\")<EOL><DEDENT>print(output, valid, result)<EOL><DEDENT>", "docstring": "internal recursion routine called by the run method that generates\n        all input combinations", "id": "f13972:c1:m2"}
{"signature": "def export_genes(adapter, build='<STR_LIT>'):", "body": "LOG.info(\"<STR_LIT>\")<EOL>for gene_obj in adapter.all_genes(build=build):<EOL><INDENT>yield gene_obj<EOL><DEDENT>", "docstring": "Export all genes from the database", "id": "f13614:m0"}
{"signature": "def invoke(self, line):", "body": "finished = True<EOL>while len(line) > <NUM_LIT:0>:<EOL><INDENT>val, line, finished = self.invoke_one(line)<EOL>if val is not None:<EOL><INDENT>iprint(val)<EOL><DEDENT><DEDENT>return finished<EOL>", "docstring": "Invoke a one or more function given a list of arguments.\n\n        The functions are searched for using the current context on the context stack\n        and its annotated type information is used to convert all of the string parameters\n        passed in line to appropriate python types.\n\n        Args:\n            line (list): The list of command line arguments.\n\n        Returns:\n            bool: A boolean specifying if the last function created a new context\n                (False if a new context was created) and a list with the remainder of the\n                command line if this function did not consume all arguments.)", "id": "f17796:c1:m20"}
{"signature": "def list(<EOL>self, start=None, top=<NUM_LIT:1000>, return_recognition_model=False, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if start is not None:<EOL><INDENT>query_parameters['<STR_LIT:start>'] = self._serialize.query(\"<STR_LIT:start>\", start, '<STR_LIT:str>', max_length=<NUM_LIT:64>)<EOL><DEDENT>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>', maximum=<NUM_LIT:1000>, minimum=<NUM_LIT:1>)<EOL><DEDENT>if return_recognition_model is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", return_recognition_model, '<STR_LIT:bool>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.APIErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "List all existing large person groups\u2019 largePersonGroupId, name,\n        userData and recognitionModel.<br />\n        * Large person groups are stored in alphabetical order of\n        largePersonGroupId.\n        * \"start\" parameter (string, optional) is a user-provided\n        largePersonGroupId value that returned entries have larger ids by\n        string comparison. \"start\" set to empty to indicate return from the\n        first item.\n        * \"top\" parameter (int, optional) specifies the number of entries to\n        return. A maximal of 1000 entries can be returned in one call. To fetch\n        more, you can specify \"start\" with the last returned entry\u2019s Id of the\n        current call.\n        <br />\n        For example, total 5 large person groups: \"group1\", ..., \"group5\".\n        <br /> \"start=&top=\" will return all 5 groups.\n        <br /> \"start=&top=2\" will return \"group1\", \"group2\".\n        <br /> \"start=group2&top=3\" will return \"group3\", \"group4\", \"group5\".\n        .\n\n        :param start: List large person groups from the least\n         largePersonGroupId greater than the \"start\".\n        :type start: str\n        :param top: The number of large person groups to list.\n        :type top: int\n        :param return_recognition_model: A value indicating whether the\n         operation should return 'recognitionModel' in response.\n        :type return_recognition_model: bool\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: list or ClientRawResponse if raw=true\n        :rtype:\n         list[~azure.cognitiveservices.vision.face.models.LargePersonGroup] or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`APIErrorException<azure.cognitiveservices.vision.face.models.APIErrorException>`", "id": "f38999:c0:m6"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/connection_points/connection_point/config (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_config is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_config() directly.\n\n    YANG Description: Configuration parameters relating to a Layer 2\nnetwork instance connection point", "id": "f22346:c1:m6"}
{"signature": "def describe_object(self, obj):", "body": "conn = self.get_conn()<EOL>return conn.__getattr__(obj).describe()<EOL>", "docstring": "Get the description of an object from Salesforce.\nThis description is the object's schema and\nsome extra metadata that Salesforce stores for each object.\n\n:param obj: The name of the Salesforce object that we are getting a description of.\n:type obj: str\n:return: the description of the Salesforce object.\n:rtype: dict", "id": "f9165:c0:m3"}
{"signature": "def stop(<EOL>self, resource_group_name, network_watcher_name, packet_capture_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._stop_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_watcher_name=network_watcher_name,<EOL>packet_capture_name=packet_capture_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Stops a specified packet capture session.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the network watcher.\n        :type network_watcher_name: str\n        :param packet_capture_name: The name of the packet capture session.\n        :type packet_capture_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33398:c0:m7"}
{"signature": "@property<EOL><INDENT>def ws_url(self):<DEDENT>", "body": "proto = self.request.protocol.replace('<STR_LIT:http>', '<STR_LIT>')<EOL>host = self.application.ipython_app.websocket_host <EOL>if host == '<STR_LIT>':<EOL><INDENT>host = self.request.host <EOL><DEDENT>return \"<STR_LIT>\" % (proto, host)<EOL>", "docstring": "websocket url matching the current request\n\n        turns http[s]://host[:port] into\n                ws[s]://host[:port]", "id": "f21634:c1:m4"}
{"signature": "def write_languages(self, file_path='<STR_LIT>',date=str(datetime.date.today())):", "body": "self.remove_date(file_path=file_path, date=date)<EOL>languages_exists = os.path.isfile(file_path)<EOL>with open(file_path, '<STR_LIT:a>') as out_languages:<EOL><INDENT>if not languages_exists:<EOL><INDENT>out_languages.write('<STR_LIT>')<EOL><DEDENT>languages_sorted = sorted(self.languages_size)<EOL>for language in languages_sorted:<EOL><INDENT>try:<EOL><INDENT>out_languages.write(date + '<STR_LIT:U+002C>' + language + '<STR_LIT:U+002C>'<EOL>+ str(self.languages[language]) + '<STR_LIT:U+002C>'<EOL>+ str(self.languages_size[language]) + '<STR_LIT:U+002C>'<EOL>+ str(math.log10(int(self.languages_size[language])))<EOL>+ '<STR_LIT:\\n>')<EOL><DEDENT>except (TypeError, KeyError) as e:<EOL><INDENT>out_languages.write(date + '<STR_LIT:U+002C>' + language + '<STR_LIT:U+002C>'<EOL>+ str(<NUM_LIT:0>) + '<STR_LIT:U+002C>'<EOL>+ str(self.languages_size[language]) + '<STR_LIT:U+002C>'<EOL>+ str(math.log10(int(self.languages_size[language])))<EOL>+ '<STR_LIT:\\n>')<EOL><DEDENT><DEDENT><DEDENT>", "docstring": "Updates languages.csv file with current data.", "id": "f4697:c0:m19"}
{"signature": "@classmethod<EOL><INDENT>def setUpClass(cls):<DEDENT>", "body": "print(\"<STR_LIT>\")<EOL>cls.backend_address = \"<STR_LIT>\"<EOL>os.environ['<STR_LIT>'] = '<STR_LIT>'<EOL>exit_code = subprocess.call(<EOL>shlex.split(<EOL>'<STR_LIT>' % os.environ['<STR_LIT>'])<EOL>)<EOL>assert exit_code == <NUM_LIT:0><EOL>cls.pid = subprocess.Popen([<EOL>'<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>'<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>'<STR_LIT>'<EOL>])<EOL>time.sleep(<NUM_LIT:3>)<EOL>headers = {'<STR_LIT:Content-Type>': '<STR_LIT:application/json>'}<EOL>params = {'<STR_LIT:username>': '<STR_LIT>', '<STR_LIT:password>': '<STR_LIT>', '<STR_LIT:action>': '<STR_LIT>'}<EOL>response = requests.post(cls.backend_address + '<STR_LIT>', json=params, headers=headers)<EOL>resp = response.json()<EOL>cls.token = resp['<STR_LIT>']<EOL>cls.auth = requests.auth.HTTPBasicAuth(cls.token, '<STR_LIT>')<EOL>response = requests.get(cls.backend_address + '<STR_LIT>',<EOL>auth=cls.auth)<EOL>resp = response.json()<EOL>cls.realmAll_id = resp['<STR_LIT>'][<NUM_LIT:0>]['<STR_LIT>']<EOL>", "docstring": "Function used in the beginning of test to prepare the backend\n\n:param module:\n:return: None", "id": "f5530:c0:m0"}
{"signature": "@staticmethod<EOL><INDENT>def load_caffe_model(defPath, modelPath, bigdl_type=\"<STR_LIT:float>\"):<DEDENT>", "body": "jmodel = callBigDlFunc(bigdl_type, \"<STR_LIT>\", defPath, modelPath)<EOL>return Layer.of(jmodel)<EOL>", "docstring": "Load a pre-trained Caffe model.\n\n\n:param defPath: The path containing the caffe model definition.\n:param modelPath: The path containing the pre-trained caffe model.\n:return: A pre-trained model.", "id": "f13262:c4:m7"}
{"signature": "def get_interaction_energy(ampal_objs, ff=None, assign_ff=True):", "body": "if ff is None:<EOL><INDENT>ff = FORCE_FIELDS['<STR_LIT>']<EOL><DEDENT>if assign_ff:<EOL><INDENT>for ampal_obj in ampal_objs:<EOL><INDENT>assign_force_field(ampal_obj, ff)<EOL><DEDENT><DEDENT>interactions = find_inter_ampal(ampal_objs, ff.distance_cutoff)<EOL>buff_score = score_interactions(interactions, ff)<EOL>return buff_score<EOL>", "docstring": "Calculates the interaction energy between AMPAL objects.\n\n    Parameters\n    ----------\n    ampal_objs: [AMPAL Object]\n        A list of any AMPAL objects with `get_atoms` methods.\n    ff: BuffForceField, optional\n        The force field to be used for scoring. If no force field is\n        provided then the most current version of the BUDE force field\n        will be used.\n    assign_ff: bool, optional\n        If true, then force field assignment on the AMPAL object will be\n        will be updated.\n\n    Returns\n    -------\n    BUFF_score: BUFFScore\n        A BUFFScore object with information about each of the interactions and\n        the atoms involved.", "id": "f1089:m0"}
{"signature": "def nothread_quit(self, arg):", "body": "self.debugger.core.stop()<EOL>self.debugger.core.execution_status = '<STR_LIT>'<EOL>self.proc.response['<STR_LIT>'] = '<STR_LIT>'<EOL>self.proc.response['<STR_LIT:name>']  = '<STR_LIT:status>'<EOL>self.proc.intf[-<NUM_LIT:1>].msg(self.proc.response)<EOL>raise Mexcept.DebuggerQuit<EOL>", "docstring": "quit command when there's just one thread.", "id": "f7450:c0:m0"}
{"signature": "def get_backup_status(<EOL>self, resource_group_name, name, backup_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_backup_status.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", backup_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a backup of an app by its ID.\n\n        Gets a backup of an app by its ID.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param backup_id: ID of the backup.\n        :type backup_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: BackupItem or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.web.models.BackupItem or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44988:c0:m12"}
{"signature": "@property<EOL><INDENT>def x(self):<DEDENT>", "body": "return scale_dimension(self.X, self.header.x_scale, self.header.x_offset)<EOL>", "docstring": "Returns the scaled x positions of the points as doubles", "id": "f5974:c0:m1"}
{"signature": "def keys(self):", "body": "return list(self.iterkeys())<EOL>", "docstring": "Dict-like keys() that returns a list of names of cookies from the jar.\n        See values() and items().", "id": "f17244:c3:m3"}
{"signature": "def update(<EOL>self, body, resource_group_name, account_name, pool_name, volume_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.update.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", pool_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", volume_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(body, '<STR_LIT>')<EOL>request = self._client.patch(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Patch a volume.\n\n        :param body: Volume object supplied in the body of the operation.\n        :type body: ~azure.mgmt.netapp.models.VolumePatch\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param account_name: The name of the NetApp account\n        :type account_name: str\n        :param pool_name: The name of the capacity pool\n        :type pool_name: str\n        :param volume_name: The name of the volume\n        :type volume_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Volume or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.netapp.models.Volume or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorException<azure.mgmt.netapp.models.ErrorException>`", "id": "f36624:c0:m5"}
{"signature": "def _anderson_ksamp_right(samples, Z, Zstar, k, n, N):", "body": "A2kN = <NUM_LIT:0.><EOL>lj = Z.searchsorted(Zstar[:-<NUM_LIT:1>], '<STR_LIT:right>') - Z.searchsorted(Zstar[:-<NUM_LIT:1>],<EOL>'<STR_LIT:left>')<EOL>Bj = lj.cumsum()<EOL>for i in arange(<NUM_LIT:0>, k):<EOL><INDENT>s = np.sort(samples[i])<EOL>Mij = s.searchsorted(Zstar[:-<NUM_LIT:1>], side='<STR_LIT:right>')<EOL>inner = lj / float(N) * (N * Mij - Bj * n[i])**<NUM_LIT:2> / (Bj * (N - Bj))<EOL>A2kN += inner.sum() / n[i]<EOL><DEDENT>return A2kN<EOL>", "docstring": "Compute A2akN equation 6 of Scholz & Stephens.\n\nParameters\n----------\nsamples : sequence of 1-D array_like\n    Array of sample arrays.\nZ : array_like\n    Sorted array of all observations.\nZstar : array_like\n    Sorted array of unique observations.\nk : int\n    Number of samples.\nn : array_like\n    Number of observations in each sample.\nN : int\n    Total number of observations.\n\nReturns\n-------\nA2KN : float\n    The A2KN statistics of Scholz and Stephens 1987.", "id": "f19695:m17"}
{"signature": "def get_functions_fast(self,code):", "body": "return self.cache.get(code,[])<EOL>", "docstring": "Return list of functions for code from the cache.\n\n            Return an empty list if the code entry is not found.", "id": "f19666:c0:m16"}
{"signature": "@staticmethod<EOL><INDENT>def get_params(width, height, distortion_scale):<DEDENT>", "body": "half_height = int(height / <NUM_LIT:2>)<EOL>half_width = int(width / <NUM_LIT:2>)<EOL>topleft = (random.randint(<NUM_LIT:0>, int(distortion_scale * half_width)),<EOL>random.randint(<NUM_LIT:0>, int(distortion_scale * half_height)))<EOL>topright = (random.randint(width - int(distortion_scale * half_width) - <NUM_LIT:1>, width - <NUM_LIT:1>),<EOL>random.randint(<NUM_LIT:0>, int(distortion_scale * half_height)))<EOL>botright = (random.randint(width - int(distortion_scale * half_width) - <NUM_LIT:1>, width - <NUM_LIT:1>),<EOL>random.randint(height - int(distortion_scale * half_height) - <NUM_LIT:1>, height - <NUM_LIT:1>))<EOL>botleft = (random.randint(<NUM_LIT:0>, int(distortion_scale * half_width)),<EOL>random.randint(height - int(distortion_scale * half_height) - <NUM_LIT:1>, height - <NUM_LIT:1>))<EOL>startpoints = [(<NUM_LIT:0>, <NUM_LIT:0>), (width - <NUM_LIT:1>, <NUM_LIT:0>), (width - <NUM_LIT:1>, height - <NUM_LIT:1>), (<NUM_LIT:0>, height - <NUM_LIT:1>)]<EOL>endpoints = [topleft, topright, botright, botleft]<EOL>return startpoints, endpoints<EOL>", "docstring": "Get parameters for ``perspective`` for a random perspective transform.\n\n        Args:\n            width : width of the image.\n            height : height of the image.\n\n        Returns:\n            List containing [top-left, top-right, bottom-right, bottom-left] of the orignal image,\n            List containing [top-left, top-right, bottom-right, bottom-left] of the transformed image.", "id": "f3371:c16:m2"}
{"signature": "def function24():", "body": "class ListTest(list):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>def __getitem__(self, key):<EOL><INDENT>pass<EOL><DEDENT><DEDENT>test = ListTest()<EOL>test[None] = <NUM_LIT:0> <EOL>del test[None] <EOL>test[None][<NUM_LIT:0>] = <NUM_LIT:0> <EOL>test[<NUM_LIT:0>][<NUM_LIT:0>] = <NUM_LIT:0> <EOL>test[<NUM_LIT:0>] = <NUM_LIT:0> <EOL>del test[<NUM_LIT:0>]<EOL>", "docstring": "Get, set, and delete on a subclass of list that overrides __getitem__", "id": "f18452:m23"}
{"signature": "def _frz(a):", "body": "if a.ndim == <NUM_LIT:0>: a.shape = (<NUM_LIT:1>,)<EOL>return a<EOL>", "docstring": "fix rank-0 --> rank-1", "id": "f19050:m0"}
{"signature": "def list(<EOL>self, filter=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.tenant_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = '<STR_LIT>'<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", next_link, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.tenant_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.GraphErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ServicePrincipalPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ServicePrincipalPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a list of service principals from the current tenant.\n\n        :param filter: The filter to apply to the operation.\n        :type filter: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ServicePrincipal\n        :rtype:\n         ~azure.graphrbac.models.ServicePrincipalPaged[~azure.graphrbac.models.ServicePrincipal]\n        :raises:\n         :class:`GraphErrorException<azure.graphrbac.models.GraphErrorException>`", "id": "f37164:c0:m2"}
{"signature": "def check_entry_points(dist, attr, value):", "body": "try:<EOL><INDENT>pkg_resources.EntryPoint.parse_map(value)<EOL><DEDENT>except ValueError as e:<EOL><INDENT>raise DistutilsSetupError(e)<EOL><DEDENT>", "docstring": "Verify that entry_points map is parseable", "id": "f21746:m7"}
{"signature": "@contents.setter<EOL><INDENT>def contents(self, contents: str) -> None:<DEDENT>", "body": "match = self._match<EOL>start, end = match.span('<STR_LIT>')<EOL>if start != -<NUM_LIT:1>:<EOL><INDENT>self[start:end] = contents<EOL><DEDENT>else:<EOL><INDENT>s, e = match.span('<STR_LIT>')<EOL>self[s:e] = '<STR_LIT>'.format(contents, match['<STR_LIT:name>'].decode())<EOL><DEDENT>", "docstring": "Set new contents.\n\n        Note that if the tag is self-closing, then it will be expanded to\n        have a start tag and an end tag. For example:\n        >>> t = Tag('<t/>')\n        >>> t.contents = 'n'\n        >>> t.string\n        '<t>n</t>'", "id": "f8139:c1:m4"}
{"signature": "def output_difference(self, example, got, optionflags):", "body": "want = example.want<EOL>if not (optionflags & DONT_ACCEPT_BLANKLINE):<EOL><INDENT>got = re.sub('<STR_LIT>', BLANKLINE_MARKER, got)<EOL><DEDENT>if self._do_a_fancy_diff(want, got, optionflags):<EOL><INDENT>want_lines = want.splitlines(True)  <EOL>got_lines = got.splitlines(True)<EOL>if optionflags & REPORT_UDIFF:<EOL><INDENT>diff = difflib.unified_diff(want_lines, got_lines, n=<NUM_LIT:2>)<EOL>diff = list(diff)[<NUM_LIT:2>:] <EOL>kind = '<STR_LIT>'<EOL><DEDENT>elif optionflags & REPORT_CDIFF:<EOL><INDENT>diff = difflib.context_diff(want_lines, got_lines, n=<NUM_LIT:2>)<EOL>diff = list(diff)[<NUM_LIT:2>:] <EOL>kind = '<STR_LIT>'<EOL><DEDENT>elif optionflags & REPORT_NDIFF:<EOL><INDENT>engine = difflib.Differ(charjunk=difflib.IS_CHARACTER_JUNK)<EOL>diff = list(engine.compare(want_lines, got_lines))<EOL>kind = '<STR_LIT>'<EOL><DEDENT>else:<EOL><INDENT>assert <NUM_LIT:0>, '<STR_LIT>'<EOL><DEDENT>diff = [line.rstrip() + '<STR_LIT:\\n>' for line in diff]<EOL>return '<STR_LIT>' % kind + _indent('<STR_LIT>'.join(diff))<EOL><DEDENT>if want and got:<EOL><INDENT>return '<STR_LIT>' % (_indent(want), _indent(got))<EOL><DEDENT>elif want:<EOL><INDENT>return '<STR_LIT>' % _indent(want)<EOL><DEDENT>elif got:<EOL><INDENT>return '<STR_LIT>' % _indent(got)<EOL><DEDENT>else:<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>", "docstring": "Return a string describing the differences between the\nexpected output for a given example (`example`) and the actual\noutput (`got`).  `optionflags` is the set of option flags used\nto compare `want` and `got`.", "id": "f21705:c7:m2"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/bandwidth/auto_bandwidth/overflow/config/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: enables mpls lsp bandwidth overflow\nadjustment on the lsp", "id": "f22244:c0:m3"}
{"signature": "@property<EOL><INDENT>def size(self):<DEDENT>", "body": "return self._metadata['<STR_LIT>']<EOL>", "docstring": "Size in bytes of the serialized dataset contents.", "id": "f13017:c2:m19"}
{"signature": "def join(self, **conditions):", "body": "self.query.add_join_conditions(conditions)<EOL>return self<EOL>", "docstring": "Adds extra conditions to existing joins.\n\n        WARNING: This is an extremely experimental feature.\n                 DO NOT USE unless you know what you're doing.", "id": "f353:c0:m3"}
{"signature": "def _get_restart_timer(self):", "body": "return self.__restart_timer<EOL>", "docstring": "Getter method for restart_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/config/restart_timer (decimal64)\n\n    YANG Description: Time interval in seconds after which the BGP session\nis re-established after being torn down due to exceeding\nthe max-prefix limit.", "id": "f23415:c0:m11"}
{"signature": "def parse(self, value, decimal=None):", "body": "<EOL>value = value or <NUM_LIT:0><EOL>if check_type(value, '<STR_LIT:list>'):<EOL><INDENT>return map(lambda val: self.parse(val, decimal))<EOL><DEDENT>if check_type(value, '<STR_LIT:int>') or check_type(value, '<STR_LIT:float>'):<EOL><INDENT>return value<EOL><DEDENT>decimal = decimal or self.settings.number.decimal<EOL>regex = re.compile(\"<STR_LIT>\" + decimal + \"<STR_LIT:]>\")<EOL>unformatted = str(value)<EOL>unformatted = re.sub('<STR_LIT>', \"<STR_LIT>\", unformatted)<EOL>unformatted = re.sub(regex, '<STR_LIT>', unformatted)<EOL>unformatted = unformatted.replace('<STR_LIT:.>', decimal)<EOL>formatted = (lambda val: unformatted if val else <NUM_LIT:0>)(<EOL>is_num(unformatted))<EOL>return formatted<EOL>", "docstring": "Summary.\n\n Takes a string/array of strings, removes all formatting/cruft and\n returns the raw float value\n\n Decimal must be included in the regular expression to match floats\n  (defaults to Accounting.settings.number.decimal),\n  so if the number uses a non-standard decimal\n separator, provide it as the second argument.\n *\n Also matches bracketed negatives (eg. \"$ (1.99)\" => -1.99)\n\n Doesn't throw any errors (`None`s become 0) but this may change\n\nArgs:\n    value (TYPE): Description\n    decimal (TYPE): Description\n\nReturns:\n    name (TYPE): Description", "id": "f585:c0:m3"}
{"signature": "def without_deprecated(plugin, options):", "body": "return filter(lambda option: not is_option_deprecated(plugin, option[<NUM_LIT:0>]), options)<EOL>", "docstring": ":type options: list of tuple", "id": "f17599:m9"}
{"signature": "def run_query(self,<EOL>sql,<EOL>destination_dataset_table=None,<EOL>write_disposition='<STR_LIT>',<EOL>allow_large_results=False,<EOL>flatten_results=None,<EOL>udf_config=None,<EOL>use_legacy_sql=None,<EOL>maximum_billing_tier=None,<EOL>maximum_bytes_billed=None,<EOL>create_disposition='<STR_LIT>',<EOL>query_params=None,<EOL>labels=None,<EOL>schema_update_options=(),<EOL>priority='<STR_LIT>',<EOL>time_partitioning=None,<EOL>api_resource_configs=None,<EOL>cluster_fields=None,<EOL>location=None):", "body": "if time_partitioning is None:<EOL><INDENT>time_partitioning = {}<EOL><DEDENT>if location:<EOL><INDENT>self.location = location<EOL><DEDENT>if not api_resource_configs:<EOL><INDENT>api_resource_configs = self.api_resource_configs<EOL><DEDENT>else:<EOL><INDENT>_validate_value('<STR_LIT>',<EOL>api_resource_configs, dict)<EOL><DEDENT>configuration = deepcopy(api_resource_configs)<EOL>if '<STR_LIT>' not in configuration:<EOL><INDENT>configuration['<STR_LIT>'] = {}<EOL><DEDENT>else:<EOL><INDENT>_validate_value(\"<STR_LIT>\",<EOL>configuration['<STR_LIT>'], dict)<EOL><DEDENT>if sql is None and not configuration['<STR_LIT>'].get('<STR_LIT>', None):<EOL><INDENT>raise TypeError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>allowed_schema_update_options = [<EOL>'<STR_LIT>', \"<STR_LIT>\"<EOL>]<EOL>if not set(allowed_schema_update_options<EOL>).issuperset(set(schema_update_options)):<EOL><INDENT>raise ValueError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>.format(schema_update_options,<EOL>allowed_schema_update_options))<EOL><DEDENT>if schema_update_options:<EOL><INDENT>if write_disposition not in [\"<STR_LIT>\", \"<STR_LIT>\"]:<EOL><INDENT>raise ValueError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT><DEDENT>if destination_dataset_table:<EOL><INDENT>destination_project, destination_dataset, destination_table =_split_tablename(table_input=destination_dataset_table,<EOL>default_project_id=self.project_id)<EOL>destination_dataset_table = {<EOL>'<STR_LIT>': destination_project,<EOL>'<STR_LIT>': destination_dataset,<EOL>'<STR_LIT>': destination_table,<EOL>}<EOL><DEDENT>if cluster_fields:<EOL><INDENT>cluster_fields = {'<STR_LIT>': cluster_fields}<EOL><DEDENT>query_param_list = [<EOL>(sql, '<STR_LIT>', None, six.string_types),<EOL>(priority, '<STR_LIT>', '<STR_LIT>', six.string_types),<EOL>(use_legacy_sql, '<STR_LIT>', self.use_legacy_sql, bool),<EOL>(query_params, '<STR_LIT>', None, list),<EOL>(udf_config, '<STR_LIT>', None, list),<EOL>(maximum_billing_tier, '<STR_LIT>', None, int),<EOL>(maximum_bytes_billed, '<STR_LIT>', None, float),<EOL>(time_partitioning, '<STR_LIT>', {}, dict),<EOL>(schema_update_options, '<STR_LIT>', None, tuple),<EOL>(destination_dataset_table, '<STR_LIT>', None, dict),<EOL>(cluster_fields, '<STR_LIT>', None, dict),<EOL>]<EOL>for param_tuple in query_param_list:<EOL><INDENT>param, param_name, param_default, param_type = param_tuple<EOL>if param_name not in configuration['<STR_LIT>'] and param in [None, {}, ()]:<EOL><INDENT>if param_name == '<STR_LIT>':<EOL><INDENT>param_default = _cleanse_time_partitioning(<EOL>destination_dataset_table, time_partitioning)<EOL><DEDENT>param = param_default<EOL><DEDENT>if param not in [None, {}, ()]:<EOL><INDENT>_api_resource_configs_duplication_check(<EOL>param_name, param, configuration['<STR_LIT>'])<EOL>configuration['<STR_LIT>'][param_name] = param<EOL>_validate_value(param_name, configuration['<STR_LIT>'][param_name],<EOL>param_type)<EOL>if param_name == '<STR_LIT>' and param:<EOL><INDENT>self.log.info(\"<STR_LIT>\"<EOL>\"<STR_LIT:%s>\", schema_update_options)<EOL><DEDENT>if param_name == '<STR_LIT>':<EOL><INDENT>for key in ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']:<EOL><INDENT>if key not in configuration['<STR_LIT>']['<STR_LIT>']:<EOL><INDENT>raise ValueError(<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT><DEDENT>configuration['<STR_LIT>'].update({<EOL>'<STR_LIT>': allow_large_results,<EOL>'<STR_LIT>': flatten_results,<EOL>'<STR_LIT>': write_disposition,<EOL>'<STR_LIT>': create_disposition,<EOL>})<EOL><DEDENT><DEDENT><DEDENT>if '<STR_LIT>' in configuration['<STR_LIT>'] and configuration['<STR_LIT>']['<STR_LIT>'] and'<STR_LIT>' in configuration['<STR_LIT>']:<EOL><INDENT>raise ValueError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>if labels:<EOL><INDENT>_api_resource_configs_duplication_check(<EOL>'<STR_LIT>', labels, configuration)<EOL>configuration['<STR_LIT>'] = labels<EOL><DEDENT>return self.run_with_configuration(configuration)<EOL>", "docstring": "Executes a BigQuery SQL query. Optionally persists results in a BigQuery\ntable. See here:\n\nhttps://cloud.google.com/bigquery/docs/reference/v2/jobs\n\nFor more details about these parameters.\n\n:param sql: The BigQuery SQL to execute.\n:type sql: str\n:param destination_dataset_table: The dotted ``<dataset>.<table>``\n    BigQuery table to save the query results.\n:type destination_dataset_table: str\n:param write_disposition: What to do if the table already exists in\n    BigQuery.\n:type write_disposition: str\n:param allow_large_results: Whether to allow large results.\n:type allow_large_results: bool\n:param flatten_results: If true and query uses legacy SQL dialect, flattens\n    all nested and repeated fields in the query results. ``allowLargeResults``\n    must be true if this is set to false. For standard SQL queries, this\n    flag is ignored and results are never flattened.\n:type flatten_results: bool\n:param udf_config: The User Defined Function configuration for the query.\n    See https://cloud.google.com/bigquery/user-defined-functions for details.\n:type udf_config: list\n:param use_legacy_sql: Whether to use legacy SQL (true) or standard SQL (false).\n    If `None`, defaults to `self.use_legacy_sql`.\n:type use_legacy_sql: bool\n:param api_resource_configs: a dictionary that contain params\n    'configuration' applied for Google BigQuery Jobs API:\n    https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs\n    for example, {'query': {'useQueryCache': False}}. You could use it\n    if you need to provide some params that are not supported by the\n    BigQueryHook like args.\n:type api_resource_configs: dict\n:param maximum_billing_tier: Positive integer that serves as a\n    multiplier of the basic price.\n:type maximum_billing_tier: int\n:param maximum_bytes_billed: Limits the bytes billed for this job.\n    Queries that will have bytes billed beyond this limit will fail\n    (without incurring a charge). If unspecified, this will be\n    set to your project default.\n:type maximum_bytes_billed: float\n:param create_disposition: Specifies whether the job is allowed to\n    create new tables.\n:type create_disposition: str\n:param query_params: a list of dictionary containing query parameter types and\n    values, passed to BigQuery\n:type query_params: list\n:param labels: a dictionary containing labels for the job/query,\n    passed to BigQuery\n:type labels: dict\n:param schema_update_options: Allows the schema of the destination\n    table to be updated as a side effect of the query job.\n:type schema_update_options: tuple\n:param priority: Specifies a priority for the query.\n    Possible values include INTERACTIVE and BATCH.\n    The default value is INTERACTIVE.\n:type priority: str\n:param time_partitioning: configure optional time partitioning fields i.e.\n    partition by field, type and expiration as per API specifications.\n:type time_partitioning: dict\n:param cluster_fields: Request that the result of this query be stored sorted\n    by one or more columns. This is only available in combination with\n    time_partitioning. The order of columns given determines the sort order.\n:type cluster_fields: list[str]\n:param location: The geographic location of the job. Required except for\n    US and EU. See details at\n    https://cloud.google.com/bigquery/docs/locations#specifying_your_location\n:type location: str", "id": "f9169:c3:m4"}
{"signature": "def _get_delay(self):", "body": "return self.__delay<EOL>", "docstring": "Getter method for delay, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/link_delay/state/delay (uint32)\n\n    YANG Description: Average link delay value (in microseconds) between two directly\nconnected IS-IS neighbors over a configurable interval.", "id": "f22870:c1:m8"}
{"signature": "def define_class(self, kind, attributes, doc='<STR_LIT>'):", "body": "ukind = kind.upper()<EOL>if ukind in self.metaclasses:<EOL><INDENT>raise MetaModelException('<STR_LIT>' % kind)<EOL><DEDENT>metaclass = MetaClass(kind, self)<EOL>for name, ty in attributes:<EOL><INDENT>metaclass.append_attribute(name, ty)<EOL><DEDENT>self.metaclasses[ukind] = metaclass<EOL>return metaclass<EOL>", "docstring": "Define a new class in the metamodel, and return its metaclass.", "id": "f14739:c16:m2"}
{"signature": "@log_calls<EOL><INDENT>def relative_dir_walk(self, dir):<DEDENT>", "body": "result = []<EOL>if S3URL.is_valid(dir):<EOL><INDENT>basepath = S3URL(dir).path<EOL>for f in (f for f in self.s3walk(dir) if not f['<STR_LIT>']):<EOL><INDENT>result.append(os.path.relpath(S3URL(f['<STR_LIT:name>']).path, basepath))<EOL><DEDENT><DEDENT>else:<EOL><INDENT>for f in (f for f in self.local_walk(dir) if not os.path.isdir(f)):<EOL><INDENT>result.append(os.path.relpath(f, dir))<EOL><DEDENT><DEDENT>return result<EOL>", "docstring": "Generic version of directory walk. Return file list without base path\n           for comparison.", "id": "f16741:c8:m23"}
{"signature": "@internal<EOL><INDENT>def domain_size(self):<DEDENT>", "body": "return int(<NUM_LIT:2> ** self.bit_length())<EOL>", "docstring": ":return: how many values can have specified type", "id": "f1275:c0:m3"}
{"signature": "def prepare(self, context):", "body": "<EOL>context.db[self.alias] = self.Session<EOL>", "docstring": "Prepare a sqlalchemy session on the WebCore context", "id": "f16295:c0:m3"}
{"signature": "def extract_images(f):", "body": "print('<STR_LIT>', f.name)<EOL>with gzip.GzipFile(fileobj=f) as bytestream:<EOL><INDENT>magic = _read32(bytestream)<EOL>if magic != <NUM_LIT>:<EOL><INDENT>raise ValueError(<EOL>'<STR_LIT>' %<EOL>(magic, f.name))<EOL><DEDENT>num_images = _read32(bytestream)<EOL>rows = _read32(bytestream)<EOL>cols = _read32(bytestream)<EOL>buf = bytestream.read(rows * cols * num_images)<EOL>data = numpy.frombuffer(buf, dtype=numpy.uint8)<EOL>data = data.reshape(num_images, rows, cols, <NUM_LIT:1>)<EOL>return data<EOL><DEDENT>", "docstring": "Extract the images into a 4D uint8 numpy array [index, y, x, depth].\n\n    :param: f: A file object that can be passed into a gzip reader.\n    :return: data: A 4D unit8 numpy array [index, y, x, depth].\n    :raise: ValueError: If the bytestream does not start with 2051.", "id": "f13227:m1"}
{"signature": "def get(<EOL>self, resource_group_name, circuit_name, authorization_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", circuit_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", authorization_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified authorization from the specified express route\n        circuit.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param authorization_name: The name of the authorization.\n        :type authorization_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ExpressRouteCircuitAuthorization or ClientRawResponse if\n         raw=true\n        :rtype:\n         ~azure.mgmt.network.v2018_02_01.models.ExpressRouteCircuitAuthorization\n         or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f35273:c0:m3"}
{"signature": "@property<EOL><INDENT>def split(self):<DEDENT>", "body": "return self._split<EOL>", "docstring": "Axis at which the array is split into keys/values.", "id": "f985:c0:m37"}
{"signature": "def delete_all_created_images(self):", "body": "self.delete_filtered_images()<EOL>self.delete_sized_images()<EOL>self.delete_filtered_sized_images()<EOL>", "docstring": "Delete all images created from `self.name`.", "id": "f3800:c0:m14"}
{"signature": "def set_entry(self, entry_name, key, value):", "body": "self.cache[entry_name][key] = value<EOL>", "docstring": "Replaces entire cache entry parameter data by its name with new data.\n\n        :param str|unicode entry_name:\n        :param key:\n        :param value:", "id": "f3745:c1:m7"}
{"signature": "def __get__(self, obj, cls=None):", "body": "if obj is None:<EOL><INDENT>return self<EOL><DEDENT>else:<EOL><INDENT>try:<EOL><INDENT>value = obj._trait_values[self.name]<EOL><DEDENT>except KeyError:<EOL><INDENT>if self.name in obj._trait_dyn_inits:<EOL><INDENT>value = obj._trait_dyn_inits[self.name](obj)<EOL>value = self._validate(obj, value)<EOL>obj._trait_values[self.name] = value<EOL>return value<EOL><DEDENT>else:<EOL><INDENT>raise TraitError('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT><DEDENT>except Exception:<EOL><INDENT>raise TraitError('<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>return value<EOL><DEDENT><DEDENT>", "docstring": "Get the value of the trait by self.name for the instance.\n\n        Default values are instantiated when :meth:`HasTraits.__new__`\n        is called.  Thus by the time this method gets called either the\n        default value or a user defined value (they called :meth:`__set__`)\n        is in the :class:`HasTraits` instance.", "id": "f21522:c4:m5"}
{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VpnGatewayPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VpnGatewayPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all the VpnGateways in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VpnGateway\n        :rtype:\n         ~azure.mgmt.network.v2018_06_01.models.VpnGatewayPaged[~azure.mgmt.network.v2018_06_01.models.VpnGateway]\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_06_01.models.ErrorException>`", "id": "f30933:c0:m9"}
{"signature": "def _get_name(self):", "body": "return self.__name<EOL>", "docstring": "Getter method for name, mapped from YANG variable /system/aaa/server_groups/server_group/config/name (string)\n\nYANG Description: Name for the server group", "id": "f21895:c0:m2"}
{"signature": "def on(self, analyte=None, filt=None):", "body": "if isinstance(analyte, str):<EOL><INDENT>analyte = [analyte]<EOL><DEDENT>if isinstance(filt, (int, float)):<EOL><INDENT>filt = [filt]<EOL><DEDENT>elif isinstance(filt, str):<EOL><INDENT>filt = self.fuzzmatch(filt, multi=True)<EOL><DEDENT>if analyte is None:<EOL><INDENT>analyte = self.analytes<EOL><DEDENT>if filt is None:<EOL><INDENT>filt = list(self.index.values())<EOL><DEDENT>for a in analyte:<EOL><INDENT>for f in filt:<EOL><INDENT>if isinstance(f, (int, float)):<EOL><INDENT>f = self.index[int(f)]<EOL><DEDENT>try:<EOL><INDENT>self.switches[a][f] = True<EOL><DEDENT>except KeyError:<EOL><INDENT>f = self.fuzzmatch(f, multi=False)<EOL>self.switches[a][f] = True<EOL><DEDENT><DEDENT><DEDENT>return<EOL>", "docstring": "Turn on specified filter(s) for specified analyte(s).\n\nParameters\n----------\nanalyte : optional, str or array_like\n    Name or list of names of analytes.\n    Defaults to all analytes.\nfilt : optional. int, str or array_like\n    Name/number or iterable names/numbers of filters.\n\nReturns\n-------\nNone", "id": "f2434:c0:m6"}
{"signature": "def _set_sid(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>False,<EOL>sid.sid,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT:False>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__sid = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for sid, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/adjacency_sid/sid (list)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_sid is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_sid() directly.\n\n    YANG Description: Adjacency Segment-IDs List. An IGP-Adjacency Segment is an IGP\nsegment attached to a unidirectional adjacency or a set of\nunidirectional adjacencies. By default, an IGP-Adjacency Segment is\nlocal to the node which advertises it.", "id": "f22833:c1:m3"}
{"signature": "def close(self):", "body": "pass<EOL>", "docstring": "BigQueryConnection does not have anything to close.", "id": "f9169:c2:m1"}
{"signature": "def _set_table(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT>\",<EOL>table.table,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__table = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for table, mapped from YANG variable /network_instances/network_instance/tables/table (list)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_table is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_table() directly.\n\n    YANG Description: A network instance manages one or more forwarding or\nrouting tables. These may reflect a Layer 2 forwarding\ninformation base, a Layer 3 routing table, or an MPLS\nLFIB.\n\nThe table populated by a protocol within an instance is\nidentified by the protocol identifier (e.g., BGP, IS-IS)\nand the address family (e.g., IPv4, IPv6) supported by\nthat protocol. Multiple instances of the same protocol\npopulate a single table -- such that\na single IS-IS or OSPF IPv4 table exists per network\ninstance.\n\nAn implementation is expected to create entries within\nthis list when the relevant protocol context is enabled.\ni.e., when a BGP instance is created with IPv4 and IPv6\naddress families enabled, the protocol=BGP,\naddress-family=IPv4 table is created by the system.", "id": "f22375:c0:m3"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, load_balancer_name, inbound_nat_rule_name, inbound_nat_rule_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>load_balancer_name=load_balancer_name,<EOL>inbound_nat_rule_name=inbound_nat_rule_name,<EOL>inbound_nat_rule_parameters=inbound_nat_rule_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a load balancer inbound nat rule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param load_balancer_name: The name of the load balancer.\n        :type load_balancer_name: str\n        :param inbound_nat_rule_name: The name of the inbound nat rule.\n        :type inbound_nat_rule_name: str\n        :param inbound_nat_rule_parameters: Parameters supplied to the create\n         or update inbound nat rule operation.\n        :type inbound_nat_rule_parameters:\n         ~azure.mgmt.network.v2018_04_01.models.InboundNatRule\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns InboundNatRule or\n         ClientRawResponse<InboundNatRule> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_04_01.models.InboundNatRule]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_04_01.models.InboundNatRule]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33793:c0:m6"}
{"signature": "def cpu_percent(interval=<NUM_LIT:0.1>, percpu=False):", "body": "global _last_cpu_times<EOL>global _last_per_cpu_times<EOL>blocking = interval is not None and interval > <NUM_LIT:0.0><EOL>def calculate(t1, t2):<EOL><INDENT>t1_all = sum(t1)<EOL>t1_busy = t1_all - t1.idle<EOL>t2_all = sum(t2)<EOL>t2_busy = t2_all - t2.idle<EOL>if t2_busy <= t1_busy:<EOL><INDENT>return <NUM_LIT:0.0><EOL><DEDENT>busy_delta = t2_busy - t1_busy<EOL>all_delta = t2_all - t1_all<EOL>busy_perc = (busy_delta / all_delta) * <NUM_LIT:100><EOL>return round(busy_perc, <NUM_LIT:1>)<EOL><DEDENT>if not percpu:<EOL><INDENT>if blocking:<EOL><INDENT>t1 = cpu_times()<EOL>time.sleep(interval)<EOL><DEDENT>else:<EOL><INDENT>t1 = _last_cpu_times<EOL><DEDENT>_last_cpu_times = cpu_times()<EOL>return calculate(t1, _last_cpu_times)<EOL><DEDENT>else:<EOL><INDENT>ret = []<EOL>if blocking:<EOL><INDENT>tot1 = cpu_times(percpu=True)<EOL>time.sleep(interval)<EOL><DEDENT>else:<EOL><INDENT>tot1 = _last_per_cpu_times<EOL><DEDENT>_last_per_cpu_times = cpu_times(percpu=True)<EOL>for t1, t2 in zip(tot1, _last_per_cpu_times):<EOL><INDENT>ret.append(calculate(t1, t2))<EOL><DEDENT>return ret<EOL><DEDENT>", "docstring": "Return a float representing the current system-wide CPU\n    utilization as a percentage.\n\n    When interval is > 0.0 compares system CPU times elapsed before\n    and after the interval (blocking).\n\n    When interval is 0.0 or None compares system CPU times elapsed\n    since last call or module import, returning immediately.\n    In this case is recommended for accuracy that this function be\n    called with at least 0.1 seconds between calls.\n\n    When percpu is True returns a list of floats representing the\n    utilization as a percentage for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.", "id": "f21312:m2"}
{"signature": "def atomize(f, lock=None):", "body": "lock = lock or threading.RLock()<EOL>@functools.wraps(f)<EOL>def exec_atomic(*args, **kwargs):<EOL><INDENT>lock.acquire()<EOL>try:<EOL><INDENT>return f(*args, **kwargs)<EOL><DEDENT>finally:<EOL><INDENT>lock.release()<EOL><DEDENT><DEDENT>return exec_atomic<EOL>", "docstring": "Decorate a function with a reentrant lock to prevent multiple\nthreads from calling said thread simultaneously.", "id": "f14582:m0"}
{"signature": "def start(<EOL>self, resource_group_name, profile_name, endpoint_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._start_initial(<EOL>resource_group_name=resource_group_name,<EOL>profile_name=profile_name,<EOL>endpoint_name=endpoint_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Starts an existing CDN endpoint that is on a stopped state.\n\n        :param resource_group_name: Name of the Resource group within the\n         Azure subscription.\n        :type resource_group_name: str\n        :param profile_name: Name of the CDN profile which is unique within\n         the resource group.\n        :type profile_name: str\n        :param endpoint_name: Name of the endpoint under the profile which is\n         unique globally.\n        :type endpoint_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns Endpoint or\n         ClientRawResponse<Endpoint> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.cdn.models.Endpoint]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.cdn.models.Endpoint]]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.cdn.models.ErrorResponseException>`", "id": "f40938:c0:m10"}
{"signature": "@pointfree<EOL>def pfprint_all(iterable, end='<STR_LIT:\\n>', file=None):", "body": "for item in iterable:<EOL><INDENT>pfprint(item, end=end, file=file)<EOL><DEDENT>", "docstring": "Prints each item from an iterable.\n\n    :param iterable: An iterable yielding values to print\n    :param end: String to append to the end of printed output\n    :param file: File to which output is printed\n    :rtype: None\n\n    Example::\n\n        >>> @pointfree\n        ... def prefix_all(prefix, iterable):\n        ...     for item in iterable:\n        ...         yield \"%s%s\" % (prefix, item)\n\n        >>> fn = prefix_all(\"An item: \") >> pfprint_all\n\n        >>> fn([\"foo\", \"bar\", \"baz\"])\n        An item: foo\n        An item: bar\n        An item: baz", "id": "f5604:m5"}
{"signature": "def get(<EOL>self, resource_group_name, profile_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", profile_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a CDN profile with the specified profile name under the specified\n        subscription and resource group.\n\n        :param resource_group_name: Name of the Resource group within the\n         Azure subscription.\n        :type resource_group_name: str\n        :param profile_name: Name of the CDN profile which is unique within\n         the resource group.\n        :type profile_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Profile or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.cdn.models.Profile or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.cdn.models.ErrorResponseException>`", "id": "f40944:c0:m3"}
{"signature": "def _set_dataplane_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={\"<STR_LIT>\": {}, \"<STR_LIT>\": {}},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__dataplane_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for dataplane_type, mapped from YANG variable /network_instances/network_instance/segment_routing/srlbs/srlb/state/dataplane_type (sr-dataplane-type)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_dataplane_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_dataplane_type() directly.\n\n    YANG Description: The dataplane that is to be used for the Segment Routing Local Block.\nWhen MPLS is specified, the local block corresponds to a block of MPLS\nlabels; when IPv6 is specified it corresponds to an IPv6 prefix.", "id": "f22364:c1:m6"}
{"signature": "def _handle_stranded_msgs(self, eid, uuid):", "body": "outstanding = self.queues[eid]<EOL>for msg_id in outstanding:<EOL><INDENT>self.pending.remove(msg_id)<EOL>self.all_completed.add(msg_id)<EOL>try:<EOL><INDENT>raise error.EngineError(\"<STR_LIT>\" % (eid, msg_id))<EOL><DEDENT>except:<EOL><INDENT>content = error.wrap_exception()<EOL><DEDENT>header = {}<EOL>header['<STR_LIT>'] = uuid<EOL>header['<STR_LIT:date>'] = datetime.now()<EOL>rec = dict(result_content=content, result_header=header, result_buffers=[])<EOL>rec['<STR_LIT>'] = header['<STR_LIT:date>']<EOL>rec['<STR_LIT>'] = uuid<EOL>try:<EOL><INDENT>self.db.update_record(msg_id, rec)<EOL><DEDENT>except Exception:<EOL><INDENT>self.log.error(\"<STR_LIT>\", msg_id, exc_info=True)<EOL><DEDENT><DEDENT>", "docstring": "Handle messages known to be on an engine when the engine unregisters.\n\n        It is possible that this will fire prematurely - that is, an engine will\n        go down after completing a result, and the client will be notified\n        that the result failed and later receive the actual result.", "id": "f21689:c2:m18"}
{"signature": "def templates(args, template_name=None):", "body": "from sregistry.main import get_client<EOL>cli = get_client(init=False)<EOL>if len(args.commands) > <NUM_LIT:0>:<EOL><INDENT>template_name = args.commands.pop(<NUM_LIT:0>)<EOL><DEDENT>cli.list_templates(template_name)<EOL>sys.exit(<NUM_LIT:0>)<EOL>", "docstring": "list a specific template (if a name is provided) or all templates\n       available.\n\n       Parameters\n       ==========\n       args: the argparse object to look for a template name\n       template_name: if not set, show all", "id": "f9876:m4"}
{"signature": "def expandvars(path):", "body": "if '<STR_LIT:$>' not in path and '<STR_LIT:%>' not in path:<EOL><INDENT>return path<EOL><DEDENT>import string<EOL>varchars = string.ascii_letters + string.digits + '<STR_LIT>'<EOL>if isinstance(path, _unicode):<EOL><INDENT>encoding = sys.getfilesystemencoding()<EOL>def getenv(var):<EOL><INDENT>return os.environ[var.encode(encoding)].decode(encoding)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>def getenv(var):<EOL><INDENT>return os.environ[var]<EOL><DEDENT><DEDENT>res = '<STR_LIT>'<EOL>index = <NUM_LIT:0><EOL>pathlen = len(path)<EOL>while index < pathlen:<EOL><INDENT>c = path[index]<EOL>if c == '<STR_LIT>':   <EOL><INDENT>path = path[index + <NUM_LIT:1>:]<EOL>pathlen = len(path)<EOL>try:<EOL><INDENT>index = path.index('<STR_LIT>')<EOL>res = res + '<STR_LIT>' + path[:index + <NUM_LIT:1>]<EOL><DEDENT>except ValueError:<EOL><INDENT>res = res + c + path<EOL>index = pathlen - <NUM_LIT:1><EOL><DEDENT><DEDENT>elif c == '<STR_LIT:%>':  <EOL><INDENT>if path[index + <NUM_LIT:1>:index + <NUM_LIT:2>] == '<STR_LIT:%>':<EOL><INDENT>res = res + c<EOL>index = index + <NUM_LIT:1><EOL><DEDENT>else:<EOL><INDENT>path = path[index+<NUM_LIT:1>:]<EOL>pathlen = len(path)<EOL>try:<EOL><INDENT>index = path.index('<STR_LIT:%>')<EOL><DEDENT>except ValueError:<EOL><INDENT>res = res + '<STR_LIT:%>' + path<EOL>index = pathlen - <NUM_LIT:1><EOL><DEDENT>else:<EOL><INDENT>var = path[:index]<EOL>try:<EOL><INDENT>res = res + getenv(var)<EOL><DEDENT>except KeyError:<EOL><INDENT>res = res + '<STR_LIT:%>' + var + '<STR_LIT:%>'<EOL><DEDENT><DEDENT><DEDENT><DEDENT>elif c == '<STR_LIT:$>':  <EOL><INDENT>if path[index + <NUM_LIT:1>:index + <NUM_LIT:2>] == '<STR_LIT:$>':<EOL><INDENT>res = res + c<EOL>index = index + <NUM_LIT:1><EOL><DEDENT>elif path[index + <NUM_LIT:1>:index + <NUM_LIT:2>] == '<STR_LIT:{>':<EOL><INDENT>path = path[index+<NUM_LIT:2>:]<EOL>pathlen = len(path)<EOL>try:<EOL><INDENT>index = path.index('<STR_LIT:}>')<EOL>var = path[:index]<EOL>try:<EOL><INDENT>res = res + getenv(var)<EOL><DEDENT>except KeyError:<EOL><INDENT>res = res + '<STR_LIT>' + var + '<STR_LIT:}>'<EOL><DEDENT><DEDENT>except ValueError:<EOL><INDENT>res = res + '<STR_LIT>' + path<EOL>index = pathlen - <NUM_LIT:1><EOL><DEDENT><DEDENT>else:<EOL><INDENT>var = '<STR_LIT>'<EOL>index = index + <NUM_LIT:1><EOL>c = path[index:index + <NUM_LIT:1>]<EOL>while c != '<STR_LIT>' and c in varchars:<EOL><INDENT>var = var + c<EOL>index = index + <NUM_LIT:1><EOL>c = path[index:index + <NUM_LIT:1>]<EOL><DEDENT>try:<EOL><INDENT>res = res + getenv(var)<EOL><DEDENT>except KeyError:<EOL><INDENT>res = res + '<STR_LIT:$>' + var<EOL><DEDENT>if c != '<STR_LIT>':<EOL><INDENT>index = index - <NUM_LIT:1><EOL><DEDENT><DEDENT><DEDENT>else:<EOL><INDENT>res = res + c<EOL><DEDENT>index = index + <NUM_LIT:1><EOL><DEDENT>return res<EOL>", "docstring": "Expand shell variables of the forms $var, ${var} and %var%.\n\n    Unknown variables are left unchanged.", "id": "f17316:m13"}
{"signature": "def inc_convert(self, value):", "body": "if not os.path.isabs(value):<EOL><INDENT>value = os.path.join(self.base, value)<EOL><DEDENT>with codecs.open(value, '<STR_LIT:r>', encoding='<STR_LIT:utf-8>') as f:<EOL><INDENT>result = json.load(f)<EOL><DEDENT>return result<EOL>", "docstring": "Default converter for the inc:// protocol.", "id": "f17267:c16:m3"}
{"signature": "def create_dummy_user(self):", "body": "username = '<STR_LIT>'<EOL>email = '<STR_LIT>'<EOL>user = User.objects.create_user(username, email, '<STR_LIT>')<EOL>return (user, username, email)<EOL>", "docstring": "Create a user and return a tuple (user_object, username, email).", "id": "f20642:c7:m1"}
{"signature": "def read_bit(self, bit_num, address):", "body": "value = self.read(address)<EOL>bit_mask = get_bit_mask(bit_num)<EOL>return <NUM_LIT:1> if value & bit_mask else <NUM_LIT:0><EOL>", "docstring": "Returns the bit specified from the address.\n\n        :param bit_num: The bit number to read from.\n        :type bit_num: int\n        :param address: The address to read from.\n        :type address: int\n        :returns: int -- the bit value from the address", "id": "f12579:c0:m8"}
{"signature": "def create_shared_data(self, name=None, **kwargs):", "body": "if name is None:<EOL><INDENT>item = self.f_get()<EOL><DEDENT>else:<EOL><INDENT>item = self.f_get(name)<EOL><DEDENT>return item.create_shared_data(**kwargs)<EOL>", "docstring": "Calls the corresponding function of the shared data item", "id": "f4215:c8:m6"}
{"signature": "def list(<EOL>self, resource_group_name, load_balancer_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", load_balancer_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.BackendAddressPoolPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.BackendAddressPoolPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the load balancer backed address pools.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param load_balancer_name: The name of the load balancer.\n        :type load_balancer_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of BackendAddressPool\n        :rtype:\n         ~azure.mgmt.network.v2018_06_01.models.BackendAddressPoolPaged[~azure.mgmt.network.v2018_06_01.models.BackendAddressPool]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30915:c0:m1"}
{"signature": "def get(<EOL>self, resource_group_name, rule_name, incident_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", rule_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", incident_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets an incident associated to an alert rule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param rule_name: The name of the rule.\n        :type rule_name: str\n        :param incident_name: The name of the incident to retrieve.\n        :type incident_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Incident or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.monitor.models.Incident or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.monitor.models.ErrorResponseException>`", "id": "f36327:c0:m1"}
{"signature": "@vaex.utils.deprecated('<STR_LIT>')<EOL><INDENT>@_hidden<EOL>def __call__(self, *expressions, **kwargs):<DEDENT>", "body": "raise NotImplementedError<EOL>", "docstring": "Alias/shortcut for :func:`DataFrame.subspace`", "id": "f6914:c0:m87"}
{"signature": "def player_stats_per_game(self):", "body": "return self._get_player_stats_table('<STR_LIT>')<EOL>", "docstring": "Returns a DataFrame of per-game player stats for a season.", "id": "f8179:c0:m23"}
{"signature": "def newnews(self, pattern, timestamp):", "body": "return [x for x in self.newnews_gen(pattern, timestamp)]<EOL>", "docstring": "NEWNEWS command.\n\n        Retrieves a list of message-ids for articles created since the specified\n        timestamp for newsgroups with names that match the given pattern. See\n        newnews_gen() for more details.\n\n        See <http://tools.ietf.org/html/rfc3977#section-7.4>\n\n        Args:\n            pattern: Glob matching newsgroups of intrest.\n            timestamp: Datetime object giving 'created since' datetime.\n\n        Returns:\n            A list of message-ids as given by newnews_gen()", "id": "f14598:c8:m9"}
{"signature": "def _instantiate_client(client_class, **kwargs):", "body": "args = get_arg_spec(client_class.__init__).args<EOL>for key in ['<STR_LIT>', '<STR_LIT>']:<EOL><INDENT>if key not in kwargs:<EOL><INDENT>continue<EOL><DEDENT>if key not in args:<EOL><INDENT>del kwargs[key]<EOL><DEDENT>elif sys.version_info < (<NUM_LIT:3>, <NUM_LIT:0>) and isinstance(kwargs[key], unicode):<EOL><INDENT>kwargs[key] = kwargs[key].encode('<STR_LIT:utf-8>')<EOL><DEDENT><DEDENT>return client_class(**kwargs)<EOL>", "docstring": "Instantiate a client from kwargs, removing the subscription_id/tenant_id argument if unsupported.", "id": "f39602:m0"}
{"signature": "def generator_fp1(seq):", "body": "for val in seq:<EOL><INDENT>pass<EOL><DEDENT>for val in seq:<EOL><INDENT>yield val<EOL><DEDENT>", "docstring": "W0631 false positive", "id": "f18737:m1"}
{"signature": "def _set_affiliation(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=unicode,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>u\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>},<EOL>u\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>},<EOL>u\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>},<EOL>u\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>},<EOL>u\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>},<EOL>u\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>\"<STR_LIT>\": u\"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__affiliation = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for affiliation, mapped from YANG variable /universe/individual/affiliation (identityref)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_affiliation is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_affiliation() directly.", "id": "f23491:c0:m9"}
{"signature": "def _get_boot_time():", "body": "f = open('<STR_LIT>', '<STR_LIT:r>')<EOL>try:<EOL><INDENT>for line in f:<EOL><INDENT>if line.startswith('<STR_LIT>'):<EOL><INDENT>return float(line.strip().split()[<NUM_LIT:1>])<EOL><DEDENT><DEDENT>raise RuntimeError(\"<STR_LIT>\")<EOL><DEDENT>finally:<EOL><INDENT>f.close()<EOL><DEDENT>", "docstring": "Return system boot time (epoch in seconds)", "id": "f21313:m0"}
{"signature": "def unit_client(self):<EOL>", "body": "client = TCPClient(self.host, self.port, self.prefix)<EOL>self._configure_client(client)<EOL>return client<EOL>", "docstring": "Return a TCPClient with same settings of the batch TCP client", "id": "f16500:c1:m2"}
{"signature": "def ceiling_division(numerator, denominator):", "body": "<EOL>return -(-numerator // denominator)<EOL>", "docstring": "Divide and round up", "id": "f5945:m3"}
{"signature": "def _set_shutdown_threshold_pct(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__shutdown_threshold_pct = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for shutdown_threshold_pct, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/state/shutdown_threshold_pct (oc-types:percentage)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_shutdown_threshold_pct is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_shutdown_threshold_pct() directly.\n\n    YANG Description: Threshold on number of prefixes that can be received\nfrom a neighbour before generation of warning messages\nor log entries. Expressed as a percentage of\nmax-prefixes", "id": "f23397:c0:m9"}
{"signature": "def chebmulx(c):", "body": "<EOL>[c] = pu.as_series([c])<EOL>if len(c) == <NUM_LIT:1> and c[<NUM_LIT:0>] == <NUM_LIT:0>:<EOL><INDENT>return c<EOL><DEDENT>prd = np.empty(len(c) + <NUM_LIT:1>, dtype=c.dtype)<EOL>prd[<NUM_LIT:0>] = c[<NUM_LIT:0>]*<NUM_LIT:0><EOL>prd[<NUM_LIT:1>] = c[<NUM_LIT:0>]<EOL>if len(c) > <NUM_LIT:1>:<EOL><INDENT>tmp = c[<NUM_LIT:1>:]/<NUM_LIT:2><EOL>prd[<NUM_LIT:2>:] = tmp<EOL>prd[<NUM_LIT:0>:-<NUM_LIT:2>] += tmp<EOL><DEDENT>return prd<EOL>", "docstring": "Multiply a Chebyshev series by x.\n\n    Multiply the polynomial `c` by x, where x is the independent\n    variable.\n\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array of Chebyshev series coefficients ordered from low to\n        high.\n\n    Returns\n    -------\n    out : ndarray\n        Array representing the result of the multiplication.\n\n    Notes\n    -----\n\n    .. versionadded:: 1.5.0", "id": "f18918:m12"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ibgp/state (container)\n\nYANG Description: State information relating to iBGP multipath", "id": "f23423:c0:m5"}
{"signature": "def list_arp_table(<EOL>self, resource_group_name, circuit_name, peering_name, device_path, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._list_arp_table_initial(<EOL>resource_group_name=resource_group_name,<EOL>circuit_name=circuit_name,<EOL>peering_name=peering_name,<EOL>device_path=device_path,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Gets the currently advertised ARP table associated with the express\n        route circuit in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param peering_name: The name of the peering.\n        :type peering_name: str\n        :param device_path: The path of the device.\n        :type device_path: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         ExpressRouteCircuitsArpTableListResult or\n         ClientRawResponse<ExpressRouteCircuitsArpTableListResult> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2016_09_01.models.ExpressRouteCircuitsArpTableListResult]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2016_09_01.models.ExpressRouteCircuitsArpTableListResult]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30537:c0:m7"}
{"signature": "def _check_proper_bases(self, node):", "body": "for base in node.bases:<EOL><INDENT>ancestor = safe_infer(base)<EOL>if ancestor in (astroid.Uninferable, None):<EOL><INDENT>continue<EOL><DEDENT>if isinstance(ancestor, astroid.Instance) and ancestor.is_subtype_of(<EOL>\"<STR_LIT>\" % (BUILTINS,)<EOL>):<EOL><INDENT>continue<EOL><DEDENT>if not isinstance(ancestor, astroid.ClassDef) or _is_invalid_base_class(<EOL>ancestor<EOL>):<EOL><INDENT>self.add_message(\"<STR_LIT>\", args=base.as_string(), node=node)<EOL><DEDENT>if ancestor.name == object.__name__:<EOL><INDENT>self.add_message(<EOL>\"<STR_LIT>\", args=node.name, node=node<EOL>)<EOL><DEDENT><DEDENT>", "docstring": "Detect that a class inherits something which is not\na class or a type.", "id": "f18870:c1:m5"}
{"signature": "@neural_computation<EOL><INDENT>def iftrain(self, then_branch, else_branch):<DEDENT>", "body": "return ifelse(self._training_flag, then_branch, else_branch, name=\"<STR_LIT>\")<EOL>", "docstring": "Execute `then_branch` when training.", "id": "f6179:c0:m1"}
{"signature": "def stop_network_trace(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.stop_network_trace.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Stop ongoing capturing network packets for the site.\n\n        Stop ongoing capturing network packets for the site.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: The name of the web app.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44988:c0:m360"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/config (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_config is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_config() directly.\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23410:c1:m3"}
{"signature": "def regenerate_key(<EOL>self, resource_group_name, account_name, key_name, custom_headers=None, raw=False, **operation_config):", "body": "regenerate_key1 = models.StorageAccountRegenerateKeyParameters(key_name=key_name)<EOL>url = self.regenerate_key.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:3>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(regenerate_key1, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Regenerates one of the access keys for the specified storage account.\n\n        :param resource_group_name: The name of the resource group within the\n         user's subscription.\n        :type resource_group_name: str\n        :param account_name: The name of the storage account within the\n         specified resource group. Storage account names must be between 3 and\n         24 characters in length and use numbers and lower-case letters only.\n        :type account_name: str\n        :param key_name:\n        :type key_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: StorageAccountListKeysResult or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.storage.v2016_01_01.models.StorageAccountListKeysResult or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f41612:c0:m10"}
{"signature": "@overrides<EOL><INDENT>def gen_batches(self, batch_size: int, shuffle: bool = None)-> Generator[Tuple[List[str], List[int]], Any, None]:<DEDENT>", "body": "if shuffle is None:<EOL><INDENT>shuffle = self.shuffle<EOL><DEDENT>if shuffle:<EOL><INDENT>_doc_ids = self.random.sample(self.doc_ids, len(self.doc_ids))<EOL><DEDENT>else:<EOL><INDENT>_doc_ids = self.doc_ids<EOL><DEDENT>if batch_size > <NUM_LIT:0>:<EOL><INDENT>batches = [_doc_ids[i:i + batch_size] for i in<EOL>range(<NUM_LIT:0>, len(_doc_ids), batch_size)]<EOL><DEDENT>else:<EOL><INDENT>batches = [_doc_ids]<EOL><DEDENT>for i, doc_ids in enumerate(batches):<EOL><INDENT>docs = [self.get_doc_content(doc_id) for doc_id in doc_ids]<EOL>doc_nums = [self.doc2index[doc_id] for doc_id in doc_ids]<EOL>yield docs, zip(doc_ids, doc_nums)<EOL><DEDENT>", "docstring": "Gen batches of documents.\n\n        Args:\n            batch_size: a number of samples in a single batch\n            shuffle: whether to shuffle data during batching\n\n        Yields:\n            generated tuple of documents and their ids", "id": "f3203:c0:m5"}
{"signature": "@property<EOL><INDENT>def has_value(self):<DEDENT>", "body": "return self._value is not None<EOL>", "docstring": "get whether has value or not.", "id": "f659:c0:m1"}
{"signature": "def blackmanharris(M, sym=True):", "body": "if M < <NUM_LIT:1>:<EOL><INDENT>return np.array([])<EOL><DEDENT>if M == <NUM_LIT:1>:<EOL><INDENT>return np.ones(<NUM_LIT:1>, '<STR_LIT:d>')<EOL><DEDENT>odd = M % <NUM_LIT:2><EOL>if not sym and not odd:<EOL><INDENT>M = M + <NUM_LIT:1><EOL><DEDENT>a = [<NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>]<EOL>n = np.arange(<NUM_LIT:0>, M)<EOL>fac = n * <NUM_LIT:2> * np.pi / (M - <NUM_LIT:1.0>)<EOL>w = (a[<NUM_LIT:0>] - a[<NUM_LIT:1>] * np.cos(fac) +<EOL>a[<NUM_LIT:2>] * np.cos(<NUM_LIT:2> * fac) - a[<NUM_LIT:3>] * np.cos(<NUM_LIT:3> * fac))<EOL>if not sym and not odd:<EOL><INDENT>w = w[:-<NUM_LIT:1>]<EOL><DEDENT>return w<EOL>", "docstring": "Return a minimum 4-term Blackman-Harris window.\n\n    Parameters\n    ----------\n    M : int\n        Number of points in the output window. If zero or less, an empty\n        array is returned.\n    sym : bool, optional\n        When True (default), generates a symmetric window, for use in filter\n        design.\n        When False, generates a periodic window, for use in spectral analysis.\n\n    Returns\n    -------\n    w : ndarray\n        The window, with the maximum value normalized to 1 (though the value 1\n        does not appear if `M` is even and `sym` is True).\n\n    Examples\n    --------\n    Plot the window and its frequency response:\n\n    >>> from scipy import signal\n    >>> from scipy.fftpack import fft, fftshift\n    >>> import matplotlib.pyplot as plt\n\n    >>> window = signal.blackmanharris(51)\n    >>> plt.plot(window)\n    >>> plt.title(\"Blackman-Harris window\")\n    >>> plt.ylabel(\"Amplitude\")\n    >>> plt.xlabel(\"Sample\")\n\n    >>> plt.figure()\n    >>> A = fft(window, 2048) / (len(window)/2.0)\n    >>> freq = np.linspace(-0.5, 0.5, len(A))\n    >>> response = 20 * np.log10(np.abs(fftshift(A / abs(A).max())))\n    >>> plt.plot(freq, response)\n    >>> plt.axis([-0.5, 0.5, -120, 0])\n    >>> plt.title(\"Frequency response of the Blackman-Harris window\")\n    >>> plt.ylabel(\"Normalized magnitude [dB]\")\n    >>> plt.xlabel(\"Normalized frequency [cycles per sample]\")", "id": "f19256:m6"}
{"signature": "def delete(<EOL>self, resource_group_name, availability_set_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", availability_set_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Delete an availability set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param availability_set_name: The name of the availability set.\n        :type availability_set_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25746:c0:m3"}
{"signature": "def _get_metric(self):", "body": "return self.__metric<EOL>", "docstring": "Getter method for metric, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/neighbors/neighbor/config/metric (oc-ospf-types:ospf-metric)\n\n    YANG Description: The metric that should be considered to the remote neighbor\nover this interface. This configuration is only applicable\nfor multiple-access networks", "id": "f23105:c1:m5"}
{"signature": "def power_off(<EOL>self, resource_group_name, vm_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._power_off_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "The operation to power off (stop) a virtual machine. The virtual\n        machine can be restarted with the same provisioned resources. You are\n        still charged for this virtual machine.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns OperationStatusResponse\n         or ClientRawResponse<OperationStatusResponse> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2016_04_30_preview.models.OperationStatusResponse]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2016_04_30_preview.models.OperationStatusResponse]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25117:c0:m18"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>name=name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Create or update a VM scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param name: The name of the VM scale set to create or update.\n        :type name: str\n        :param parameters: The scale set object.\n        :type parameters:\n         ~azure.mgmt.compute.v2016_04_30_preview.models.VirtualMachineScaleSet\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns VirtualMachineScaleSet\n         or ClientRawResponse<VirtualMachineScaleSet> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2016_04_30_preview.models.VirtualMachineScaleSet]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2016_04_30_preview.models.VirtualMachineScaleSet]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25125:c0:m2"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv4_external_reachability/prefixes/prefixes/default_metric/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters for default-metric.", "id": "f22551:c0:m3"}
{"signature": "def _enable_autopx(self):", "body": "<EOL>self._original_run_cell = self.shell.run_cell<EOL>self.shell.run_cell = self.pxrun_cell<EOL>self._autopx = True<EOL>print(\"<STR_LIT>\")<EOL>", "docstring": "Enable %autopx mode by saving the original run_cell and installing\n        pxrun_cell.", "id": "f21694:c0:m8"}
{"signature": "def data(self):  ", "body": "if isinstance(self.data_to_print, list):<EOL><INDENT>to_print = {}<EOL>to_print_size = []<EOL>alone_cases = [\"<STR_LIT>\", \"<STR_LIT>\"]<EOL>without_header = [\"<STR_LIT>\", \"<STR_LIT>\"]<EOL>if self.template.lower() == \"<STR_LIT>\":<EOL><INDENT>if not PyFunceble.CONFIGURATION[\"<STR_LIT>\"] and self.output:<EOL><INDENT>return self._json_print()<EOL><DEDENT>return None<EOL><DEDENT>if self.template not in alone_cases and self.template not in without_header:<EOL><INDENT>self.header(True)<EOL>to_print_size = self._size_from_header(self.currently_used_header)<EOL><DEDENT>elif self.template in without_header:<EOL><INDENT>for data in self.data_to_print:<EOL><INDENT>to_print_size.append(str(len(data)))<EOL><DEDENT><DEDENT>else:<EOL><INDENT>to_print_size = self._size_from_header(self.headers[self.template])<EOL><DEDENT>to_print = self._data_constructor(to_print_size)<EOL>self._before_header()<EOL>for data in self._header_constructor(to_print, False):<EOL><INDENT>if self.template.lower() in PyFunceble.STATUS[\"<STR_LIT:list>\"][<EOL>\"<STR_LIT>\"<EOL>] or self.template in [\"<STR_LIT>\", \"<STR_LIT>\"]:<EOL><INDENT>if not self.only_on_file:<EOL><INDENT>colorified_data = self._colorify(data)<EOL>print(colorified_data)<EOL><DEDENT><DEDENT>if not PyFunceble.CONFIGURATION[\"<STR_LIT>\"] and self.output:<EOL><INDENT>File(self.output).write(data + \"<STR_LIT:\\n>\")<EOL><DEDENT><DEDENT><DEDENT>else:<EOL><INDENT>raise Exception(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Management and input of data to the table.\n\n:raises:\n    :code:`Exception`\n        When self.data_to_print is not a list.", "id": "f8228:c0:m8"}
{"signature": "def _get_player_stats(self, table_id_fmt):", "body": "<EOL>doc = self.get_main_doc()<EOL>tms = self.away(), self.home()<EOL>tm_ids = [table_id_fmt.format(tm) for tm in tms]<EOL>tables = [doc('<STR_LIT>'.format(tm_id).lower()) for tm_id in tm_ids]<EOL>dfs = [sportsref.utils.parse_table(table) for table in tables]<EOL>for i, (tm, df) in enumerate(zip(tms, dfs)):<EOL><INDENT>no_time = df['<STR_LIT>'] == <NUM_LIT:0><EOL>stat_cols = [col for col, dtype in df.dtypes.items()<EOL>if dtype != '<STR_LIT:object>']<EOL>df.loc[no_time, stat_cols] = <NUM_LIT:0><EOL>df['<STR_LIT>'] = tm<EOL>df['<STR_LIT>'] = i == <NUM_LIT:1><EOL>df['<STR_LIT>'] = [p < <NUM_LIT:5> for p in range(df.shape[<NUM_LIT:0>])]<EOL>df.drop_duplicates(subset='<STR_LIT>', keep='<STR_LIT>', inplace=True)<EOL><DEDENT>return pd.concat(dfs)<EOL>", "docstring": "Returns a DataFrame of player stats from the game (either basic or\n        advanced, depending on the argument.\n\n        :param table_id_fmt: Format string for str.format with a placeholder\n            for the team ID (e.g. 'box_{}_basic')\n        :returns: DataFrame of player stats", "id": "f8181:c0:m15"}
{"signature": "@manager.command<EOL>def build():", "body": "os.system('<STR_LIT>')<EOL>os.chdir('<STR_LIT>')<EOL>os.system('<STR_LIT>')<EOL>", "docstring": "Use FIS to compile assets.", "id": "f7097:m2"}
{"signature": "def update(<EOL>self, resource_group_name, private_zone_name, record_type, relative_record_set_name, parameters, if_match=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.update.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", private_zone_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", record_type, '<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", relative_record_set_name, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if if_match is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", if_match, '<STR_LIT:str>')<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.patch(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Updates a record set within a Private DNS zone.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param private_zone_name: The name of the Private DNS zone (without a\n         terminating dot).\n        :type private_zone_name: str\n        :param record_type: The type of DNS record in this record set.\n         Possible values include: 'A', 'AAAA', 'CNAME', 'MX', 'PTR', 'SOA',\n         'SRV', 'TXT'\n        :type record_type: str or ~azure.mgmt.privatedns.models.RecordType\n        :param relative_record_set_name: The name of the record set, relative\n         to the name of the zone.\n        :type relative_record_set_name: str\n        :param parameters: Parameters supplied to the Update operation.\n        :type parameters: ~azure.mgmt.privatedns.models.RecordSet\n        :param if_match: The ETag of the record set. Omit this value to always\n         overwrite the current record set. Specify the last-seen ETag value to\n         prevent accidentally overwriting concurrent changes.\n        :type if_match: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: RecordSet or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.privatedns.models.RecordSet or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38585:c0:m2"}
{"signature": "def check_existence(<EOL>self, resource_group_name, resource_provider_namespace, parent_resource_path, resource_type, resource_name, api_version, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.check_existence.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_provider_namespace, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", parent_resource_path, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_type, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.head(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = (response.status_code == <NUM_LIT>)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Checks whether a resource exists.\n\n        :param resource_group_name: The name of the resource group containing\n         the resource to check. The name is case insensitive.\n        :type resource_group_name: str\n        :param resource_provider_namespace: The resource provider of the\n         resource to check.\n        :type resource_provider_namespace: str\n        :param parent_resource_path: The parent resource identity.\n        :type parent_resource_path: str\n        :param resource_type: The resource type.\n        :type resource_type: str\n        :param resource_name: The name of the resource to check whether it\n         exists.\n        :type resource_name: str\n        :param api_version: The API version to use for the operation.\n        :type api_version: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: bool or ClientRawResponse if raw=true\n        :rtype: bool or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37611:c0:m4"}
{"signature": "def deregister_host():", "body": "pyblish.api.deregister_host(\"<STR_LIT>\")<EOL>pyblish.api.deregister_host(\"<STR_LIT>\")<EOL>pyblish.api.deregister_host(\"<STR_LIT>\")<EOL>", "docstring": "Register supported hosts", "id": "f12821:m6"}
{"signature": "def delete(<EOL>self, resource_group_name, circuit_name, authorization_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>circuit_name=circuit_name,<EOL>authorization_name=authorization_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified authorization from the specified express route\n        circuit.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param authorization_name: The name of the authorization.\n        :type authorization_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33128:c0:m2"}
{"signature": "@provide_session<EOL><INDENT>def clear(self,<EOL>start_date=None,<EOL>end_date=None,<EOL>upstream=False,<EOL>downstream=False,<EOL>session=None):<DEDENT>", "body": "TI = TaskInstance<EOL>qry = session.query(TI).filter(TI.dag_id == self.dag_id)<EOL>if start_date:<EOL><INDENT>qry = qry.filter(TI.execution_date >= start_date)<EOL><DEDENT>if end_date:<EOL><INDENT>qry = qry.filter(TI.execution_date <= end_date)<EOL><DEDENT>tasks = [self.task_id]<EOL>if upstream:<EOL><INDENT>tasks += [<EOL>t.task_id for t in self.get_flat_relatives(upstream=True)]<EOL><DEDENT>if downstream:<EOL><INDENT>tasks += [<EOL>t.task_id for t in self.get_flat_relatives(upstream=False)]<EOL><DEDENT>qry = qry.filter(TI.task_id.in_(tasks))<EOL>count = qry.count()<EOL>clear_task_instances(qry.all(), session, dag=self.dag)<EOL>session.commit()<EOL>return count<EOL>", "docstring": "Clears the state of task instances associated with the task, following\nthe parameters specified.", "id": "f9444:c0:m34"}
{"signature": "def _set_sid(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>False,<EOL>sid.sid,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT:False>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__sid = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for sid, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/adjacency_sid/sid (list)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_sid is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_sid() directly.\n\n    YANG Description: Adjacency Segment-IDs List. An IGP-Adjacency Segment is an IGP\nsegment attached to a unidirectional adjacency or a set of\nunidirectional adjacencies. By default, an IGP-Adjacency Segment is\nlocal to the node which advertises it.", "id": "f22580:c0:m3"}
{"signature": "def make_internal_signing_service(config, entity_id):", "body": "_args = dict([(k, v) for k, v in config.items() if k in KJ_SPECS])<EOL>_kj = init_key_jar(**_args)<EOL>return InternalSigningService(entity_id, _kj)<EOL>", "docstring": "Given configuration initiate an InternalSigningService instance\n\n:param config: The signing service configuration\n:param entity_id: The entity identifier\n:return: A InternalSigningService instance", "id": "f14441:m0"}
{"signature": "def _set_address_family(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__address_family = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for address_family, mapped from YANG variable /network_instances/network_instance/table_connections/table_connection/state/address_family (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_address_family is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_address_family() directly.\n\n    YANG Description: The address family associated with the connection. This\nmust be defined for the source protocol. The target\naddress family is implicitly defined by the address family\nspecified for the source protocol.", "id": "f22140:c1:m6"}
{"signature": "@property<EOL><INDENT>def detail(self):<DEDENT>", "body": "if hasattr(self, '<STR_LIT>'):<EOL><INDENT>return self._detail<EOL><DEDENT>else:<EOL><INDENT>self.get_detail()<EOL>return self._detail<EOL><DEDENT>", "docstring": "\u4e2a\u4eba\u4fe1\u606f,\u5982\u679c\u672a\u8c03\u7528\u8fc7``get_detail()``\u4f1a\u81ea\u52a8\u8c03\u7528\n\n:return: information of student\n:rtype: dict", "id": "f4089:c1:m9"}
{"signature": "def _set_prevent_teardown(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__prevent_teardown = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for prevent_teardown, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/state/prevent_teardown (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_prevent_teardown is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_prevent_teardown() directly.\n\n    YANG Description: Do not tear down the BGP session when the maximum\nprefix limit is exceeded, but rather only log a\nwarning. The default of this leaf is false, such\nthat when it is not specified, the session is torn\ndown.", "id": "f23443:c0:m6"}
{"signature": "def turn_on_with_brightness(self, device_id, name, brightness):", "body": "brightness_value = round((brightness * <NUM_LIT>) / <NUM_LIT:255>) + <NUM_LIT:1><EOL>msg = \"<STR_LIT>\" % (<EOL>device_id, brightness_value, brightness_value, name)<EOL>self._send_message(msg)<EOL>", "docstring": "Scale brightness from 0..255 to 1..32.", "id": "f12818:c0:m6"}
{"signature": "@requires_executable('<STR_LIT>')<EOL>def cut_video(in_file,<EOL>out_file,<EOL>start=None,<EOL>end=None,<EOL>vcodec=None,<EOL>acodec=None,<EOL>log_level='<STR_LIT:info>',<EOL>print_cmd=False,<EOL>**kwargs):", "body": "options = {'<STR_LIT>': log_level}<EOL>if vcodec is None:<EOL><INDENT>options['<STR_LIT>'] = '<STR_LIT>'<EOL><DEDENT>if acodec is None:<EOL><INDENT>options['<STR_LIT>'] = '<STR_LIT>'<EOL><DEDENT>if start:<EOL><INDENT>options['<STR_LIT>'] = start<EOL><DEDENT>else:<EOL><INDENT>start = <NUM_LIT:0><EOL><DEDENT>if end:<EOL><INDENT>options['<STR_LIT:t>'] = end - start<EOL><DEDENT>convert_video(in_file, out_file, print_cmd, **options)<EOL>", "docstring": "Cut a clip from a video.\n\n    Args:\n        in_file (str): Input video filename.\n        out_file (str): Output video filename.\n        start (None or float): Start time (in seconds).\n        end (None or float): End time (in seconds).\n        vcodec (None or str): Output video codec, None for unchanged.\n        acodec (None or str): Output audio codec, None for unchanged.\n        log_level (str): Logging level of ffmpeg.\n        print_cmd (bool): Whether to print the final ffmpeg command.", "id": "f14476:m2"}
{"signature": "def _get_enabled(self):", "body": "return self.__enabled<EOL>", "docstring": "Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/use_multiple_paths/config/enabled (boolean)\n\n    YANG Description: Whether the use of multiple paths for the same NLRI is\nenabled for the neighbor. This value is overridden by\nany more specific configuration value.", "id": "f23349:c1:m2"}
{"signature": "def get_relay_service_connection(<EOL>self, resource_group_name, name, entity_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_relay_service_connection.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", entity_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a hybrid connection configuration by its name.\n\n        Gets a hybrid connection configuration by its name.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param entity_name: Name of the hybrid connection.\n        :type entity_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: RelayServiceConnectionEntity or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.web.models.RelayServiceConnectionEntity or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44988:c0:m85"}
{"signature": "def add(self, subcmd_cb):", "body": "subcmd_name = subcmd_cb.name<EOL>self.subcmds[subcmd_name] = subcmd_cb<EOL>self.cmdlist.append(subcmd_name)<EOL>", "docstring": "Add subcmd to the available subcommands for this object.\n        It will have the supplied docstring, and subcmd_cb will be called\n        when we want to run the command. min_len is the minimum length\n        allowed to abbreviate the command. in_list indicates with the\n        show command will be run when giving a list of all sub commands\n        of this object. Some commands have long output like \"show commands\"\n        so we might not want to show that.", "id": "f7407:c0:m3"}
{"signature": "def graphic_target(self, x, y):", "body": "if self.authorized_display == True:<EOL><INDENT>try:<EOL><INDENT>self.display_the_graphic(self.num_line, self.wavelength, self.data_wanted, self.information)<EOL>self.ui.mouse_coordinate.setText(\"<STR_LIT>\" % (x, y))<EOL><DEDENT>except:<EOL><INDENT>pass<EOL><DEDENT><DEDENT>", "docstring": "The following update labels about mouse coordinates.", "id": "f15342:c0:m31"}
{"signature": "def _get_shutdown_threshold_pct(self):", "body": "return self.__shutdown_threshold_pct<EOL>", "docstring": "Getter method for shutdown_threshold_pct, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/config/shutdown_threshold_pct (oc-types:percentage)\n\n    YANG Description: Threshold on number of prefixes that can be received\nfrom a neighbour before generation of warning messages\nor log entries. Expressed as a percentage of\nmax-prefixes", "id": "f23174:c1:m8"}
{"signature": "def safe_run_module(self, mod_name, where):", "body": "try:<EOL><INDENT>where.update(<EOL>runpy.run_module(str(mod_name), run_name=\"<STR_LIT:__main__>\",<EOL>alter_sys=True)<EOL>)<EOL><DEDENT>except:<EOL><INDENT>self.showtraceback()<EOL>warn('<STR_LIT>' % mod_name)<EOL><DEDENT>", "docstring": "A safe version of runpy.run_module().\n\n        This version will never throw an exception, but instead print\n        helpful error messages to the screen.\n\n        Parameters\n        ----------\n        mod_name : string\n            The name of the module to be executed.\n        where : dict\n            The globals namespace.", "id": "f21442:c5:m96"}
{"signature": "def _get_link_state_id(self):", "body": "return self.__link_state_id<EOL>", "docstring": "Getter method for link_state_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/state/link_state_id (yang:dotted-quad)\n\n    YANG Description: The Link State ID for the specified LSA type. The exact\ndefined value of the Link State ID is dependent on the LSA\ntype.", "id": "f22984:c0:m2"}
{"signature": "def set_default_style(self, colors='<STR_LIT>'):", "body": "colors = colors.lower()<EOL>if colors=='<STR_LIT>':<EOL><INDENT>self.style_sheet = styles.default_light_style_sheet<EOL>self.syntax_style = styles.default_light_syntax_style<EOL><DEDENT>elif colors=='<STR_LIT>':<EOL><INDENT>self.style_sheet = styles.default_dark_style_sheet<EOL>self.syntax_style = styles.default_dark_syntax_style<EOL><DEDENT>elif colors=='<STR_LIT>':<EOL><INDENT>self.style_sheet = styles.default_bw_style_sheet<EOL>self.syntax_style = styles.default_bw_syntax_style<EOL><DEDENT>else:<EOL><INDENT>raise KeyError(\"<STR_LIT>\"%colors)<EOL><DEDENT>", "docstring": "Sets the widget style to the class defaults.\n\n        Parameters:\n        -----------\n        colors : str, optional (default lightbg)\n            Whether to use the default IPython light background or dark\n            background or B&W style.", "id": "f21644:c0:m15"}
{"signature": "@property<EOL><INDENT>def type(self):<DEDENT>", "body": "return self._json_data.get('<STR_LIT:type>')<EOL>", "docstring": "The type of room (i.e. 'group', 'direct' etc.).", "id": "f10508:c0:m2"}
{"signature": "def _get_entries(self):", "body": "return self.__entries<EOL>", "docstring": "Getter method for entries, mapped from YANG variable /network_instances/network_instance/fdb/mac_table/entries (container)\n\nYANG Description: Enclosing container for list of MAC table entries", "id": "f22098:c0:m2"}
{"signature": "def _set_use_multiple_paths(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=use_multiple_paths.use_multiple_paths,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__use_multiple_paths = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for use_multiple_paths, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_use_multiple_paths is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_use_multiple_paths() directly.\n\n    YANG Description: Parameters related to the use of multiple paths for the\nsame NLRI", "id": "f23427:c1:m18"}
{"signature": "def issue_edit(issue, **kwargs):", "body": "put(\"<STR_LIT>\",<EOL>issue_number=issue.number,<EOL>**kwargs)<EOL>", "docstring": "Saves an issue", "id": "f11651:m5"}
{"signature": "def _set_adjust_threshold(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__adjust_threshold = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for adjust_threshold, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/bandwidth/auto_bandwidth/config/adjust_threshold (oc-types:percentage)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_adjust_threshold is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_adjust_threshold() directly.\n\n    YANG Description: percentage difference between the LSP's\nspecified bandwidth and its current bandwidth\nallocation -- if the difference is greater than the\nspecified percentage, auto-bandwidth adjustment is\ntriggered", "id": "f22246:c0:m15"}
{"signature": "def _get_max_prefixes(self):", "body": "return self.__max_prefixes<EOL>", "docstring": "Getter method for max_prefixes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/config/max_prefixes (uint32)\n\n    YANG Description: Maximum number of prefixes that will be accepted\nfrom the neighbour", "id": "f23398:c1:m2"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ibgp/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration parameters relating to iBGP multipath", "id": "f23423:c0:m3"}
{"signature": "def list_virtual_machine_scale_set_network_interfaces(<EOL>self, resource_group_name, virtual_machine_scale_set_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_virtual_machine_scale_set_network_interfaces.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_machine_scale_set_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkInterfacePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkInterfacePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all network interfaces in a virtual machine scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_machine_scale_set_name: The name of the virtual machine\n         scale set.\n        :type virtual_machine_scale_set_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkInterface\n        :rtype:\n         ~azure.mgmt.network.v2015_06_15.models.NetworkInterfacePaged[~azure.mgmt.network.v2015_06_15.models.NetworkInterface]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34399:c0:m9"}
{"signature": "def count(self, conn, filters):", "body": "pipe, intersect, temp_id = self._prepare(conn, filters)<EOL>pipe.zcard(temp_id)<EOL>pipe.delete(temp_id)<EOL>return pipe.execute()[-<NUM_LIT:2>]<EOL>", "docstring": "Returns the count of the items that match the provided filters.\n\nFor the meaning of what the ``filters`` argument means, see the\n``.search()`` method docs.", "id": "f17330:c0:m3"}
{"signature": "def _get_shutdown_threshold_pct(self):", "body": "return self.__shutdown_threshold_pct<EOL>", "docstring": "Getter method for shutdown_threshold_pct, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/config/shutdown_threshold_pct (oc-types:percentage)\n\n    YANG Description: Threshold on number of prefixes that can be received\nfrom a neighbour before generation of warning messages\nor log entries. Expressed as a percentage of\nmax-prefixes", "id": "f23444:c0:m8"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv6_reachability/prefixes/prefix/subTLVs/subTLVs/tag/state (container)\n\nYANG Description: State parameters of sub-TLV 1.", "id": "f22920:c1:m2"}
{"signature": "def transplant_func(func, module):", "body": "from nose.tools import make_decorator<EOL>def newfunc(*arg, **kw):<EOL><INDENT>return func(*arg, **kw)<EOL><DEDENT>newfunc = make_decorator(func)(newfunc)<EOL>newfunc.__module__ = module<EOL>return newfunc<EOL>", "docstring": "Make a function imported from module A appear as if it is located\nin module B.\n\n>>> from pprint import pprint\n>>> pprint.__module__\n'pprint'\n>>> pp = transplant_func(pprint, __name__)\n>>> pp.__module__\n'nose.util'\n\nThe original function is not modified.\n\n>>> pprint.__module__\n'pprint'\n\nCalling the transplanted function calls the original.\n\n>>> pp([1, 2])\n[1, 2]\n>>> pprint([1,2])\n[1, 2]", "id": "f21753:m21"}
{"signature": "@contextmanager<EOL>def user_code_context_manager(user_fn, error_cls, msg):", "body": "check.callable_param(user_fn, '<STR_LIT>')<EOL>check.subclass_param(error_cls, '<STR_LIT>', DagsterUserCodeExecutionError)<EOL>with user_code_error_boundary(error_cls, msg):<EOL><INDENT>thing_or_gen = user_fn()<EOL>gen = _ensure_gen(thing_or_gen)<EOL>try:<EOL><INDENT>thing = next(gen)<EOL><DEDENT>except StopIteration:<EOL><INDENT>check.failed('<STR_LIT>')<EOL><DEDENT>yield thing<EOL>stopped = False<EOL>try:<EOL><INDENT>next(gen)<EOL><DEDENT>except StopIteration:<EOL><INDENT>stopped = True<EOL><DEDENT>check.invariant(stopped, '<STR_LIT>')<EOL><DEDENT>", "docstring": "Wraps the output of a user provided function that may yield or return a value and\n    returns a generator that asserts it only yields a single value.", "id": "f8406:m4"}
{"signature": "def close(self):", "body": "if self._ctx is not None:<EOL><INDENT>self._io_queue_release(self._ctx)<EOL>del self._ctx<EOL><DEDENT>", "docstring": "Cancels all pending IO blocks.\nWaits until all non-cancellable IO blocks finish.\nDe-initialises AIO context.", "id": "f10417:c2:m1"}
{"signature": "def _set_safi_name(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__safi_name = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for safi_name, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af/state/safi_name (identityref)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_safi_name is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_safi_name() directly.\n\nYANG Description: Subsequent address-family type.", "id": "f22439:c0:m6"}
{"signature": "def install(**kwargs):", "body": "if USE_SETUPTOOLS:<EOL><INDENT>if \"<STR_LIT>\" in sys.argv:<EOL><INDENT>sys.argv.remove(\"<STR_LIT>\")<EOL><DEDENT><DEDENT>packages = [modname] + get_packages(join(base_dir, \"<STR_LIT>\"), modname)<EOL>if USE_SETUPTOOLS:<EOL><INDENT>if install_requires:<EOL><INDENT>kwargs[\"<STR_LIT>\"] = install_requires<EOL>kwargs[\"<STR_LIT>\"] = dependency_links<EOL><DEDENT>kwargs[\"<STR_LIT>\"] = {<EOL>\"<STR_LIT>\": [<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>]<EOL>}<EOL><DEDENT>kwargs[\"<STR_LIT>\"] = packages<EOL>cmdclass = {\"<STR_LIT>\": MyInstallLib, \"<STR_LIT>\": build_py}<EOL>if easy_install_lib:<EOL><INDENT>cmdclass[\"<STR_LIT>\"] = easy_install<EOL><DEDENT>return setup(<EOL>name=distname,<EOL>version=__pkginfo__[\"<STR_LIT:version>\"],<EOL>license=__pkginfo__[\"<STR_LIT>\"],<EOL>description=__pkginfo__[\"<STR_LIT:description>\"],<EOL>long_description=long_description,<EOL>author=__pkginfo__[\"<STR_LIT>\"],<EOL>author_email=__pkginfo__[\"<STR_LIT>\"],<EOL>url=__pkginfo__[\"<STR_LIT>\"],<EOL>scripts=ensure_scripts(scripts),<EOL>classifiers=__pkginfo__[\"<STR_LIT>\"],<EOL>data_files=data_files,<EOL>ext_modules=ext_modules,<EOL>cmdclass=cmdclass,<EOL>extras_require=extras_require,<EOL>test_suite=\"<STR_LIT:test>\",<EOL>python_requires=\"<STR_LIT>\",<EOL>setup_requires=[\"<STR_LIT>\"],<EOL>tests_require=[\"<STR_LIT>\"],<EOL>**kwargs<EOL>)<EOL>", "docstring": "setup entry point", "id": "f18901:m3"}
{"signature": "def _insert_img(self, cursor, img, fmt):", "body": "try:<EOL><INDENT>image = QtGui.QImage()<EOL>image.loadFromData(img, fmt.upper())<EOL><DEDENT>except ValueError:<EOL><INDENT>self._insert_plain_text(cursor, '<STR_LIT>'%fmt)<EOL><DEDENT>else:<EOL><INDENT>format = self._add_image(image)<EOL>cursor.insertBlock()<EOL>cursor.insertImage(format)<EOL>cursor.insertBlock()<EOL><DEDENT>", "docstring": "insert a raw image, jpg or png", "id": "f21639:c0:m15"}
{"signature": "def next_generation(self, mut_rate=<NUM_LIT:0>, max_mut_amt=<NUM_LIT:0>, log_base=<NUM_LIT:10>):", "body": "if self.__num_processes > <NUM_LIT:1>:<EOL><INDENT>process_pool = Pool(processes=self.__num_processes)<EOL>members = [m.get() for m in self.__members]<EOL><DEDENT>else:<EOL><INDENT>members = self.__members<EOL><DEDENT>if len(members) == <NUM_LIT:0>:<EOL><INDENT>raise Exception(<EOL>'<STR_LIT>'<EOL>)<EOL><DEDENT>selected_members = self.__select_fn(members)<EOL>reproduction_probs = list(reversed(logspace(<NUM_LIT:0.0>, <NUM_LIT:1.0>,<EOL>num=len(selected_members), base=log_base)))<EOL>reproduction_probs = reproduction_probs / sum(reproduction_probs)<EOL>self.__members = []<EOL>for _ in range(self.__pop_size):<EOL><INDENT>parent_1 = nrandom.choice(selected_members, p=reproduction_probs)<EOL>parent_2 = nrandom.choice(selected_members, p=reproduction_probs)<EOL>feed_dict = {}<EOL>for param in self.__parameters:<EOL><INDENT>which_parent = uniform(<NUM_LIT:0>, <NUM_LIT:1>)<EOL>if which_parent < <NUM_LIT:0.5>:<EOL><INDENT>feed_dict[param.name] = parent_1.parameters[param.name]<EOL><DEDENT>else:<EOL><INDENT>feed_dict[param.name] = parent_2.parameters[param.name]<EOL><DEDENT>feed_dict[param.name] = self.__mutate_parameter(<EOL>feed_dict[param.name], param, mut_rate, max_mut_amt<EOL>)<EOL><DEDENT>if self.__num_processes > <NUM_LIT:1>:<EOL><INDENT>self.__members.append(process_pool.apply_async(<EOL>self._start_process,<EOL>[self.__cost_fn, feed_dict, self.__cost_fn_args])<EOL>)<EOL><DEDENT>else:<EOL><INDENT>self.__members.append(<EOL>Member(<EOL>feed_dict,<EOL>self.__cost_fn(feed_dict, self.__cost_fn_args)<EOL>)<EOL>)<EOL><DEDENT><DEDENT>if self.__num_processes > <NUM_LIT:1>:<EOL><INDENT>process_pool.close()<EOL>process_pool.join()<EOL><DEDENT>self.__determine_best_member()<EOL>", "docstring": "Generates the next population from a previously evaluated generation\n\n        Args:\n            mut_rate (float): mutation rate for new members (0.0 - 1.0)\n            max_mut_amt (float): how much the member is allowed to mutate\n                (0.0 - 1.0, proportion change of mutated parameter)\n            log_base (int): the higher this number, the more likely the first\n                Members (chosen with supplied selection function) are chosen\n                as parents for the next generation", "id": "f11657:c2:m12"}
{"signature": "@click.command(\"<STR_LIT>\")<EOL>@click.argument(\"<STR_LIT>\") <EOL>@click.argument(\"<STR_LIT>\") <EOL>@click_log.simple_verbosity_option(logger)<EOL>def import_csv(filepath: str, currency: str):", "body": "logger.debug(f\"<STR_LIT>\")<EOL>currency = currency.upper()<EOL>app = PriceDbApplication()<EOL>app.logger = logger<EOL>app.import_prices(filepath, currency)<EOL>", "docstring": "Import prices from CSV file", "id": "f11329:m2"}
{"signature": "def get(<EOL>self, resource_group_name, workspace_name, storage_insight_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", workspace_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", storage_insight_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a storage insight instance.\n\n        :param resource_group_name: The name of the resource group to get. The\n         name is case insensitive.\n        :type resource_group_name: str\n        :param workspace_name: Log Analytics Workspace name that contains the\n         storageInsightsConfigs resource\n        :type workspace_name: str\n        :param storage_insight_name: Name of the storageInsightsConfigs\n         resource\n        :type storage_insight_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: StorageInsight or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.loganalytics.models.StorageInsight or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f40751:c0:m2"}
{"signature": "def __contains__(self, key):", "body": "if self.typeId is None:<EOL><INDENT>(classIdentifier, orgId, typeId, deviceId) = key.split(\"<STR_LIT::>\")<EOL>deviceUrl = \"<STR_LIT>\" % (typeId, deviceId)<EOL><DEDENT>else:<EOL><INDENT>deviceUrl = \"<STR_LIT>\" % (self.typeId, key)<EOL><DEDENT>r = self._apiClient.get(deviceUrl)<EOL>if r.status_code == <NUM_LIT:200>:<EOL><INDENT>return True<EOL><DEDENT>elif r.status_code == <NUM_LIT>:<EOL><INDENT>return False<EOL><DEDENT>else:<EOL><INDENT>raise ApiException(r)<EOL><DEDENT>", "docstring": "Does a device exist?", "id": "f14917:c8:m1"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/state (container)\n\nYANG Description: This container defines interface ISIS level state information.", "id": "f22422:c0:m8"}
{"signature": "@docfiller<EOL>def minimum_filter1d(input, size, axis=-<NUM_LIT:1>, output=None,<EOL>mode=\"<STR_LIT>\", cval=<NUM_LIT:0.0>, origin=<NUM_LIT:0>):", "body": "input = numpy.asarray(input)<EOL>if numpy.iscomplexobj(input):<EOL><INDENT>raise TypeError('<STR_LIT>')<EOL><DEDENT>axis = _ni_support._check_axis(axis, input.ndim)<EOL>if size < <NUM_LIT:1>:<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>output, return_value = _ni_support._get_output(output, input)<EOL>if (size // <NUM_LIT:2> + origin < <NUM_LIT:0>) or (size // <NUM_LIT:2> + origin >= size):<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>mode = _ni_support._extend_mode_to_code(mode)<EOL>_nd_image.min_or_max_filter1d(input, size, axis, output, mode, cval,<EOL>origin, <NUM_LIT:1>)<EOL>return return_value<EOL>", "docstring": "Calculate a one-dimensional minimum filter along the given axis.\n\n    The lines of the array along the given axis are filtered with a\n    minimum filter of given size.\n\n    Parameters\n    ----------\n    %(input)s\n    size : int\n        length along which to calculate 1D minimum\n    %(axis)s\n    %(output)s\n    %(mode)s\n    %(cval)s\n    %(origin)s\n\n    Notes\n    -----\n    This function implements the MINLIST algorithm [1]_, as described by\n    Richard Harter [2]_, and has a guaranteed O(n) performance, `n` being\n    the `input` length, regardless of filter size.\n\n    References\n    ----------\n    .. [1] http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2777\n    .. [2] http://www.richardhartersworld.com/cri/2001/slidingmin.html", "id": "f19435:m16"}
{"signature": "def __init__(self, user=None, pwd=None, tokenFile=None, connect=True):", "body": "super(Skype, self).__init__(self)<EOL>self.conn = SkypeConnection()<EOL>if tokenFile:<EOL><INDENT>self.conn.setTokenFile(tokenFile)<EOL><DEDENT>if user and pwd:<EOL><INDENT>self.conn.setUserPwd(user, pwd)<EOL><DEDENT>if connect and ((user and pwd) or tokenFile):<EOL><INDENT>try:<EOL><INDENT>self.conn.readToken()<EOL><DEDENT>except SkypeAuthException:<EOL><INDENT>self.conn.getSkypeToken()<EOL><DEDENT><DEDENT>self.contacts = SkypeContacts(self)<EOL>self.chats = SkypeChats(self)<EOL>self.settings = SkypeSettings(self)<EOL>self.translate = SkypeTranslator(self)<EOL>", "docstring": "Create a new Skype object and corresponding connection.\n\nIf ``user`` and ``pwd`` are given, they will be passed to :meth:`.SkypeConnection.setUserPwd`.  This can be\neither a Skype username/password pair, or a Microsoft account email address and its associated password.\n\nIf a token file path is present, it will be used if valid.  On a successful connection, the token file will\nalso be written to.\n\nBy default, a connection attempt will be made if any valid form of credentials are supplied.  It is also\npossible to handle authentication manually, by working with the underlying connection object instead.\n\nArgs:\n    user (str): Skype username of the connecting account\n    pwd (str): corresponding Skype account password\n    tokenFile (str): path to file used for token storage\n    connect (bool): whether to try and connect straight away\n\nRaises:\n    .SkypeAuthException: if connecting, and the login request is rejected\n    .SkypeApiException: if connecting, and the login form can't be processed", "id": "f11795:c0:m0"}
{"signature": "def _get_post_session_up_delay(self):", "body": "return self.__post_session_up_delay<EOL>", "docstring": "Getter method for post_session_up_delay, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/global/mpls/igp_ldp_sync/state/post_session_up_delay (uint32)\n\n    YANG Description: This leaf specifies a delay, expressed in units of milliseconds,\nbetween the LDP session to the IGP neighbor being established, and\nit being considered synchronized by the IGP.", "id": "f23151:c1:m5"}
{"signature": "def set_accessed(self, node):", "body": "frame = node_frame_class(node)<EOL>if frame is None:<EOL><INDENT>return<EOL><DEDENT>self._scopes[frame][node.attrname].append(node)<EOL>", "docstring": "Set the given node as accessed.", "id": "f18870:c0:m1"}
{"signature": "def add(self, dist):", "body": "new_path = (<EOL>dist.location not in self.paths and (<EOL>dist.location not in self.sitedirs or<EOL>dist.location == os.getcwd()<EOL>)<EOL>)<EOL>if new_path:<EOL><INDENT>self.paths.append(dist.location)<EOL>self.dirty = True<EOL><DEDENT>Environment.add(self, dist)<EOL>", "docstring": "Add `dist` to the distribution map", "id": "f17038:c1:m3"}
{"signature": "def await_finished(self):", "body": "return self._finished_d<EOL>", "docstring": "Wait for the both sides of the connection to close.", "id": "f1156:c2:m6"}
{"signature": "def raise_any_error(self):", "body": "for tc in self.possible:<EOL><INDENT>tc.raise_found_error()<EOL><DEDENT>", "docstring": "raise any found error in the possible PathFinders", "id": "f5409:c1:m1"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters relating to multipath", "id": "f23315:c1:m6"}
{"signature": "def get_quota(self):", "body": "return op.itemgetter('<STR_LIT>', '<STR_LIT>')(super(OneDriveAPI, self).get_quota())<EOL>", "docstring": "Return tuple of (bytes_available, bytes_quota).", "id": "f1114:c11:m1"}
{"signature": "def list(<EOL>self, resource_group_name, network_interface_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", network_interface_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkInterfaceIPConfigurationPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkInterfaceIPConfigurationPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get all ip configurations in a network interface.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_interface_name: The name of the network interface.\n        :type network_interface_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkInterfaceIPConfiguration\n        :rtype:\n         ~azure.mgmt.network.v2018_01_01.models.NetworkInterfaceIPConfigurationPaged[~azure.mgmt.network.v2018_01_01.models.NetworkInterfaceIPConfiguration]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31996:c0:m1"}
{"signature": "def IMPORT_FROM(self,pc,namei):", "body": "raise NotImplementedError<EOL>", "docstring": "Loads the attribute co_names[namei] from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a STORE_FAST instruction.", "id": "f19667:c3:m81"}
{"signature": "def catch(fcn, *args, **kwargs):", "body": "try:<EOL><INDENT>spit = kwargs.pop('<STR_LIT>')<EOL><DEDENT>except:<EOL><INDENT>spit = None<EOL><DEDENT>try:<EOL><INDENT>results = fcn(*args, **kwargs)<EOL>if results:<EOL><INDENT>return results<EOL><DEDENT><DEDENT>except:<EOL><INDENT>print(traceback.format_exc())<EOL>if spit:<EOL><INDENT>return spit<EOL><DEDENT><DEDENT>", "docstring": "try:\n          retrun fcn(*args, **kwargs)\n       except:\n          print traceback\n            if 'spit' in kwargs.keys():\n                return kwargs['spit']\n\n    Parameters\n    ----------\n    fcn : function\n    *args : unnamed parameters of fcn\n    **kwargs : named parameters of fcn\n        spit : returns the parameter named return in the exception\n\n    Returns\n    -------\n    The expected output of fcn or prints the exception traceback", "id": "f18908:m0"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkSecurityGroupPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkSecurityGroupPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all network security groups in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkSecurityGroup\n        :rtype:\n         ~azure.mgmt.network.v2019_02_01.models.NetworkSecurityGroupPaged[~azure.mgmt.network.v2019_02_01.models.NetworkSecurityGroup]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34947:c0:m9"}
{"signature": "@property<EOL><INDENT>def lr(self):<DEDENT>", "body": "return self.max_x, self.min_y<EOL>", "docstring": "Returns the lower right coordinate.", "id": "f1742:c0:m18"}
{"signature": "@property<EOL><INDENT>def height(self):<DEDENT>", "body": "return self._height<EOL>", "docstring": "The height of the image, in texels (read-only).", "id": "f6776:c0:m4"}
{"signature": "def get_last_update(self):", "body": "instance, created =models.DashboardWidgetLastUpdate.objects.get_or_create(<EOL>widget_name=self.get_name())<EOL>return instance<EOL>", "docstring": "Gets or creates the last update object for this widget.", "id": "f307:c0:m2"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualNetworkGatewayConnectionPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualNetworkGatewayConnectionPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "The List VirtualNetworkGatewayConnections operation retrieves all the\n        virtual network gateways connections created.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualNetworkGatewayConnection\n        :rtype:\n         ~azure.mgmt.network.v2017_06_01.models.VirtualNetworkGatewayConnectionPaged[~azure.mgmt.network.v2017_06_01.models.VirtualNetworkGatewayConnection]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32281:c0:m9"}
{"signature": "def _parse_example(self, m, name, lineno,ip2py=False):", "body": "<EOL>indent = len(m.group('<STR_LIT>'))<EOL>source_lines = m.group('<STR_LIT:source>').split('<STR_LIT:\\n>')<EOL>ps1 = m.group('<STR_LIT>')<EOL>ps2 = m.group('<STR_LIT>')<EOL>ps1_len = len(ps1)<EOL>self._check_prompt_blank(source_lines, indent, name, lineno,ps1_len)<EOL>if ps2:<EOL><INDENT>self._check_prefix(source_lines[<NUM_LIT:1>:], '<STR_LIT:U+0020>'*indent + ps2, name, lineno)<EOL><DEDENT>source = '<STR_LIT:\\n>'.join([sl[indent+ps1_len+<NUM_LIT:1>:] for sl in source_lines])<EOL>if ip2py:<EOL><INDENT>source = self.ip2py(source)<EOL><DEDENT>want = m.group('<STR_LIT>')<EOL>want_lines = want.split('<STR_LIT:\\n>')<EOL>if len(want_lines) > <NUM_LIT:1> and re.match(r'<STR_LIT>', want_lines[-<NUM_LIT:1>]):<EOL><INDENT>del want_lines[-<NUM_LIT:1>]  <EOL><DEDENT>self._check_prefix(want_lines, '<STR_LIT:U+0020>'*indent, name,<EOL>lineno + len(source_lines))<EOL>want_lines[<NUM_LIT:0>] = re.sub(r'<STR_LIT>','<STR_LIT>',want_lines[<NUM_LIT:0>])<EOL>want = '<STR_LIT:\\n>'.join([wl[indent:] for wl in want_lines])<EOL>m = self._EXCEPTION_RE.match(want)<EOL>if m:<EOL><INDENT>exc_msg = m.group('<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>exc_msg = None<EOL><DEDENT>options = self._find_options(source, name, lineno)<EOL>return source, options, want, exc_msg<EOL>", "docstring": "Given a regular expression match from `_EXAMPLE_RE` (`m`),\nreturn a pair `(source, want)`, where `source` is the matched\nexample's source code (with prompts and indentation stripped);\nand `want` is the example's expected output (with indentation\nstripped).\n\n`name` is the string's name, and `lineno` is the line number\nwhere the example starts; both are used for error messages.\n\nOptional:\n`ip2py`: if true, filter the input via IPython to convert the syntax\ninto valid python.", "id": "f21375:c6:m2"}
{"signature": "def capture(<EOL>self, resource_group_name, vm_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._capture_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Captures the VM by copying virtual hard disks of the VM and outputs a\n        template that can be used to create similar VMs.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param parameters: Parameters supplied to the Capture Virtual Machine\n         operation.\n        :type parameters:\n         ~azure.mgmt.compute.v2016_04_30_preview.models.VirtualMachineCaptureParameters\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         VirtualMachineCaptureResult or\n         ClientRawResponse<VirtualMachineCaptureResult> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2016_04_30_preview.models.VirtualMachineCaptureResult]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2016_04_30_preview.models.VirtualMachineCaptureResult]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25117:c0:m3"}
{"signature": "def _prepare_queue(self):", "body": "if self._queue is None:<EOL><INDENT>if self._use_manager:<EOL><INDENT>if self._manager is None:<EOL><INDENT>self._manager = multip.Manager()<EOL><DEDENT>self._queue = self._manager.Queue(maxsize=self._queue_maxsize)<EOL><DEDENT>else:<EOL><INDENT>self._queue = multip.Queue(maxsize=self._queue_maxsize)<EOL><DEDENT><DEDENT>self._logger.info('<STR_LIT>')<EOL>queue_handler = QueueStorageServiceWriter(self._storage_service, self._queue,<EOL>self._gc_interval)<EOL>self._queue_process = multip.Process(name='<STR_LIT>', target=_wrap_handling,<EOL>args=(dict(handler=queue_handler,<EOL>logging_manager=self._logging_manager,<EOL>graceful_exit=self._graceful_exit),))<EOL>self._queue_process.start()<EOL>self._queue_wrapper = QueueStorageServiceSender(self._queue)<EOL>self._traj.v_storage_service = self._queue_wrapper<EOL>", "docstring": "Replaces the trajectory's service with a queue sender and starts the queue process.", "id": "f4231:c1:m17"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, route_table_name, route_name, route_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>route_table_name=route_table_name,<EOL>route_name=route_name,<EOL>route_parameters=route_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a route in the specified route table.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_table_name: The name of the route table.\n        :type route_table_name: str\n        :param route_name: The name of the route.\n        :type route_name: str\n        :param route_parameters: Parameters supplied to the create or update\n         route operation.\n        :type route_parameters: ~azure.mgmt.network.v2017_09_01.models.Route\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns Route or\n         ClientRawResponse<Route> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_09_01.models.Route]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_09_01.models.Route]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29819:c0:m5"}
{"signature": "def get(<EOL>self, resource_group_name, route_filter_name, rule_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", route_filter_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", rule_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified rule from a route filter.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_filter_name: The name of the route filter.\n        :type route_filter_name: str\n        :param rule_name: The name of the rule.\n        :type rule_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: RouteFilterRule or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_01_01.models.RouteFilterRule or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32028:c0:m3"}
{"signature": "def send_metric(self, name, metric):", "body": "config = SERIALIZER_CONFIG[class_name(metric)]<EOL>mmap(<EOL>self._buffered_send_metric,<EOL>self.serialize_metric(<EOL>metric,<EOL>name,<EOL>config['<STR_LIT>'],<EOL>config['<STR_LIT>']<EOL>)<EOL>)<EOL>if hasattr(metric, '<STR_LIT>') and config.get('<STR_LIT>'):<EOL><INDENT>mmap(<EOL>self._buffered_send_metric,<EOL>self.serialize_metric(<EOL>metric.snapshot,<EOL>name,<EOL>config['<STR_LIT>'],<EOL>config['<STR_LIT>']<EOL>)<EOL>)<EOL><DEDENT>", "docstring": "Send metric and its snapshot.", "id": "f9829:c0:m3"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ExpressRouteCircuitPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ExpressRouteCircuitPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the express route circuits in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ExpressRouteCircuit\n        :rtype:\n         ~azure.mgmt.network.v2018_08_01.models.ExpressRouteCircuitPaged[~azure.mgmt.network.v2018_08_01.models.ExpressRouteCircuit]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31678:c0:m16"}
{"signature": "def create_service_from_template(<EOL>self, application_id, service_from_template_description, timeout=<NUM_LIT>, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>url = self.create_service_from_template.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", application_id, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>if timeout is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", timeout, '<STR_LIT>', maximum=<NUM_LIT>, minimum=<NUM_LIT:1>)<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>body_content = self._serialize.body(service_from_template_description, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.FabricErrorException(self._deserialize, response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Creates a Service Fabric service from the service template.\n\n        Creates a Service Fabric service from the service template defined in\n        the application manifest. A service template contains the properties\n        that will be same for the service instance of the same type. The API\n        allows overriding the properties that are usually different for\n        different services of the same service type.\n\n        :param application_id: The identity of the application. This is\n         typically the full name of the application without the 'fabric:' URI\n         scheme.\n         Starting from version 6.0, hierarchical names are delimited with the\n         \"~\" character.\n         For example, if the application name is \"fabric:/myapp/app1\", the\n         application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in\n         previous versions.\n        :type application_id: str\n        :param service_from_template_description: Describes the service that\n         needs to be created from the template defined in the application\n         manifest.\n        :type service_from_template_description:\n         ~azure.servicefabric.models.ServiceFromTemplateDescription\n        :param timeout: The server timeout for performing the operation in\n         seconds. This timeout specifies the time duration that the client is\n         willing to wait for the requested operation to complete. The default\n         value for this parameter is 60 seconds.\n        :type timeout: long\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`FabricErrorException<azure.servicefabric.models.FabricErrorException>`", "id": "f27460:c1:m65"}
{"signature": "def _set_prevent_teardown(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__prevent_teardown = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for prevent_teardown, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/config/prevent_teardown (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_prevent_teardown is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_prevent_teardown() directly.\n\n    YANG Description: Do not tear down the BGP session when the maximum\nprefix limit is exceeded, but rather only log a\nwarning. The default of this leaf is false, such\nthat when it is not specified, the session is torn\ndown.", "id": "f23430:c0:m6"}
{"signature": "def get_filename(self):", "body": "return os.path.basename(self.img.name)<EOL>", "docstring": "Returns the image filename.", "id": "f18273:c9:m1"}
{"signature": "def pre_save(self, model_instance, add):", "body": "if self.original:<EOL><INDENT>original_value = getattr(model_instance, self.original)<EOL>setattr(model_instance, self.attname, original_value)<EOL><DEDENT>return super(HashMixin, self).pre_save(model_instance, add)<EOL>", "docstring": "Save the original_value.", "id": "f1244:c1:m1"}
{"signature": "def getargvalues(frame):", "body": "args, varargs, varkw = getargs(frame.f_code)<EOL>return args, varargs, varkw, frame.f_locals<EOL>", "docstring": "Get information about arguments passed into a particular frame.\n\n    A tuple of four things is returned: (args, varargs, varkw, locals).\n    'args' is a list of the argument names (it may contain nested lists).\n    'varargs' and 'varkw' are the names of the * and ** arguments or None.\n    'locals' is the locals dictionary of the given frame.", "id": "f18980:m5"}
{"signature": "def confirm(message=\"<STR_LIT>\", title=\"<STR_LIT>\", default=False, ok=False, cancel=False,<EOL>parent=None):", "body": "style = wx.CENTRE<EOL>if ok:<EOL><INDENT>style |= wx.OK <EOL><DEDENT>else:<EOL><INDENT>style |= wx.YES | wx.NO<EOL>if default:<EOL><INDENT>style |= wx.YES_DEFAULT<EOL><DEDENT>else:<EOL><INDENT>style |= wx.NO_DEFAULT<EOL><DEDENT><DEDENT>if cancel:<EOL><INDENT>style |= wx.CANCEL<EOL><DEDENT>result = dialogs.messageDialog(parent, message, title, style)<EOL>if cancel and result.returned == wx.ID_CANCEL:<EOL><INDENT>return None<EOL><DEDENT>return result.accepted<EOL>", "docstring": "Ask for confirmation (yes/no or ok and cancel), returns True or False", "id": "f17373:m2"}
{"signature": "@property<EOL><INDENT>def v_comment(self):<DEDENT>", "body": "return self._comment<EOL>", "docstring": "Should be a nice descriptive comment", "id": "f4238:c0:m9"}
{"signature": "def open(self):", "body": "self.thing.add_subscriber(self)<EOL>", "docstring": "Handle a new connection.", "id": "f478:c4:m5"}
{"signature": "def list_application_settings(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list_application_settings.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the application settings of an app.\n\n        Gets the application settings of an app.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: StringDictionary or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.web.models.StringDictionary or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44988:c0:m19"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/config (container)\n\nYANG Description: This container defines interface ISIS level configuration.", "id": "f22422:c1:m5"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/lan_adjacency_sid/sid/state (container)\n\nYANG Description: State parameters of LAN Adjacency-SID.", "id": "f22616:c1:m2"}
{"signature": "def grow(script, iterations=<NUM_LIT:1>):", "body": "filter_xml = '<STR_LIT>'<EOL>for _ in range(iterations):<EOL><INDENT>util.write_filter(script, filter_xml)<EOL><DEDENT>return None<EOL>", "docstring": "Grow (dilate, expand) the current set of selected faces\n\n    Args:\n        script: the FilterScript object or script filename to write\n            the filter to.\n        iterations (int): the number of times to grow the selection.\n\n    Layer stack:\n        No impacts\n\n    MeshLab versions:\n        2016.12\n        1.3.4BETA", "id": "f9652:m4"}
{"signature": "def _set_address(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT>\",<EOL>address.address,<EOL>yang_name=\"<STR_LIT:address>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT:address>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__address = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for address, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address (list)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_address is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_address() directly.\n\nYANG Description: The list of configured IPv4 addresses on the interface.", "id": "f21958:c0:m3"}
{"signature": "def set(self, option: ConfigKeys, value):", "body": "assert isinstance(option, ConfigKeys)<EOL>section = SECTION<EOL>self.config.set(section, option.name, value)<EOL>self.save()<EOL>", "docstring": "Sets a value in config", "id": "f11327:c1:m8"}
{"signature": "@property<EOL><INDENT>def design_matrix(self):<DEDENT>", "body": "return self._design_matrix<EOL>", "docstring": "Tensor representing the design matrix.", "id": "f15505:c1:m2"}
{"signature": "@property<EOL><INDENT>def scale(self):<DEDENT>", "body": "return self._scale<EOL>", "docstring": "Distribution parameter for the scale.", "id": "f15727:c0:m4"}
{"signature": "def backend_health(<EOL>self, resource_group_name, application_gateway_name, expand=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._backend_health_initial(<EOL>resource_group_name=resource_group_name,<EOL>application_gateway_name=application_gateway_name,<EOL>expand=expand,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Gets the backend health of the specified application gateway in a\n        resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param application_gateway_name: The name of the application gateway.\n        :type application_gateway_name: str\n        :param expand: Expands BackendAddressPool and BackendHttpSettings\n         referenced in backend health.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         ApplicationGatewayBackendHealth or\n         ClientRawResponse<ApplicationGatewayBackendHealth> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_09_01.models.ApplicationGatewayBackendHealth]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_09_01.models.ApplicationGatewayBackendHealth]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29796:c0:m15"}
{"signature": "def process_json(filename):", "body": "logger.debug('<STR_LIT>', filename)<EOL>doecode_json = json.load(open(filename))<EOL>for record in doecode_json['<STR_LIT>']:<EOL><INDENT>yield record<EOL><DEDENT>", "docstring": "Converts a DOE CODE .json file into DOE CODE projects\nYields DOE CODE records from a DOE CODE .json file", "id": "f4687:m0"}
{"signature": "def _get_retransmission_interval(self):", "body": "return self.__retransmission_interval<EOL>", "docstring": "Getter method for retransmission_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/interfaces/interface/timers/config/retransmission_interval (uint32)\n\n    YANG Description: The number of seconds that the local system waits before\nretransmitting an unacknowledged LSA.", "id": "f23109:c1:m8"}
{"signature": "def stop(<EOL>self, resource_group_name, network_watcher_name, packet_capture_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._stop_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_watcher_name=network_watcher_name,<EOL>packet_capture_name=packet_capture_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Stops a specified packet capture session.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_watcher_name: The name of the network watcher.\n        :type network_watcher_name: str\n        :param packet_capture_name: The name of the packet capture session.\n        :type packet_capture_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.network.v2018_12_01.models.ErrorResponseException>`", "id": "f29205:c0:m7"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.PublicIPPrefixPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.PublicIPPrefixPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all public IP prefixes in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of PublicIPPrefix\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.PublicIPPrefixPaged[~azure.mgmt.network.v2018_11_01.models.PublicIPPrefix]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32795:c0:m9"}
{"signature": "@property<EOL><INDENT>def left_thumb_x(self):<DEDENT>", "body": "return self.get_axis(ControllerAxes.left_thumb_x)<EOL>", "docstring": "The absolute X axis value of the left thumb-stick, or the main stick on a joystick.", "id": "f6775:c0:m7"}
{"signature": "def to_matrix(self):", "body": "return numpy.array([[<NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>]], dtype=complex)<EOL>", "docstring": "Return a Numpy.array for the Toffoli gate.", "id": "f10826:c0:m3"}
{"signature": "def _set_flags(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={\"<STR_LIT>\": {}},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__flags = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for flags, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/is_reachability/neighbors/neighbors/default_metric/state/flags (enumeration)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_flags is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_flags() directly.\n\nYANG Description: ISIS Default-Metric Flags.", "id": "f22958:c1:m3"}
{"signature": "def _get_last_established_time(self):", "body": "return self.__last_established_time<EOL>", "docstring": "Getter method for last_established_time, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/virtual_links/virtual_link/state/last_established_time (oc-types:timeticks64)\n\n    YANG Description: The time at which the adjacency was last established with\nthe neighbor. That is to say the time at which the\nadjacency last transitioned into the FULL state.\n\nThis value is expressed as the number of seconds, relative to\nthe Unix Epoch (Jan 1, 1970 00:00:00 UTC).", "id": "f23127:c0:m20"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, network_security_group_name, security_rule_name, security_rule_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_security_group_name=network_security_group_name,<EOL>security_rule_name=security_rule_name,<EOL>security_rule_parameters=security_rule_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a security rule in the specified network security\n        group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_security_group_name: The name of the network security\n         group.\n        :type network_security_group_name: str\n        :param security_rule_name: The name of the security rule.\n        :type security_rule_name: str\n        :param security_rule_parameters: Parameters supplied to the create or\n         update network security rule operation.\n        :type security_rule_parameters:\n         ~azure.mgmt.network.v2017_11_01.models.SecurityRule\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns SecurityRule or\n         ClientRawResponse<SecurityRule> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_11_01.models.SecurityRule]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_11_01.models.SecurityRule]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f28628:c0:m5"}
{"signature": "def p_gate_id_list_1(self, program):", "body": "program[<NUM_LIT:0>] = program[<NUM_LIT:1>]<EOL>program[<NUM_LIT:0>].add_child(program[<NUM_LIT:3>])<EOL>self.update_symtab(program[<NUM_LIT:3>])<EOL>", "docstring": "gate_id_list : gate_id_list ',' id", "id": "f10971:c0:m27"}
{"signature": "def compile(marker):", "body": "try:<EOL><INDENT>return _cache[marker]<EOL><DEDENT>except KeyError:<EOL><INDENT>pass<EOL><DEDENT>if not marker.strip():<EOL><INDENT>def marker_fn(environment=None, override=None):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>return True<EOL><DEDENT><DEDENT>else:<EOL><INDENT>compiled_marker = compile_marker(parse_marker(marker))<EOL>def marker_fn(environment=None, override=None):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>if override is None:<EOL><INDENT>override = {}<EOL><DEDENT>if environment is None:<EOL><INDENT>environment = default_environment()<EOL><DEDENT>environment.update(override)<EOL>return eval(compiled_marker, environment)<EOL><DEDENT><DEDENT>marker_fn.__doc__ = marker<EOL>_cache[marker] = marker_fn<EOL>return _cache[marker]<EOL>", "docstring": "Return compiled marker as a function accepting an environment dict.", "id": "f17067:m3"}
{"signature": "def xpat_gen(self, header, msgid_range, *pattern):", "body": "args = \"<STR_LIT:U+0020>\".join(<EOL>[header, utils.unparse_msgid_range(msgid_range)] + list(pattern)<EOL>)<EOL>code, message = self.command(\"<STR_LIT>\", args)<EOL>if code != <NUM_LIT>:<EOL><INDENT>raise NNTPReplyError(code, message)<EOL><DEDENT>for line in self.info_gen(code, message):<EOL><INDENT>yield line.strip()<EOL><DEDENT>", "docstring": "Generator for the XPAT command.", "id": "f14598:c8:m39"}
{"signature": "def create_filtered_image(self, path_to_image, save_path_on_storage):", "body": "image, file_ext, image_format, mime_type = self.retrieve_image(<EOL>path_to_image<EOL>)<EOL>image, save_kwargs = self.preprocess(image, image_format)<EOL>imagefile = self.process_image(image, image_format, save_kwargs)<EOL>self.save_image(imagefile, save_path_on_storage, file_ext, mime_type)<EOL>", "docstring": "Creates a filtered image.\n`path_to_image`: The path to the image with the media directory\n                 to resize.\n`save_path_on_storage`: Where on self.storage to save the filtered\n                        image", "id": "f3819:c1:m1"}
{"signature": "@cls_named_arguments<EOL>def dad79637580d(Foo, Bar):", "body": "class Container(Injector):<EOL><INDENT>bar = Bar<EOL><DEDENT>", "docstring": "Declarative injector.", "id": "f5023:m75"}
{"signature": "def generate(self, delim='<STR_LIT:->', length=<NUM_LIT:4>, chars='<STR_LIT>'):", "body": "descriptor = self._select(self._descriptors)<EOL>noun = self._select(self._nouns)<EOL>numbers = '<STR_LIT>'.join((self._select(chars) for _ in range(length)))<EOL>return delim.join([descriptor, noun, numbers])<EOL>", "docstring": "Generate a robot name. Inspiration from Haikunator, but much more\n         poorly implemented ;)\n\nParameters\n==========\ndelim: Delimiter\nlength: TokenLength\nchars: TokenChars", "id": "f9904:c0:m0"}
{"signature": "def _set_interface_id(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__interface_id = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for interface_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/config/interface_id (oc-if:interface-id)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_interface_id is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_interface_id() directly.\n\nYANG Description: Interface for which ISIS configuration is to be applied.", "id": "f22397:c0:m6"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:true>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/state/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: Controls whether IPv4 is enabled or disabled on this\ninterface.  When IPv4 is enabled, this interface is\nconnected to an IPv4 stack, and the interface can send\nand receive IPv4 packets.", "id": "f21942:c0:m3"}
{"signature": "def setConnectString(self, connection_string):", "body": "self.m_connection_string = connection_string<EOL>pass<EOL>", "docstring": "Setter for connection string.\n        Args:\n            connection_string (str): Connection string.", "id": "f2325:c27:m1"}
{"signature": "def process_url(url, key):", "body": "logger.debug('<STR_LIT>', url)<EOL>if key is None:<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>response = requests.get(url, headers={\"<STR_LIT>\": \"<STR_LIT>\" + key})<EOL>doecode_json = response.json()<EOL>for record in doecode_json['<STR_LIT>']:<EOL><INDENT>yield record<EOL><DEDENT>", "docstring": "Yields DOE CODE records from a DOE CODE .json URL response\nConverts a DOE CODE API .json URL response into DOE CODE projects", "id": "f4687:m1"}
{"signature": "def _general_error_handler(http_error):", "body": "message = str(http_error)<EOL>if http_error.respbody is not None:<EOL><INDENT>message += '<STR_LIT:\\n>' + http_error.respbody.decode('<STR_LIT>')<EOL><DEDENT>raise AzureHttpError(message, http_error.status)<EOL>", "docstring": "Simple error handler for azure.", "id": "f41500:m0"}
{"signature": "def complete_restore(<EOL>self, location_name, operation_id, last_backup_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._complete_restore_initial(<EOL>location_name=location_name,<EOL>operation_id=operation_id,<EOL>last_backup_name=last_backup_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Completes the restore operation on a managed database.\n\n        :param location_name: The name of the region where the resource is\n         located.\n        :type location_name: str\n        :param operation_id: Management operation id that this request tries\n         to complete.\n        :type operation_id: str\n        :param last_backup_name: The last backup name to apply\n        :type last_backup_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38384:c0:m2"}
{"signature": "def walk(top, func, arg):", "body": "warnings.warnpy3k(\"<STR_LIT>\",<EOL>stacklevel=<NUM_LIT:2>)<EOL>try:<EOL><INDENT>names = os.listdir(top)<EOL><DEDENT>except os.error:<EOL><INDENT>return<EOL><DEDENT>func(arg, top, names)<EOL>for name in names:<EOL><INDENT>name = join(top, name)<EOL>if isdir(name):<EOL><INDENT>walk(name, func, arg)<EOL><DEDENT><DEDENT>", "docstring": "Directory tree walk with callback function.\n\n    For each directory in the directory tree rooted at top (including top\n    itself, but excluding '.' and '..'), call func(arg, dirname, fnames).\n    dirname is the name of the directory, and fnames a list of the names of\n    the files and subdirectories in dirname (excluding '.' and '..').  func\n    may modify the fnames list in-place (e.g. via del or slice assignment),\n    and walk will only recurse into the subdirectories whose names remain in\n    fnames; this can be used to implement a filter, or to impose a specific\n    order of visiting.  No semantics are defined for, or required of, arg,\n    beyond that arg is always passed to func.  It can be used, e.g., to pass\n    a filename pattern, or a mutable object designed to accumulate\n    statistics.  Passing None for arg is common.", "id": "f17316:m11"}
{"signature": "def approx_jacobian(x,func,epsilon,*args):", "body": "x0 = asfarray(x)<EOL>f0 = atleast_1d(func(*((x0,)+args)))<EOL>jac = zeros([len(x0),len(f0)])<EOL>dx = zeros(len(x0))<EOL>for i in range(len(x0)):<EOL><INDENT>dx[i] = epsilon<EOL>jac[i] = (func(*((x0+dx,)+args)) - f0)/epsilon<EOL>dx[i] = <NUM_LIT:0.0><EOL><DEDENT>return jac.transpose()<EOL>", "docstring": "Approximate the Jacobian matrix of a callable function.\n\nParameters\n----------\nx : array_like\n    The state vector at which to compute the Jacobian matrix.\nfunc : callable f(x,*args)\n    The vector-valued function.\nepsilon : float\n    The perturbation used to determine the partial derivatives.\nargs : sequence\n    Additional arguments passed to func.\n\nReturns\n-------\nAn array of dimensions ``(lenf, lenx)`` where ``lenf`` is the length\nof the outputs of `func`, and ``lenx`` is the number of elements in\n`x`.\n\nNotes\n-----\nThe approximation is done using forward differences.", "id": "f19426:m0"}
{"signature": "def __init__(self, data=None, url=None, filename=None, format=u'<STR_LIT>', embed=None):", "body": "if filename is not None:<EOL><INDENT>ext = self._find_ext(filename)<EOL><DEDENT>elif url is not None:<EOL><INDENT>ext = self._find_ext(url)<EOL><DEDENT>elif data.startswith('<STR_LIT:http>'):<EOL><INDENT>ext = self._find_ext(data)<EOL><DEDENT>else:<EOL><INDENT>ext = None<EOL><DEDENT>if ext is not None:<EOL><INDENT>if ext == u'<STR_LIT>' or ext == u'<STR_LIT>':<EOL><INDENT>format = u'<STR_LIT>'<EOL><DEDENT>if ext == u'<STR_LIT>':<EOL><INDENT>format = u'<STR_LIT>'<EOL><DEDENT><DEDENT>self.format = unicode(format).lower()<EOL>self.embed = embed if embed is not None else (url is None)<EOL>super(Image, self).__init__(data=data, url=url, filename=filename)<EOL>", "docstring": "Create a display an PNG/JPEG image given raw data.\n\n        When this object is returned by an expression or passed to the\n        display function, it will result in the image being displayed\n        in the frontend.\n\n        Parameters\n        ----------\n        data : unicode, str or bytes\n            The raw data or a URL to download the data from.\n        url : unicode\n            A URL to download the data from.\n        filename : unicode\n            Path to a local file to load the data from.\n        format : unicode\n            The format of the image data (png/jpeg/jpg). If a filename or URL is given\n            for format will be inferred from the filename extension.\n        embed : bool\n            Should the image data be embedded using a data URI (True) or be\n            loaded using an <img> tag. Set this to True if you want the image\n            to be viewable later with no internet connection in the notebook.\n\n            Default is `True`, unless the keyword argument `url` is set, then\n            default value is `False`.\n\n            Note that QtConsole is not able to display images if `embed` is set to `False`\n\n        Examples\n        --------\n        # embed implicitly True, works in qtconsole and notebook\n        Image('http://www.google.fr/images/srpr/logo3w.png')\n\n        # embed implicitly False, does not works in qtconsole but works in notebook if\n        # internet connection available\n        Image(url='http://www.google.fr/images/srpr/logo3w.png')", "id": "f21443:c8:m0"}
{"signature": "@property<EOL><INDENT>def is_anonymous(self):<DEDENT>", "body": "return False<EOL>", "docstring": "Required by flask_login", "id": "f9363:c0:m3"}
{"signature": "def __init__(self, text, source=None):", "body": "self._text = text<EOL>self._source_name = str(source) if source else \"<STR_LIT>\"<EOL>", "docstring": ":param text: Entity's text\n:param source: Source of the entity, which is converted to a string via `str()` to produce the source name", "id": "f18114:c0:m0"}
{"signature": "@property<EOL><INDENT>def last_returncode(self):<DEDENT>", "body": "try:<EOL><INDENT>return self.log[-<NUM_LIT:1>][<NUM_LIT:1>]<EOL><DEDENT>except IndexError:<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>", "docstring": "Get the return code of the last command exevuted.", "id": "f10130:c1:m1"}
{"signature": "def _set_hop_limit(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__hop_limit = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for hop_limit, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/ip/state/hop_limit (uint8)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_hop_limit is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_hop_limit() directly.\n\n    YANG Description: The IP packet's hop limit -- known as TTL (in hops) in\nIPv4 packets, and hop limit in IPv6", "id": "f22152:c1:m24"}
{"signature": "def add_signing_keys(self, statement):", "body": "statement['<STR_LIT>'] = self.self_signer.export_jwks_as_json()<EOL>return statement<EOL>", "docstring": "Adding signing keys by value to a statement.\n\n:param statement: Metadata statement to be extended\n:return: The extended statement", "id": "f14439:c0:m6"}
{"signature": "def case(pred_fn_pairs, default=None, exclusive=False, name='<STR_LIT>'):", "body": "return control_flow_ops._case_helper(  <EOL>cond, pred_fn_pairs, default, exclusive, name, allow_python_preds=True)<EOL>", "docstring": "Like tf.case, except attempts to statically evaluate predicates.\n\n    If any predicate in `pred_fn_pairs` is a bool or has a constant value, the\n    associated callable will be called or omitted depending on its value.\n    Otherwise this functions like tf.case.\n\n    Args:\n      pred_fn_pairs: Dict or list of pairs of a boolean scalar tensor and a\n                     callable which returns a list of tensors.\n      default: Optional callable that returns a list of tensors.\n      exclusive: True iff at most one predicate is allowed to evaluate to `True`.\n      name: A name for this operation (optional).\n\n    Returns:\n      The tensors returned by the first pair whose predicate evaluated to True, or\n      those returned by `default` if none does.\n\n    Raises:\n      TypeError: If `pred_fn_pairs` is not a list/dictionary.\n      TypeError: If `pred_fn_pairs` is a list but does not contain 2-tuples.\n      TypeError: If `fns[i]` is not callable for any i, or `default` is not\n                 callable.", "id": "f15604:m7"}
{"signature": "def list_by_resource_group(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_resource_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ExpressRouteCrossConnectionPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ExpressRouteCrossConnectionPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves all the ExpressRouteCrossConnections in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ExpressRouteCrossConnection\n        :rtype:\n         ~azure.mgmt.network.v2018_12_01.models.ExpressRouteCrossConnectionPaged[~azure.mgmt.network.v2018_12_01.models.ExpressRouteCrossConnection]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29201:c0:m2"}
{"signature": "def as_strided(x, shape=None, strides=None):", "body": "interface = dict(x.__array_interface__)<EOL>if shape is not None:<EOL><INDENT>interface['<STR_LIT>'] = tuple(shape)<EOL><DEDENT>if strides is not None:<EOL><INDENT>interface['<STR_LIT>'] = tuple(strides)<EOL><DEDENT>array = np.asarray(DummyArray(interface, base=x))<EOL>if array.dtype.kind == '<STR_LIT>':<EOL><INDENT>array.dtype = x.dtype<EOL><DEDENT>return array<EOL>", "docstring": "Make an ndarray from the given array with the given shape and strides.", "id": "f19112:m0"}
{"signature": "def put_new_symbol(  <EOL>self,<EOL>s: sym.Symbol,<EOL>binding: Binding,<EOL>warn_on_shadowed_name: bool = True,<EOL>warn_on_shadowed_var: bool = True,<EOL>warn_if_unused: bool = True,<EOL>):", "body": "st = self.symbol_table<EOL>if warn_on_shadowed_name and self.warn_on_shadowed_name:<EOL><INDENT>if st.find_symbol(s) is not None:<EOL><INDENT>logger.warning(f\"<STR_LIT>\")<EOL><DEDENT><DEDENT>if (<EOL>warn_on_shadowed_name or warn_on_shadowed_var<EOL>) and self.warn_on_shadowed_var:<EOL><INDENT>if self.current_ns.find(s) is not None:<EOL><INDENT>logger.warning(f\"<STR_LIT>\")<EOL><DEDENT><DEDENT>if s.meta is not None and s.meta.entry(SYM_NO_WARN_WHEN_UNUSED_META_KEY, None):<EOL><INDENT>warn_if_unused = False<EOL><DEDENT>st.new_symbol(s, binding, warn_if_unused=warn_if_unused)<EOL>", "docstring": "Add a new symbol to the symbol table.\n\n        This function allows individual warnings to be disabled for one run\n        by supplying keyword arguments temporarily disabling those warnings.\n        In certain cases, we do not want to issue warnings again for a\n        previously checked case, so this is a simple way of disabling these\n        warnings for those cases.\n\n        If WARN_ON_SHADOWED_NAME compiler option is active and the\n        warn_on_shadowed_name keyword argument is True, then a warning will be\n        emitted if a local name is shadowed by another local name. Note that\n        WARN_ON_SHADOWED_NAME implies WARN_ON_SHADOWED_VAR.\n\n        If WARN_ON_SHADOWED_VAR compiler option is active and the\n        warn_on_shadowed_var keyword argument is True, then a warning will be\n        emitted if a named var is shadowed by a local name.", "id": "f1064:c3:m13"}
{"signature": "@classmethod<EOL><INDENT>def travis_permissions(cls):<DEDENT>", "body": "if PyFunceble.CONFIGURATION[\"<STR_LIT>\"]:<EOL><INDENT>try:<EOL><INDENT>build_dir = PyFunceble.environ[\"<STR_LIT>\"]<EOL>commands = [<EOL>\"<STR_LIT>\" % (build_dir),<EOL>\"<STR_LIT>\" % (build_dir),<EOL>\"<STR_LIT>\" % (build_dir),<EOL>\"<STR_LIT>\"<EOL>% (build_dir + PyFunceble.directory_separator),<EOL>r\"<STR_LIT>\" % (build_dir),<EOL>]<EOL>for command in commands:<EOL><INDENT>Command(command).execute()<EOL><DEDENT>if Command(\"<STR_LIT>\").execute() == \"<STR_LIT>\":<EOL><INDENT>Command(\"<STR_LIT>\").execute()<EOL><DEDENT><DEDENT>except KeyError:<EOL><INDENT>pass<EOL><DEDENT><DEDENT>", "docstring": "Set permissions in order to avoid issues before commiting.", "id": "f8231:c0:m1"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/state (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_state is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_state() directly.\n\n    YANG Description: Operational state parameters relating to the OSPFv2\narea", "id": "f23098:c0:m3"}
{"signature": "def rebuild_auth(self, prepared_request, response):", "body": "headers = prepared_request.headers<EOL>url = prepared_request.url<EOL>if '<STR_LIT>' in headers:<EOL><INDENT>original_parsed = urlparse(response.request.url)<EOL>redirect_parsed = urlparse(url)<EOL>if (original_parsed.hostname != redirect_parsed.hostname):<EOL><INDENT>del headers['<STR_LIT>']<EOL><DEDENT><DEDENT>new_auth = get_netrc_auth(url) if self.trust_env else None<EOL>if new_auth is not None:<EOL><INDENT>prepared_request.prepare_auth(new_auth)<EOL><DEDENT>return<EOL>", "docstring": "When being redirected we may want to strip authentication from the\nrequest to avoid leaking credentials. This method intelligently removes\nand reapplies authentication where possible to avoid credential loss.", "id": "f17263:c0:m1"}
{"signature": "def concat(self, other):", "body": "dfs = []<EOL>if isinstance(self, DataFrameConcatenated):<EOL><INDENT>dfs.extend(self.dfs)<EOL><DEDENT>else:<EOL><INDENT>dfs.extend([self])<EOL><DEDENT>if isinstance(other, DataFrameConcatenated):<EOL><INDENT>dfs.extend(other.dfs)<EOL><DEDENT>else:<EOL><INDENT>dfs.extend([other])<EOL><DEDENT>return DataFrameConcatenated(dfs)<EOL>", "docstring": "Concatenates two DataFrames, adding the rows of one the other DataFrame to the current, returned in a new DataFrame.\n\n        No copy of the data is made.\n\n        :param other: The other DataFrame that is concatenated with this DataFrame\n        :return: New DataFrame with the rows concatenated\n        :rtype: DataFrameConcatenated", "id": "f6914:c1:m13"}
{"signature": "def _get_status(self):", "body": "return self.__status<EOL>", "docstring": "Getter method for status, mapped from YANG variable /vlans/vlan/state/status (enumeration)\n\nYANG Description: Admin state of the VLAN", "id": "f21837:c0:m8"}
{"signature": "def get(<EOL>self, resource_group_name, registry_name, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', min_length=<NUM_LIT:1>),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", registry_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the properties of the specified container registry.\n\n        :param resource_group_name: The name of the resource group to which\n         the container registry belongs.\n        :type resource_group_name: str\n        :param registry_name: The name of the container registry.\n        :type registry_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Registry or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.containerregistry.v2018_09_01.models.Registry or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f23973:c0:m4"}
{"signature": "@classmethod<EOL><INDENT>@BatchController.memoise<EOL>def _filtered_clauses(cls, user):<DEDENT>", "body": "types = list(ConditionController._controllers())<EOL>discounttypes = [<EOL>i for i in types if issubclass(i, conditions.DiscountBase)<EOL>]<EOL>product_clauses = conditions.DiscountForProduct.objects.all()<EOL>product_clauses = product_clauses.select_related(<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>)<EOL>category_clauses = conditions.DiscountForCategory.objects.all()<EOL>category_clauses = category_clauses.select_related(<EOL>\"<STR_LIT>\",<EOL>\"<STR_LIT>\",<EOL>)<EOL>all_subsets = []<EOL>for discounttype in discounttypes:<EOL><INDENT>discounts = discounttype.objects.all()<EOL>ctrl = ConditionController.for_type(discounttype)<EOL>discounts = ctrl.pre_filter(discounts, user)<EOL>all_subsets.append(discounts)<EOL><DEDENT>filtered_discounts = list(itertools.chain(*all_subsets))<EOL>from_filter = dict((i.id, i) for i in filtered_discounts)<EOL>clause_sets = (<EOL>product_clauses.filter(discount__in=filtered_discounts),<EOL>category_clauses.filter(discount__in=filtered_discounts),<EOL>)<EOL>clause_sets = (<EOL>cls._annotate_with_past_uses(i, user) for i in clause_sets<EOL>)<EOL>discount_clauses = set(itertools.chain(*clause_sets))<EOL>for clause in discount_clauses:<EOL><INDENT>clause.discount = from_filter[clause.discount.id]<EOL><DEDENT>return discount_clauses<EOL>", "docstring": "Returns:\n    Sequence[DiscountForProduct | DiscountForCategory]: All clauses\n    that passed the filter function.", "id": "f17915:c1:m1"}
{"signature": "def main():", "body": "height, width = <NUM_LIT>, <NUM_LIT><EOL>inputs = tf.Variable(tf.random_uniform((<NUM_LIT:1>, height, width, <NUM_LIT:3>)), name='<STR_LIT:input>')<EOL>inputs = tf.identity(inputs, \"<STR_LIT>\")<EOL>with slim.arg_scope(overfeat.overfeat_arg_scope()):<EOL><INDENT>net, end_points = overfeat.overfeat(inputs, is_training = False)<EOL><DEDENT>print(\"<STR_LIT>\")<EOL>for n in end_points:<EOL><INDENT>print(n + \"<STR_LIT>\" + str(end_points[n]))<EOL><DEDENT>net_outputs = map(lambda x: tf.get_default_graph().get_tensor_by_name(x), argv[<NUM_LIT:2>].split('<STR_LIT:U+002C>'))<EOL>run_model(net_outputs, argv[<NUM_LIT:1>], '<STR_LIT>', argv[<NUM_LIT:3>] == '<STR_LIT:True>')<EOL>", "docstring": "You can also run these commands manually to generate the pb file\n1. git clone https://github.com/tensorflow/models.git\n2. export PYTHONPATH=Path_to_your_model_folder\n3. python alexnet.py", "id": "f13195:m0"}
{"signature": "def get(<EOL>self, resource_group_name, ddos_protection_plan_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", ddos_protection_plan_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets information about the specified DDoS protection plan.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param ddos_protection_plan_name: The name of the DDoS protection\n         plan.\n        :type ddos_protection_plan_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: DdosProtectionPlan or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2018_07_01.models.DdosProtectionPlan or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34195:c0:m3"}
{"signature": "def write_header(self,<EOL>shape,<EOL>mclass,<EOL>is_complex=False,<EOL>is_logical=False,<EOL>nzmax=<NUM_LIT:0>):", "body": "<EOL>name = self._var_name<EOL>is_global = self._var_is_global<EOL>self._mat_tag_pos = self.file_stream.tell()<EOL>self.write_bytes(self.mat_tag)<EOL>af = np.zeros((), NDT_ARRAY_FLAGS)<EOL>af['<STR_LIT>'] = miUINT32<EOL>af['<STR_LIT>'] = <NUM_LIT:8><EOL>flags = is_complex << <NUM_LIT:3> | is_global << <NUM_LIT:2> | is_logical << <NUM_LIT:1><EOL>af['<STR_LIT>'] = mclass | flags << <NUM_LIT:8><EOL>af['<STR_LIT>'] = nzmax<EOL>self.write_bytes(af)<EOL>self.write_element(np.array(shape, dtype='<STR_LIT>'))<EOL>name = np.asarray(name)<EOL>if name == '<STR_LIT>':  <EOL><INDENT>self.write_smalldata_element(name, miINT8, <NUM_LIT:0>)<EOL><DEDENT>else:<EOL><INDENT>self.write_element(name, miINT8)<EOL><DEDENT>self._var_name = '<STR_LIT>'<EOL>self._var_is_global = False<EOL>", "docstring": "Write header for given data options\n        shape : sequence\n           array shape\n        mclass      - mat5 matrix class\n        is_complex  - True if matrix is complex\n        is_logical  - True if matrix is logical\n        nzmax        - max non zero elements for sparse arrays\n\n        We get the name and the global flag from the object, and reset\n        them to defaults after we've used them", "id": "f19359:c1:m6"}
{"signature": "def _set_ethertype(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=[<EOL>RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:16>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>],<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ethertype = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ethertype, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/l2/config/ethertype (oc-pkt-match-types:ethertype-type)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_ethertype is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_ethertype() directly.\n\nYANG Description: Ethertype field to match in Ethernet packets", "id": "f22149:c1:m15"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/state (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_state is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_state() directly.\n\n    YANG Description: Operational state parameters relating to the forwarding\npolicy.", "id": "f22146:c0:m9"}
{"signature": "def parse_genes(gene_lines):", "body": "genes = []<EOL>header = []<EOL>hgnc_identifiers = set()<EOL>delimiter = '<STR_LIT:\\t>'<EOL>delimiters = ['<STR_LIT:\\t>', '<STR_LIT:U+0020>', '<STR_LIT:;>']<EOL>for i,line in enumerate(gene_lines):<EOL><INDENT>line = line.rstrip()<EOL>if not len(line) > <NUM_LIT:0>:<EOL><INDENT>continue<EOL><DEDENT>if line.startswith('<STR_LIT:#>'):<EOL><INDENT>if not line.startswith('<STR_LIT>'):<EOL><INDENT>line_length = <NUM_LIT:0><EOL>delimiter = None<EOL>for alt in delimiters:<EOL><INDENT>head_line = line.split(alt)<EOL>if len(head_line) > line_length:<EOL><INDENT>line_length = len(head_line)<EOL>delimiter = alt<EOL><DEDENT><DEDENT>header = [word.lower() for word in line[<NUM_LIT:1>:].split(delimiter)]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if i == <NUM_LIT:0>:<EOL><INDENT>line_length = <NUM_LIT:0><EOL>for alt in delimiters:<EOL><INDENT>head_line = line.split(alt)<EOL>if len(head_line) > line_length:<EOL><INDENT>line_length = len(head_line)<EOL>delimiter = alt<EOL><DEDENT><DEDENT>if ('<STR_LIT>' in line or '<STR_LIT>' in line):<EOL><INDENT>header = [word.lower() for word in line.split(delimiter)]<EOL>continue<EOL><DEDENT>if line.split(delimiter)[<NUM_LIT:0>].isdigit():<EOL><INDENT>header = ['<STR_LIT>']<EOL><DEDENT>else:<EOL><INDENT>header = ['<STR_LIT>']<EOL><DEDENT><DEDENT>splitted_line = line.split(delimiter)<EOL>gene_info = dict(zip(header, splitted_line))<EOL>info_found = False<EOL>for key in gene_info:<EOL><INDENT>if gene_info[key]:<EOL><INDENT>info_found = True<EOL>break<EOL><DEDENT><DEDENT>if not info_found:<EOL><INDENT>continue<EOL><DEDENT>try:<EOL><INDENT>gene = parse_gene(gene_info)<EOL><DEDENT>except Exception as e:<EOL><INDENT>LOG.warning(e)<EOL>raise SyntaxError(\"<STR_LIT>\".format(i + <NUM_LIT:1>))<EOL><DEDENT>identifier = gene.pop('<STR_LIT>')<EOL>if not identifier in hgnc_identifiers:<EOL><INDENT>hgnc_identifiers.add(identifier)<EOL>genes.append(gene)<EOL><DEDENT><DEDENT><DEDENT>return genes<EOL>", "docstring": "Parse a file with genes and return the hgnc ids\n\n    Args:\n        gene_lines(iterable(str)): Stream with genes\n\n    Returns:\n        genes(list(dict)): Dictionaries with relevant gene info", "id": "f13841:m2"}
{"signature": "def _called_in_methods(func, klass, methods):", "body": "if not isinstance(func, astroid.FunctionDef):<EOL><INDENT>return False<EOL><DEDENT>for method in methods:<EOL><INDENT>try:<EOL><INDENT>infered = klass.getattr(method)<EOL><DEDENT>except astroid.NotFoundError:<EOL><INDENT>continue<EOL><DEDENT>for infer_method in infered:<EOL><INDENT>for call in infer_method.nodes_of_class(astroid.Call):<EOL><INDENT>try:<EOL><INDENT>bound = next(call.func.infer())<EOL><DEDENT>except (astroid.InferenceError, StopIteration):<EOL><INDENT>continue<EOL><DEDENT>if not isinstance(bound, astroid.BoundMethod):<EOL><INDENT>continue<EOL><DEDENT>func_obj = bound._proxied<EOL>if isinstance(func_obj, astroid.UnboundMethod):<EOL><INDENT>func_obj = func_obj._proxied<EOL><DEDENT>if func_obj.name == func.name:<EOL><INDENT>return True<EOL><DEDENT><DEDENT><DEDENT><DEDENT>return False<EOL>", "docstring": "Check if the func was called in any of the given methods,\n    belonging to the *klass*. Returns True if so, False otherwise.", "id": "f18870:m11"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_ipv4_reachability/prefixes/prefix/subTLVs/subTLVs/tag/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of sub-TLV 1.", "id": "f22946:c1:m3"}
