0	self.error = True<EOL>msg = ERROR_MESSAGES['<STR_LIT>'].format(p.lineno(<NUM_LIT:1>))<EOL>self.logger.log(msg)<EOL>
1	if start_node is None:<EOL><INDENT>start_node  = self.__root<EOL>level = <NUM_LIT:0><EOL><DEDENT>if start_node is None:<EOL><INDENT>return []<EOL><DEDENT>items = [ (level, start_node) ]<EOL>for child in self.children(start_node):<EOL><INDENT>if child is not None:<EOL><INDENT>items += self.traverse(child, level + <NUM_LIT:1>)<EOL><DEDENT><DEDENT>return items<EOL>
2	self._salted_password = self.Hi(self.Normalize(self.password), salt,<EOL>iteration_count)<EOL>self.password = None <EOL>if self.channel_binding:<EOL><INDENT>channel_binding = b"<STR_LIT>" + standard_b64encode(self._gs2_header +<EOL>self._cb_data)<EOL><DEDENT>else:<EOL><INDENT>channel_binding = b"<STR_LIT>" + standard_b64encode(self._gs2_header)<EOL><DEDENT>client_final_message_without_proof = (channel_binding + b"<STR_LIT>" + nonce)<EOL>client_key = self.HMAC(self._salted_password, b"<STR_LIT>")<EOL>stored_key = self.H(client_key)<EOL>auth_message = ( self._client_first_message_bare + b"<STR_LIT:U+002C>" +<EOL>self._server_first_message + b"<STR_LIT:U+002C>" +<EOL>client_final_message_without_proof )<EOL>self._auth_message = auth_message<EOL>client_signature = self.HMAC(stored_key, auth_message)<EOL>client_proof = self.XOR(client_key, client_signature)<EOL>proof = b"<STR_LIT>" + standard_b64encode(client_proof)<EOL>client_final_message = (client_final_message_without_proof + b"<STR_LIT:U+002C>" +<EOL>proof)<EOL>return Response(client_final_message)<EOL>
3	if available_indexes and len(available_indexes) == <NUM_LIT:1>:<EOL><INDENT>index_center = available_indexes[<NUM_LIT:0>]<EOL>return [ available_indexes ], self.__pointer_data[index_center]<EOL><DEDENT>local_data = self.__pointer_data<EOL>if available_indexes:<EOL><INDENT>local_data = [ self.__pointer_data[i] for i in available_indexes ]<EOL><DEDENT>local_centers = centers<EOL>if centers is None:<EOL><INDENT>local_centers = kmeans_plusplus_initializer(local_data, <NUM_LIT:2>, kmeans_plusplus_initializer.FARTHEST_CENTER_CANDIDATE).initialize()<EOL><DEDENT>kmeans_instance = kmeans(local_data, local_centers, tolerance=self.__tolerance, ccore=False)<EOL>kmeans_instance.process()<EOL>local_centers = kmeans_instance.get_centers()<EOL>clusters = kmeans_instance.get_clusters()<EOL>if available_indexes:<EOL><INDENT>clusters = self.__local_to_global_clusters(clusters, available_indexes)<EOL><DEDENT>return clusters, local_centers<EOL>
4	results = self.communicationChannel.receive()<EOL>if self.nruns != len(results):<EOL><INDENT>import logging<EOL>logger = logging.getLogger(__name__)<EOL>logger.warning(<EOL>'<STR_LIT>'.format(<EOL>len(results),<EOL>self.nruns<EOL>))<EOL><DEDENT>return results<EOL>
5	results = self.get_temperatures(sensors=[sensor,])<EOL>if format == '<STR_LIT>':<EOL><INDENT>return results[sensor]['<STR_LIT>']<EOL><DEDENT>elif format == '<STR_LIT>':<EOL><INDENT>return results[sensor]['<STR_LIT>']<EOL><DEDENT>elif format == '<STR_LIT>':<EOL><INDENT>return results[sensor]['<STR_LIT>']<EOL><DEDENT>else:<EOL><INDENT>raise ValueError("<STR_LIT>")<EOL><DEDENT>
6	print("<STR_LIT>")<EOL>for c in range(self.numberOfCols):<EOL><INDENT>print(int(x[c]), end='<STR_LIT:U+0020>')<EOL><DEDENT>print()<EOL>
7	if self.val == other:<EOL><INDENT>self._err('<STR_LIT>' % (self.val, other))<EOL><DEDENT>return self<EOL>
8	return self.legendPatch<EOL>
9	raise NotImplementedError()<EOL>
