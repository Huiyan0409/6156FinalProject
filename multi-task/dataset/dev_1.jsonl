{"signature": "def p_file_type_2(self, p):", "body": "self.error = True<EOL>msg = ERROR_MESSAGES['<STR_LIT>'].format(p.lineno(<NUM_LIT:1>))<EOL>self.logger.log(msg)<EOL>", "docstring": "file_type : FILE_TYPE error", "id": "f3753:c0:m57"}
{"signature": "def traverse(self, start_node = None, level = None):", "body": "if start_node is None:<EOL><INDENT>start_node  = self.__root<EOL>level = <NUM_LIT:0><EOL><DEDENT>if start_node is None:<EOL><INDENT>return []<EOL><DEDENT>items = [ (level, start_node) ]<EOL>for child in self.children(start_node):<EOL><INDENT>if child is not None:<EOL><INDENT>items += self.traverse(child, level + <NUM_LIT:1>)<EOL><DEDENT><DEDENT>return items<EOL>", "docstring": "!\n        @brief Traverses all nodes of subtree that is defined by node specified in input parameter.\n\n        @param[in] start_node (node): Node from that travering of subtree is performed.\n        @param[in, out] level (uint): Should be ignored by application.\n\n        @return (list) All nodes of the subtree.", "id": "f15715:c2:m14"}
{"signature": "def _make_response(self, nonce, salt, iteration_count):", "body": "self._salted_password = self.Hi(self.Normalize(self.password), salt,<EOL>iteration_count)<EOL>self.password = None <EOL>if self.channel_binding:<EOL><INDENT>channel_binding = b\"<STR_LIT>\" + standard_b64encode(self._gs2_header +<EOL>self._cb_data)<EOL><DEDENT>else:<EOL><INDENT>channel_binding = b\"<STR_LIT>\" + standard_b64encode(self._gs2_header)<EOL><DEDENT>client_final_message_without_proof = (channel_binding + b\"<STR_LIT>\" + nonce)<EOL>client_key = self.HMAC(self._salted_password, b\"<STR_LIT>\")<EOL>stored_key = self.H(client_key)<EOL>auth_message = ( self._client_first_message_bare + b\"<STR_LIT:U+002C>\" +<EOL>self._server_first_message + b\"<STR_LIT:U+002C>\" +<EOL>client_final_message_without_proof )<EOL>self._auth_message = auth_message<EOL>client_signature = self.HMAC(stored_key, auth_message)<EOL>client_proof = self.XOR(client_key, client_signature)<EOL>proof = b\"<STR_LIT>\" + standard_b64encode(client_proof)<EOL>client_final_message = (client_final_message_without_proof + b\"<STR_LIT:U+002C>\" +<EOL>proof)<EOL>return Response(client_final_message)<EOL>", "docstring": "Make a response for the first challenge from the server.\n\n        :return: the response or a failure indicator.\n        :returntype: `sasl.Response` or `sasl.Failure`", "id": "f15238:c1:m4"}
{"signature": "def __improve_parameters(self, centers, available_indexes = None):", "body": "if available_indexes and len(available_indexes) == <NUM_LIT:1>:<EOL><INDENT>index_center = available_indexes[<NUM_LIT:0>]<EOL>return [ available_indexes ], self.__pointer_data[index_center]<EOL><DEDENT>local_data = self.__pointer_data<EOL>if available_indexes:<EOL><INDENT>local_data = [ self.__pointer_data[i] for i in available_indexes ]<EOL><DEDENT>local_centers = centers<EOL>if centers is None:<EOL><INDENT>local_centers = kmeans_plusplus_initializer(local_data, <NUM_LIT:2>, kmeans_plusplus_initializer.FARTHEST_CENTER_CANDIDATE).initialize()<EOL><DEDENT>kmeans_instance = kmeans(local_data, local_centers, tolerance=self.__tolerance, ccore=False)<EOL>kmeans_instance.process()<EOL>local_centers = kmeans_instance.get_centers()<EOL>clusters = kmeans_instance.get_clusters()<EOL>if available_indexes:<EOL><INDENT>clusters = self.__local_to_global_clusters(clusters, available_indexes)<EOL><DEDENT>return clusters, local_centers<EOL>", "docstring": "!\n        @brief Performs k-means clustering in the specified region.\n\n        @param[in] centers (list): Centers of clusters.\n        @param[in] available_indexes (list): Indexes that defines which points can be used for k-means clustering, if None - then all points are used.\n\n        @return (list) List of allocated clusters, each cluster contains indexes of objects in list of data.", "id": "f15593:c1:m5"}
{"signature": "def end(self):", "body": "results = self.communicationChannel.receive()<EOL>if self.nruns != len(results):<EOL><INDENT>import logging<EOL>logger = logging.getLogger(__name__)<EOL>logger.warning(<EOL>'<STR_LIT>'.format(<EOL>len(results),<EOL>self.nruns<EOL>))<EOL><DEDENT>return results<EOL>", "docstring": "wait until all event loops end and returns the results.", "id": "f9110:c0:m8"}
{"signature": "def get_temperature(self, format='<STR_LIT>', sensor=<NUM_LIT:0>):", "body": "results = self.get_temperatures(sensors=[sensor,])<EOL>if format == '<STR_LIT>':<EOL><INDENT>return results[sensor]['<STR_LIT>']<EOL><DEDENT>elif format == '<STR_LIT>':<EOL><INDENT>return results[sensor]['<STR_LIT>']<EOL><DEDENT>elif format == '<STR_LIT>':<EOL><INDENT>return results[sensor]['<STR_LIT>']<EOL><DEDENT>else:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Get device temperature reading.", "id": "f11313:c0:m10"}
{"signature": "def printInput(self, x):", "body": "print(\"<STR_LIT>\")<EOL>for c in range(self.numberOfCols):<EOL><INDENT>print(int(x[c]), end='<STR_LIT:U+0020>')<EOL><DEDENT>print()<EOL>", "docstring": "TODO: document\n\n:param x: \n:return:", "id": "f17565:c0:m27"}
{"signature": "def is_not_equal_to(self, other):", "body": "if self.val == other:<EOL><INDENT>self._err('<STR_LIT>' % (self.val, other))<EOL><DEDENT>return self<EOL>", "docstring": "Asserts that val is not equal to other.", "id": "f9307:c0:m3"}
{"signature": "def get_frame(self):", "body": "return self.legendPatch<EOL>", "docstring": "return the Rectangle instance used to frame the legend", "id": "f17172:c0:m12"}
{"signature": "def create_effect_instances(self):", "body": "raise NotImplementedError()<EOL>", "docstring": "Create instances of effects.\nMust be implemented or ``NotImplementedError`` is raised.", "id": "f14467:c0:m4"}