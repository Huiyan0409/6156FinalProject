{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.RouteFilterPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.RouteFilterPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all route filters in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of RouteFilter\n        :rtype:\n         ~azure.mgmt.network.v2017_03_01.models.RouteFilterPaged[~azure.mgmt.network.v2017_03_01.models.RouteFilter]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31198:c0:m9"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/state (container)\n\n    YANG Description: State information relating to the prefix-limit for the\nAFI-SAFI", "id": "f23226:c1:m5"}
{"signature": "def create_prebuilt_entity_role(<EOL>self, app_id, version_id, entity_id, name=None, custom_headers=None, raw=False, **operation_config):", "body": "entity_role_create_object = models.EntityRoleCreateObject(name=name)<EOL>url = self.create_prebuilt_entity_role.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", app_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", version_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", entity_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>body_content = self._serialize.body(entity_role_create_object, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT:str>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Create a role for a prebuilt entity in a version of the application.\n\n        :param app_id: The application ID.\n        :type app_id: str\n        :param version_id: The version ID.\n        :type version_id: str\n        :param entity_id: The entity model ID.\n        :type entity_id: str\n        :param name: The entity role name.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: str or ClientRawResponse if raw=true\n        :rtype: str or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException>`", "id": "f43227:c0:m59"}
{"signature": "def get_learned_routes(<EOL>self, resource_group_name, virtual_network_gateway_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._get_learned_routes_initial(<EOL>resource_group_name=resource_group_name,<EOL>virtual_network_gateway_name=virtual_network_gateway_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "This operation retrieves a list of routes the virtual network gateway\n        has learned, including routes learned from BGP peers.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_gateway_name: The name of the virtual network\n         gateway.\n        :type virtual_network_gateway_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns GatewayRouteListResult\n         or ClientRawResponse<GatewayRouteListResult> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_07_01.models.GatewayRouteListResult]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_07_01.models.GatewayRouteListResult]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34232:c0:m21"}
{"signature": "@classmethod<EOL><INDENT>def class_config_section(cls):<DEDENT>", "body": "def c(s):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>s = '<STR_LIT>'.join(wrap_paragraphs(s, <NUM_LIT>))<EOL>return '<STR_LIT>' + s.replace('<STR_LIT:\\n>', '<STR_LIT>')<EOL><DEDENT>breaker = '<STR_LIT:#>' + '<STR_LIT:->'*<NUM_LIT><EOL>s = \"<STR_LIT>\"%cls.__name__<EOL>lines = [breaker, s, breaker, '<STR_LIT>']<EOL>desc = cls.class_traits().get('<STR_LIT:description>')<EOL>if desc:<EOL><INDENT>desc = desc.default_value<EOL><DEDENT>else:<EOL><INDENT>desc = getattr(cls, '<STR_LIT>', '<STR_LIT>')<EOL><DEDENT>if desc:<EOL><INDENT>lines.append(c(desc))<EOL>lines.append('<STR_LIT>')<EOL><DEDENT>parents = []<EOL>for parent in cls.mro():<EOL><INDENT>if parent is not cls and issubclass(parent, Configurable) andparent.class_traits(config=True):<EOL><INDENT>parents.append(parent)<EOL><DEDENT><DEDENT>if parents:<EOL><INDENT>pstr = '<STR_LIT:U+002CU+0020>'.join([ p.__name__ for p in parents ])<EOL>lines.append(c('<STR_LIT>'%(cls.__name__, pstr)))<EOL>lines.append('<STR_LIT>')<EOL><DEDENT>for name,trait in cls.class_traits(config=True).items():<EOL><INDENT>help = trait.get_metadata('<STR_LIT>') or '<STR_LIT>'<EOL>lines.append(c(help))<EOL>lines.append('<STR_LIT>'%(cls.__name__, name, trait.get_default_value()))<EOL>lines.append('<STR_LIT>')<EOL><DEDENT>return '<STR_LIT:\\n>'.join(lines)<EOL>", "docstring": "Get the config class config section", "id": "f21494:c2:m6"}
{"signature": "def set_option(self, section, option, value):", "body": "raise NotImplementedError<EOL>", "docstring": "Set an option in storage", "id": "f17531:c2:m17"}
{"signature": "def _get_tag(self):", "body": "return self.__tag<EOL>", "docstring": "Getter method for tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_reachability/prefixes/prefixes/subTLVs/subTLVs/tag (container)\n\nYANG Description: This container defines sub-TLV 1.", "id": "f22661:c0:m8"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af/segment_routing/prefix_sids/prefix_sid/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration parameters for the IGP Prefix SID.", "id": "f22450:c0:m6"}
{"signature": "def handle_error(errcode):", "body": "if type(errcode) is c_int:<EOL><INDENT>errcode = errcode.value<EOL><DEDENT>if errcode == <NUM_LIT:0>:<EOL><INDENT>pass  <EOL><DEDENT>elif errcode == -<NUM_LIT:1>:<EOL><INDENT>raise TimeoutError(\"<STR_LIT>\")<EOL><DEDENT>elif errcode == -<NUM_LIT:2>:<EOL><INDENT>raise LostError(\"<STR_LIT>\")<EOL><DEDENT>elif errcode == -<NUM_LIT:3>:<EOL><INDENT>raise InvalidArgumentError(\"<STR_LIT>\")<EOL><DEDENT>elif errcode == -<NUM_LIT:4>:<EOL><INDENT>raise InternalError(\"<STR_LIT>\")<EOL><DEDENT>elif errcode < <NUM_LIT:0>: <EOL><INDENT>raise RuntimeError(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Error handler function. Translates an error code into an exception.", "id": "f12888:m8"}
{"signature": "def supported_security_providers(<EOL>self, resource_group_name, virtual_wan_name, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>url = self.supported_security_providers.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_wan_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gives the supported security providers for the virtual wan.\n\n        :param resource_group_name: The resource group name.\n        :type resource_group_name: str\n        :param virtual_wan_name: The name of the VirtualWAN for which\n         supported security providers are needed.\n        :type virtual_wan_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: VirtualWanSecurityProviders or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.VirtualWanSecurityProviders or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_11_01.models.ErrorException>`", "id": "f32312:c1:m2"}
{"signature": "def _refresh(self):", "body": "self.invoice.refresh_from_db()<EOL>if self.invoice.cart:<EOL><INDENT>self.invoice.cart.refresh_from_db()<EOL><DEDENT>", "docstring": "Refreshes the underlying invoice and cart objects.", "id": "f17921:c0:m9"}
{"signature": "def open(self, file, flags, mode=<NUM_LIT>):", "body": "if flags & WRITE_FLAGS and not self._ok(file):<EOL><INDENT>self._violation(\"<STR_LIT>\", file, flags, mode)<EOL><DEDENT>return _os.open(file,flags,mode)<EOL>", "docstring": "Called for low-level os.open()", "id": "f21745:c1:m8"}
{"signature": "def _truncate_float(matchobj, format_str='<STR_LIT>'):", "body": "if matchobj.group(<NUM_LIT:0>):<EOL><INDENT>return format(float(matchobj.group(<NUM_LIT:0>)), format_str)<EOL><DEDENT>return '<STR_LIT>'<EOL>", "docstring": "Truncate long floats\n\n    Args:\n        matchobj (re.Match): contains original float\n        format_str (str): format specifier\n    Returns:\n       str: returns truncated float", "id": "f10887:m1"}
{"signature": "def list(<EOL>self, resource_group_name, load_balancer_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", load_balancer_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.BackendAddressPoolPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.BackendAddressPoolPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the load balancer backed address pools.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param load_balancer_name: The name of the load balancer.\n        :type load_balancer_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of BackendAddressPool\n        :rtype:\n         ~azure.mgmt.network.v2018_04_01.models.BackendAddressPoolPaged[~azure.mgmt.network.v2018_04_01.models.BackendAddressPool]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33769:c0:m1"}
{"signature": "@property<EOL><INDENT>def left_thumb_x(self):<DEDENT>", "body": "return self.get_axis(ControllerAxes.left_thumb_x)<EOL>", "docstring": "The absolute X axis value of the left thumb-stick, or the main stick on a joystick.", "id": "f6775:c0:m7"}
{"signature": "def find_modules(rootpath, skip):", "body": "INITPY = '<STR_LIT>'<EOL>rootpath = os.path.normpath(os.path.abspath(rootpath))<EOL>if INITPY in os.listdir(rootpath):<EOL><INDENT>root_package = rootpath.split(os.path.sep)[-<NUM_LIT:1>]<EOL>print(\"<STR_LIT>\", rootpath)<EOL><DEDENT>else:<EOL><INDENT>print(\"<STR_LIT>\", rootpath)<EOL>return<EOL><DEDENT>def makename(package, module):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>if package:<EOL><INDENT>name = package<EOL>if module:<EOL><INDENT>name += '<STR_LIT:.>' + module<EOL><DEDENT><DEDENT>else:<EOL><INDENT>name = module<EOL><DEDENT>return name<EOL><DEDENT>skipall = []<EOL>for m in list(skip.keys()):<EOL><INDENT>if skip[m] is None: skipall.append(m)<EOL><DEDENT>tree = {}<EOL>saved = <NUM_LIT:0><EOL>found = <NUM_LIT:0><EOL>def save(module, submodule):<EOL><INDENT>name = module+ \"<STR_LIT:.>\"+ submodule<EOL>for s in skipall:<EOL><INDENT>if name.startswith(s):<EOL><INDENT>print(\"<STR_LIT>\"+name)<EOL>return False<EOL><DEDENT><DEDENT>if module in skip:<EOL><INDENT>if submodule in skip[module]:<EOL><INDENT>print(\"<STR_LIT>\"+name)<EOL>return False<EOL><DEDENT><DEDENT>if module not in tree:<EOL><INDENT>tree[module] = []<EOL><DEDENT>tree[module].append(submodule)<EOL>return True<EOL><DEDENT>for root, subs, files in os.walk(rootpath):<EOL><INDENT>py_files = sorted([f for f in files if os.path.splitext(f)[<NUM_LIT:1>] == '<STR_LIT>'])<EOL>if INITPY in py_files:<EOL><INDENT>subpackage = root[len(rootpath):].lstrip(os.path.sep).replace(os.path.sep, '<STR_LIT:.>')<EOL>full = makename(root_package, subpackage)<EOL>part = full.rpartition('<STR_LIT:.>')<EOL>base_package, submodule = part[<NUM_LIT:0>], part[<NUM_LIT:2>]<EOL>found += <NUM_LIT:1><EOL>if save(base_package, submodule): saved += <NUM_LIT:1><EOL>py_files.remove(INITPY)    <EOL>for py_file in py_files:<EOL><INDENT>found += <NUM_LIT:1><EOL>module = os.path.splitext(py_file)[<NUM_LIT:0>]<EOL>if save(full, module): saved += <NUM_LIT:1><EOL><DEDENT><DEDENT><DEDENT>for item in list(tree.keys()):<EOL><INDENT>tree[item].sort()<EOL><DEDENT>print(\"<STR_LIT>\" %(root_package, found, found-saved))<EOL>return tree<EOL>", "docstring": "Look for every file in the directory tree and return a dict\nHacked from sphinx.autodoc", "id": "f17368:m1"}
{"signature": "def register_sizer(self, attr_name, sizedimage_cls):", "body": "if attr_name.startswith(<EOL>'<STR_LIT:_>'<EOL>) or attr_name in self.unallowed_sizer_names:<EOL><INDENT>raise UnallowedSizerName(<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\" % (<EOL>attr_name,<EOL>'<STR_LIT:U+002CU+0020>'.join([<EOL>name<EOL>for name in self.unallowed_sizer_names<EOL>])<EOL>)<EOL>)<EOL><DEDENT>if not issubclass(sizedimage_cls, SizedImage):<EOL><INDENT>raise InvalidSizedImageSubclass(<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>)<EOL><DEDENT>if attr_name in self._sizedimage_registry:<EOL><INDENT>raise AlreadyRegistered(<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>' % attr_name<EOL>)<EOL><DEDENT>else:<EOL><INDENT>self._sizedimage_registry[attr_name] = sizedimage_cls<EOL><DEDENT>", "docstring": "Register a new SizedImage subclass (`sizedimage_cls`).\n\nTo be used via the attribute (`attr_name`).", "id": "f3814:c6:m1"}
{"signature": "def cvt2frames(self,<EOL>frame_dir,<EOL>file_start=<NUM_LIT:0>,<EOL>filename_tmpl='<STR_LIT>',<EOL>start=<NUM_LIT:0>,<EOL>max_num=<NUM_LIT:0>,<EOL>show_progress=True):", "body": "mkdir_or_exist(frame_dir)<EOL>if max_num == <NUM_LIT:0>:<EOL><INDENT>task_num = self.frame_cnt - start<EOL><DEDENT>else:<EOL><INDENT>task_num = min(self.frame_cnt - start, max_num)<EOL><DEDENT>if task_num <= <NUM_LIT:0>:<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>if start > <NUM_LIT:0>:<EOL><INDENT>self._set_real_position(start)<EOL><DEDENT>def write_frame(file_idx):<EOL><INDENT>img = self.read()<EOL>filename = osp.join(frame_dir, filename_tmpl.format(file_idx))<EOL>cv2.imwrite(filename, img)<EOL><DEDENT>if show_progress:<EOL><INDENT>track_progress(write_frame, range(file_start,<EOL>file_start + task_num))<EOL><DEDENT>else:<EOL><INDENT>for i in range(task_num):<EOL><INDENT>img = self.read()<EOL>if img is None:<EOL><INDENT>break<EOL><DEDENT>filename = osp.join(frame_dir,<EOL>filename_tmpl.format(i + file_start))<EOL>cv2.imwrite(filename, img)<EOL><DEDENT><DEDENT>", "docstring": "Convert a video to frame images\n\n        Args:\n            frame_dir (str): Output directory to store all the frame images.\n            file_start (int): Filenames will start from the specified number.\n            filename_tmpl (str): Filename template with the index as the\n                placeholder.\n            start (int): The starting frame index.\n            max_num (int): Maximum number of frames to be written.\n            show_progress (bool): Whether to show a progress bar.", "id": "f14477:c1:m15"}
{"signature": "def rating(self, **kwargs):", "body": "path = self._get_id_path('<STR_LIT>')<EOL>payload = {<EOL>'<STR_LIT:value>': kwargs.pop('<STR_LIT:value>', None),<EOL>}<EOL>response = self._POST(path, kwargs, payload)<EOL>self._set_attrs_to_values(response)<EOL>return response<EOL>", "docstring": "This method lets users rate a TV show. A valid session id or guest\nsession id is required.\n\nArgs:\n    session_id: see Authentication.\n    guest_session_id: see Authentication.\n    value: Rating value.\n\nReturns:\n    A dict respresentation of the JSON returned from the API.", "id": "f272:c0:m7"}
{"signature": "def list_source_repository_properties(<EOL>self, resource_group_name, registry_name, build_task_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list_source_repository_properties.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", registry_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", build_task_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get the source control properties for a build task.\n\n        :param resource_group_name: The name of the resource group to which\n         the container registry belongs.\n        :type resource_group_name: str\n        :param registry_name: The name of the container registry.\n        :type registry_name: str\n        :param build_task_name: The name of the container registry build task.\n        :type build_task_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: SourceRepositoryProperties or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.containerregistry.v2018_02_01_preview.models.SourceRepositoryProperties\n         or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24092:c0:m9"}
{"signature": "def restart(<EOL>self, resource_group_name, vm_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._restart_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "The operation to restart a virtual machine.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns OperationStatusResponse\n         or ClientRawResponse<OperationStatusResponse> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2015_06_15.models.OperationStatusResponse]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2015_06_15.models.OperationStatusResponse]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25859:c0:m17"}
{"signature": "def start(<EOL>self, resource_group_name, profile_name, endpoint_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._start_initial(<EOL>resource_group_name=resource_group_name,<EOL>profile_name=profile_name,<EOL>endpoint_name=endpoint_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Starts an existing CDN endpoint that is on a stopped state.\n\n        :param resource_group_name: Name of the Resource group within the\n         Azure subscription.\n        :type resource_group_name: str\n        :param profile_name: Name of the CDN profile which is unique within\n         the resource group.\n        :type profile_name: str\n        :param endpoint_name: Name of the endpoint under the profile which is\n         unique globally.\n        :type endpoint_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns Endpoint or\n         ClientRawResponse<Endpoint> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.cdn.models.Endpoint]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.cdn.models.Endpoint]]\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.cdn.models.ErrorResponseException>`", "id": "f40938:c0:m10"}
{"signature": "def _get_authentication_key(self):", "body": "return self.__authentication_key<EOL>", "docstring": "Getter method for authentication_key, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/authentication/config/authentication_key (string)\n\n    YANG Description: authenticate RSVP signaling\nmessages", "id": "f22300:c1:m5"}
{"signature": "def guess_byte_order(self):", "body": "return boc.native_code<EOL>", "docstring": "As we do not know what file type we have, assume native", "id": "f19358:c4:m2"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv4/addresses/address/vrrp/vrrp_group/config (container)\n\nYANG Description: Configuration data for the VRRP group", "id": "f21954:c0:m5"}
{"signature": "def check_token(token):", "body": "user = models.User.objects(api_key=token).first()<EOL>return user or None<EOL>", "docstring": "Verify http header token authentification", "id": "f8692:m1"}
{"signature": "def _set_areas(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=areas.areas,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__areas = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for areas, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_areas is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_areas() directly.\n\n    YANG Description: Configuration and operational state relating to an\nOSPFv2 area.", "id": "f23132:c0:m6"}
{"signature": "def _get_reset_trigger(self):", "body": "return self.__reset_trigger<EOL>", "docstring": "Getter method for reset_trigger, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/lsp_bit/overload_bit/reset_triggers/reset_trigger/config/reset_trigger (identityref)\n\n    YANG Description: In the case that the system sets the overload bit on start, the\nsystem should reset the bit (i.e., clear the overload bit) upon\nthe specified trigger.", "id": "f22483:c0:m2"}
{"signature": "def get_at_subscription_scope(<EOL>self, deployment_name, operation_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_at_subscription_scope.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", deployment_name, '<STR_LIT:str>', max_length=<NUM_LIT:64>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", operation_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a deployments operation.\n\n        :param deployment_name: The name of the deployment.\n        :type deployment_name: str\n        :param operation_id: The ID of the operation to get.\n        :type operation_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: DeploymentOperation or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.resource.resources.v2018_05_01.models.DeploymentOperation\n         or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37816:c0:m1"}
{"signature": "def __new__(mcs, *args, **kwargs):", "body": "class_name, super_cls, dict_ = args<EOL>dict_['<STR_LIT>'] = None<EOL>cls_ = super(Singleton, mcs).__new__(<EOL>mcs, class_name, super_cls, dict_, **kwargs)<EOL>return cls_<EOL>", "docstring": "\u5143\u7c7bmsc\u901a\u8fc7__new__\u7ec4\u5efa\u7c7b\u5bf9\u8c61\uff0c\u5176\u4e2dmsc\u6307Singleton\n\n:param list args: \u53ef\u4ee5\u5305\u542b\u7c7b\u6784\u5efa\u6240\u9700\u8981\u4e09\u5143\u7d20\uff0c ``\u7c7b\u540d`` \uff0c ``\u7236\u7c7b`` \uff0c\n    ``\u547d\u540d\u7a7a\u95f4``, \u5176\u4e2d\u547d\u540d\u7a7a\u95f4\u4e2d __qualname__ \u548c\u51fd\u6570\u7684 __qualname__\n    \u5747\u542b\u6709 classname \u505a\u4e3a\u524d\u7f00\uff0c\u5728\u8fd9\u91cc\uff0c\u5982\u679c\u60f3\u66ff\u6362\u7c7b\u540d\uff0c\u9700\u8981\u628a\u4ee5\u4e0a\u5168\u90e8\u66ff\u6362\u624d\u53ef\u4ee5\u3002\n:param dict kwargs: \u53ef\u4ee5\u81ea\u5b9a\u4e49\u4f20\u9012\u4e00\u4e9b\u53c2\u6570\n:return: \u8fd4\u56de\u7c7b\u5bf9\u8c61,\u901a\u8fc7super(Singleton, mcs).__new__\u6b64\u65f6\u5df2\u7ecf\u7ec4\u88c5\u597d\u4e86\u7c7b\n:rtype: class", "id": "f2932:c1:m0"}
{"signature": "def fetch_ensembl_exons(build='<STR_LIT>'):", "body": "LOG.info(\"<STR_LIT>\", build)<EOL>if build == '<STR_LIT>':<EOL><INDENT>url = '<STR_LIT>'<EOL><DEDENT>else:<EOL><INDENT>url = '<STR_LIT>'<EOL><DEDENT>dataset_name = '<STR_LIT>'<EOL>dataset = pybiomart.Dataset(name=dataset_name, host=url)<EOL>attributes = [<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'<EOL>]<EOL>filters = {<EOL>'<STR_LIT>': CHROMOSOMES,<EOL>}<EOL>result = dataset.query(<EOL>attributes = attributes,<EOL>filters = filters<EOL>)<EOL>return result<EOL>", "docstring": "Fetch the ensembl genes\n\n    Args:\n        build(str): ['37', '38']", "id": "f13711:m9"}
{"signature": "def create_list(self, list_json, **kwargs):", "body": "return self.client.create_list(list_json, **kwargs)<EOL>", "docstring": "Create List object from JSON object\n\nReturns:\n    List: The list from the given `list_json`.", "id": "f12590:c0:m16"}
{"signature": "def _get_unknown_value(self):", "body": "return self.__unknown_value<EOL>", "docstring": "Getter method for unknown_value, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering/tlvs/tlv/link/sub_tlvs/sub_tlv/state/unknown_value (binary)\n\nYANG Description: The binary contents of the unknown TLV", "id": "f23043:c0:m8"}
{"signature": "def search_all(self):", "body": "results = self._list_containers()<EOL>bot.info(\"<STR_LIT>\" %self._bucket_name)<EOL>rows = []<EOL>for i in results:<EOL><INDENT>size = round(i.size / (<NUM_LIT>*<NUM_LIT>))<EOL>size = (\"<STR_LIT>\" %size).rjust(<NUM_LIT:10>)<EOL>rows.append([size,i.metadata['<STR_LIT>']])<EOL><DEDENT>bot.table(rows)<EOL>return rows<EOL>", "docstring": "a \"list all\" search that doesn't require a query. Here we return to\n       the user all objects that have custom metadata value of \"container\"\n\n       IMPORTANT: the upload function adds this metadata. For a container to\n       be found by the client, it must have the type as container in metadata.", "id": "f9973:m2"}
{"signature": "def content(self):", "body": "return self._content(self.dirname)<EOL>", "docstring": "Returns all directories and files in this directory and its\n            subdirectories", "id": "f14404:c3:m5"}
{"signature": "def assert_executed_command(self, expected_cmd, with_path=True):", "body": "if not with_path:<EOL><INDENT>self.adapter.execute.assert_called_once_with(expected_cmd)<EOL><DEDENT>else:<EOL><INDENT>self.adapter.execute.assert_called_once_with(<EOL>expected_cmd,<EOL>os.path.join(self.sandbox.path, \"<STR_LIT>\"))<EOL><DEDENT>", "docstring": "Assert that adapter has executed expected command.", "id": "f2016:c3:m2"}
{"signature": "def _get_description(self):", "body": "return self.__description<EOL>", "docstring": "Getter method for description, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/state/description (string)\n\n    YANG Description: An optional textual description (intended primarily for use\nwith a peer or group", "id": "f23273:c0:m32"}
{"signature": "def load(self, filename):", "body": "self.filename = filename<EOL>fileobj = open(filename, \"<STR_LIT:rb>\")<EOL>try:<EOL><INDENT>try:<EOL><INDENT>self.info = self._Info(fileobj)<EOL>self.tags = self._Tags(fileobj, self.info)<EOL>self.info._post_tags(fileobj)<EOL><DEDENT>except error as e:<EOL><INDENT>reraise(self._Error, e, sys.exc_info()[<NUM_LIT:2>])<EOL><DEDENT>except EOFError:<EOL><INDENT>raise self._Error(\"<STR_LIT>\")<EOL><DEDENT><DEDENT>finally:<EOL><INDENT>fileobj.close()<EOL><DEDENT>", "docstring": "Load file information from a filename.", "id": "f2186:c2:m0"}
{"signature": "def _get_max_fd(self):", "body": "limits = resource.getrlimit(resource.RLIMIT_NOFILE)<EOL>result = limits[<NUM_LIT:1>]<EOL>if result == resource.RLIM_INFINITY:<EOL><INDENT>result = maxfd<EOL><DEDENT>return result<EOL>", "docstring": "Return the maximum file descriptor value.", "id": "f11639:c1:m1"}
{"signature": "@property<EOL><INDENT>def running(self):<DEDENT>", "body": "if self.state == '<STR_LIT>':<EOL><INDENT>return True<EOL><DEDENT>else:<EOL><INDENT>return False<EOL><DEDENT>", "docstring": "Am I running.", "id": "f21671:c3:m5"}
{"signature": "def _get_ipv4_interface_address(self):", "body": "return self.__ipv4_interface_address<EOL>", "docstring": "Getter method for ipv4_interface_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/ipv4_interface_address/state/ipv4_interface_address (inet:ipv4-address-no-zone)\n\n    YANG Description: A 4-octet IPv4 address for the interface described by the\n(main) TLV. This sub-TLV can occur multiple times.", "id": "f22751:c0:m5"}
{"signature": "def max(self, axis):", "body": "raise NotImplementedError<EOL>", "docstring": "Return the maximum of the array elements over the given axis or axes.", "id": "f986:c0:m12"}
{"signature": "def integrate_kde(self, other):", "body": "if other.d != self.d:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>if other.n < self.n:<EOL><INDENT>small = other<EOL>large = self<EOL><DEDENT>else:<EOL><INDENT>small = self<EOL>large = other<EOL><DEDENT>sum_cov = small.covariance + large.covariance<EOL>sum_cov_chol = linalg.cho_factor(sum_cov)<EOL>result = <NUM_LIT:0.0><EOL>for i in range(small.n):<EOL><INDENT>mean = small.dataset[:, i, newaxis]<EOL>diff = large.dataset - mean<EOL>tdiff = linalg.cho_solve(sum_cov_chol, diff)<EOL>energies = sum(diff * tdiff, axis=<NUM_LIT:0>) / <NUM_LIT><EOL>result += sum(exp(-energies), axis=<NUM_LIT:0>)<EOL><DEDENT>result /= sqrt(linalg.det(<NUM_LIT:2> * pi * sum_cov)) * large.n * small.n<EOL>return result<EOL>", "docstring": "Computes the integral of the product of this  kernel density estimate\nwith another.\n\nParameters\n----------\nother : gaussian_kde instance\n    The other kde.\n\nReturns\n-------\nvalue : scalar\n    The result of the integral.\n\nRaises\n------\nValueError\n    If the KDEs have different dimensionality.", "id": "f19696:c0:m5"}
{"signature": "@property<EOL><INDENT>def url(self) -> str:<DEDENT>", "body": "if self[<NUM_LIT:0>] == '<STR_LIT:[>':<EOL><INDENT>return self[<NUM_LIT:1>:URL_MATCH(self._ext_link_shadow, <NUM_LIT:1>).end()]<EOL><DEDENT>return self.string<EOL>", "docstring": "Return the url.", "id": "f8133:c0:m0"}
{"signature": "@register_function(scope='<STR_LIT:str>')<EOL>def str_contains(x, pattern, regex=True):", "body": "return _to_string_sequence(x).search(pattern, regex)<EOL>", "docstring": "Check if a string pattern or regex is contained within a sample of a string column.\n\n    :param str pattern: A string or regex pattern\n    :param bool regex: If True,\n    :returns: an expression which is evaluated to True if the pattern is found in a given sample, and it is False otherwise.\n\n    Example:\n\n    >>> import vaex\n    >>> text = ['Something', 'very pretty', 'is coming', 'our', 'way.']\n    >>> df = vaex.from_arrays(text=text)\n    >>> df\n      #  text\n      0  Something\n      1  very pretty\n      2  is coming\n      3  our\n      4  way.\n\n    >>> df.text.str.contains('very')\n    Expression = str_contains(text, 'very')\n    Length: 5 dtype: bool (expression)\n    ----------------------------------\n    0  False\n    1   True\n    2  False\n    3  False\n    4  False", "id": "f6962:m18"}
{"signature": "def _set_type_of_service(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT>\",<EOL>type_of_service.type_of_service,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__type_of_service = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for type_of_service, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/nssa_external_lsa/types_of_service/type_of_service (list)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_type_of_service is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_type_of_service() directly.\n\nYANG Description: Per-type of service parameters for the NSSA external LSA", "id": "f22992:c1:m3"}
{"signature": "def _set_flags(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(<EOL>allowed_type=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {},<EOL>\"<STR_LIT>\": {},<EOL>\"<STR_LIT>\": {},<EOL>\"<STR_LIT>\": {},<EOL>\"<STR_LIT>\": {},<EOL>\"<STR_LIT>\": {},<EOL>},<EOL>)<EOL>),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__flags = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for flags, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_ipv6_reachability/prefixes/prefix/subTLVs/subTLVs/prefix_sid/sid/state/flags (enumeration)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_flags is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_flags() directly.\n\nYANG Description: Flags associated with Prefix Segment-ID.", "id": "f22917:c1:m9"}
{"signature": "def _get_max_link_bandwidth(self):", "body": "return self.__max_link_bandwidth<EOL>", "docstring": "Getter method for max_link_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/max_link_bandwidth (container)\n\nYANG Description: This container defines sub-TLV 9.", "id": "f22845:c0:m17"}
{"signature": "def _get_total_paths(self):", "body": "return self.__total_paths<EOL>", "docstring": "Getter method for total_paths, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/state/total_paths (uint32)\n\nYANG Description: Total number of BGP paths within the context", "id": "f23163:c1:m29"}
{"signature": "def _stinespring_to_operator(data, input_dim, output_dim):", "body": "trace_dim = data[<NUM_LIT:0>].shape[<NUM_LIT:0>] // output_dim<EOL>if data[<NUM_LIT:1>] is not None or trace_dim != <NUM_LIT:1>:<EOL><INDENT>raise QiskitError(<EOL>'<STR_LIT>')<EOL><DEDENT>return data[<NUM_LIT:0>]<EOL>", "docstring": "Transform Stinespring representation to Operator representation.", "id": "f10803:m9"}
{"signature": "def path(self, filename, folder=None):", "body": "if folder is not None:<EOL><INDENT>target_folder = os.path.join(self.config.destination, folder)<EOL><DEDENT>else:<EOL><INDENT>target_folder = self.config.destination<EOL><DEDENT>return os.path.join(target_folder, filename)<EOL>", "docstring": "This returns the absolute path of a file uploaded to this set. It\ndoesn't actually check whether said file exists.\n\n:param filename: The filename to return the path for.\n:param folder: The subfolder within the upload set previously used\n               to save to.", "id": "f11049:c4:m3"}
{"signature": "def _get_extended_ipv4_reachability(self):", "body": "return self.__extended_ipv4_reachability<EOL>", "docstring": "Getter method for extended_ipv4_reachability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_ipv4_reachability (container)\n\n    YANG Description: This container defines list of IPv4 extended reachability\ninformation.", "id": "f22825:c1:m62"}
{"signature": "def list(self):", "body": "response = requests.get(self.base_url)<EOL>if not response.ok:<EOL><INDENT>raise ServerException(<EOL>'<STR_LIT>'.format(response.status_code, response.text))<EOL><DEDENT>return {<EOL>host.get('<STR_LIT:name>'): [<EOL>log.get('<STR_LIT:key>')<EOL>for log<EOL>in host.get('<STR_LIT>')]<EOL>for host<EOL>in response.json().get('<STR_LIT:list>')<EOL>}<EOL>", "docstring": "Get all log sets\n\n:return: Returns a dictionary where the key is the hostname or log set,\n    and the value is a list of the log keys\n:rtype: dict\n\n:raises: This will raise a\n    :class:`ServerException<logentries_api.exceptions.ServerException>`\n    if there is an error from Logentries", "id": "f8662:c0:m1"}
{"signature": "def __init__(self, raw_data):", "body": "assert isinstance(raw_data, dict), '<STR_LIT>'.format(type(raw_data).__name__)<EOL>self.raw_data = raw_data<EOL>self.validated_data = None<EOL>self.errors = {}<EOL>", "docstring": ":param raw_data: unvalidate data", "id": "f6048:c1:m0"}
{"signature": "def volume_device_type(self, volume):", "body": "volume = self._get_volume(volume)<EOL>if volume is not None:<EOL><INDENT>return volume[\"<STR_LIT>\"]<EOL><DEDENT>", "docstring": "Returns the volume type (RAID1, RAID2, etc)", "id": "f6343:c2:m5"}
{"signature": "def _get_net(self):", "body": "return self.__net<EOL>", "docstring": "Getter method for net, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/config/net (oc-isis-types:net)\n\n    YANG Description: ISIS network entity title (NET). The first 8 bits are usually\n49 (private AFI), next 16 bits represent area, next 48 bits represent\nsystem id and final 8 bits are set to 0.", "id": "f22501:c0:m8"}
{"signature": "def __init__(self, url):", "body": "super(WebHookAlertConfig, self).__init__(url=url)<EOL>", "docstring": "Requires a 'url' parameter", "id": "f8660:c4:m0"}
{"signature": "def get(<EOL>self, location_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", location_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Retrieves a single ExpressRoutePort peering location, including the\n        list of available bandwidths available at said peering location.\n\n        :param location_name: Name of the requested ExpressRoutePort peering\n         location.\n        :type location_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ExpressRoutePortsLocation or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.ExpressRoutePortsLocation or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32801:c0:m2"}
{"signature": "def list_for_scope(<EOL>self, scope, filter=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_for_scope.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", scope, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.RoleAssignmentPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.RoleAssignmentPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets role assignments for a scope.\n\n        :param scope: The scope of the role assignments.\n        :type scope: str\n        :param filter: The filter to apply on the operation. Use\n         $filter=atScope() to return all role assignments at or above the\n         scope. Use $filter=principalId eq {id} to return all role assignments\n         at, above or below the scope for the specified principal.\n        :type filter: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of RoleAssignment\n        :rtype:\n         ~azure.mgmt.authorization.v2015_07_01.models.RoleAssignmentPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f45513:c0:m10"}
{"signature": "def list_available_server_variables(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.list_available_server_variables.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all available server variables.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ApplicationGatewayAvailableServerVariablesResult or\n         ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.ApplicationGatewayAvailableServerVariablesResult\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_11_01.models.ErrorException>`", "id": "f32776:c0:m16"}
{"signature": "def delete(self, filename, storage_type=None, bucket_name=None):", "body": "if not (storage_type and bucket_name):<EOL><INDENT>self._delete_local(filename)<EOL><DEDENT>else:<EOL><INDENT>if storage_type != '<STR_LIT>':<EOL><INDENT>raise ValueError('<STR_LIT>' % storage_type)<EOL><DEDENT>self._delete_s3(filename, bucket_name)<EOL><DEDENT>", "docstring": "Deletes the specified file, either locally or from S3, depending on the file's storage type.", "id": "f5421:c0:m5"}
{"signature": "def detect_image_url_with_no_store(<EOL>self, project_id, published_name, url, application=None, custom_headers=None, raw=False, **operation_config):", "body": "image_url = models.ImageUrl(url=url)<EOL>url = self.detect_image_url_with_no_store.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", project_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", published_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if application is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", application, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.api_key, '<STR_LIT:str>')<EOL>body_content = self._serialize.body(image_url, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.CustomVisionErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Detect objects in an image url without saving the result.\n\n        :param project_id: The project id.\n        :type project_id: str\n        :param published_name: Specifies the name of the model to evaluate\n         against.\n        :type published_name: str\n        :param url: Url of the image.\n        :type url: str\n        :param application: Optional. Specifies the name of application using\n         the endpoint.\n        :type application: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ImagePrediction or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.cognitiveservices.vision.customvision.prediction.models.ImagePrediction\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`CustomVisionErrorException<azure.cognitiveservices.vision.customvision.prediction.models.CustomVisionErrorException>`", "id": "f28043:c1:m7"}
{"signature": "def _best_version(fields):", "body": "def _has_marker(keys, markers):<EOL><INDENT>for marker in markers:<EOL><INDENT>if marker in keys:<EOL><INDENT>return True<EOL><DEDENT><DEDENT>return False<EOL><DEDENT>keys = []<EOL>for key, value in fields.items():<EOL><INDENT>if value in ([], '<STR_LIT>', None):<EOL><INDENT>continue<EOL><DEDENT>keys.append(key)<EOL><DEDENT>possible_versions = ['<STR_LIT:1.0>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']<EOL>for key in keys:<EOL><INDENT>if key not in _241_FIELDS and '<STR_LIT:1.0>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT:1.0>')<EOL><DEDENT>if key not in _314_FIELDS and '<STR_LIT>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT>')<EOL><DEDENT>if key not in _345_FIELDS and '<STR_LIT>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT>')<EOL><DEDENT>if key not in _426_FIELDS and '<STR_LIT>' in possible_versions:<EOL><INDENT>possible_versions.remove('<STR_LIT>')<EOL><DEDENT><DEDENT>if len(possible_versions) == <NUM_LIT:1>:<EOL><INDENT>return possible_versions[<NUM_LIT:0>]   <EOL><DEDENT>elif len(possible_versions) == <NUM_LIT:0>:<EOL><INDENT>raise MetadataConflictError('<STR_LIT>')<EOL><DEDENT>is_1_1 = '<STR_LIT>' in possible_versions and _has_marker(keys, _314_MARKERS)<EOL>is_1_2 = '<STR_LIT>' in possible_versions and _has_marker(keys, _345_MARKERS)<EOL>is_2_0 = '<STR_LIT>' in possible_versions and _has_marker(keys, _426_MARKERS)<EOL>if int(is_1_1) + int(is_1_2) + int(is_2_0) > <NUM_LIT:1>:<EOL><INDENT>raise MetadataConflictError('<STR_LIT>')<EOL><DEDENT>if not is_1_1 and not is_1_2 and not is_2_0:<EOL><INDENT>if PKG_INFO_PREFERRED_VERSION in possible_versions:<EOL><INDENT>return PKG_INFO_PREFERRED_VERSION<EOL><DEDENT><DEDENT>if is_1_1:<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>if is_1_2:<EOL><INDENT>return '<STR_LIT>'<EOL><DEDENT>return '<STR_LIT>'<EOL>", "docstring": "Detect the best version depending on the fields used.", "id": "f17276:m1"}
{"signature": "def find_packages(top=HERE):", "body": "packages = []<EOL>for d, dirs, _ in os.walk(top, followlinks=True):<EOL><INDENT>if os.path.exists(pjoin(d, '<STR_LIT>')):<EOL><INDENT>packages.append(os.path.relpath(d, top).replace(os.path.sep, '<STR_LIT:.>'))<EOL><DEDENT>elif d != top:<EOL><INDENT>dirs[:] = []<EOL><DEDENT><DEDENT>return packages<EOL>", "docstring": "Find all of the packages.", "id": "f9671:m2"}
{"signature": "def _set_subtlv_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__subtlv_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/link_protection_type/state/subtlv_type (identityref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_subtlv_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_subtlv_type() directly.\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22790:c0:m3"}
{"signature": "def delete(<EOL>self, resource_group_name, vm_scale_set_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_scale_set_name=vm_scale_set_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes a VM scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_scale_set_name: The name of the VM scale set.\n        :type vm_scale_set_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns OperationStatusResponse\n         or ClientRawResponse<OperationStatusResponse> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2016_03_30.models.OperationStatusResponse]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2016_03_30.models.OperationStatusResponse]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25516:c0:m4"}
{"signature": "def _get_subtlv_type(self):", "body": "return self.__subtlv_type<EOL>", "docstring": "Getter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/admin_group/state/subtlv_type (identityref)\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22783:c0:m2"}
{"signature": "def _get_extended_prefix_range(self):", "body": "return self.__extended_prefix_range<EOL>", "docstring": "Getter method for extended_prefix_range, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix/tlvs/tlv/extended_prefix_range (container)\n\n    YANG Description: State parameters relating to the extended prefix range\nsub-TLV of the extended prefix LSA", "id": "f23017:c0:m5"}
{"signature": "def resize(self, shape):", "body": "if not isshape(shape):<EOL><INDENT>raise TypeError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>newM, newN = shape<EOL>M, N = self.shape<EOL>if newM < M or newN < N:<EOL><INDENT>for (i, j) in list(self.keys()):<EOL><INDENT>if i >= newM or j >= newN:<EOL><INDENT>del self[i, j]<EOL><DEDENT><DEDENT><DEDENT>self._shape = shape<EOL>", "docstring": "Resize the matrix in-place to dimensions given by 'shape'.\n\n        Any non-zero elements that lie outside the new shape are removed.", "id": "f19588:c0:m26"}
{"signature": "@register_vcs_handler(\"<STR_LIT>\", \"<STR_LIT>\")<EOL>def git_versions_from_keywords(keywords, tag_prefix, verbose):", "body": "if not keywords:<EOL><INDENT>raise NotThisMethod(\"<STR_LIT>\")<EOL><DEDENT>date = keywords.get(\"<STR_LIT:date>\")<EOL>if date is not None:<EOL><INDENT>date = date.strip().replace(\"<STR_LIT:U+0020>\", \"<STR_LIT:T>\", <NUM_LIT:1>).replace(\"<STR_LIT:U+0020>\", \"<STR_LIT>\", <NUM_LIT:1>)<EOL><DEDENT>refnames = keywords[\"<STR_LIT>\"].strip()<EOL>if refnames.startswith(\"<STR_LIT>\"):<EOL><INDENT>if verbose:<EOL><INDENT>print(\"<STR_LIT>\")<EOL><DEDENT>raise NotThisMethod(\"<STR_LIT>\")<EOL><DEDENT>refs = set([r.strip() for r in refnames.strip(\"<STR_LIT>\").split(\"<STR_LIT:U+002C>\")])<EOL>TAG = \"<STR_LIT>\"<EOL>tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])<EOL>if not tags:<EOL><INDENT>tags = set([r for r in refs if re.search(r'<STR_LIT>', r)])<EOL>if verbose:<EOL><INDENT>print(\"<STR_LIT>\" % \"<STR_LIT:U+002C>\".join(refs - tags))<EOL><DEDENT><DEDENT>if verbose:<EOL><INDENT>print(\"<STR_LIT>\" % \"<STR_LIT:U+002C>\".join(sorted(tags)))<EOL><DEDENT>for ref in sorted(tags):<EOL><INDENT>if ref.startswith(tag_prefix):<EOL><INDENT>r = ref[len(tag_prefix):]<EOL>if verbose:<EOL><INDENT>print(\"<STR_LIT>\" % r)<EOL><DEDENT>return {\"<STR_LIT:version>\": r,<EOL>\"<STR_LIT>\": keywords[\"<STR_LIT>\"].strip(),<EOL>\"<STR_LIT>\": False, \"<STR_LIT:error>\": None,<EOL>\"<STR_LIT:date>\": date}<EOL><DEDENT><DEDENT>if verbose:<EOL><INDENT>print(\"<STR_LIT>\")<EOL><DEDENT>return {\"<STR_LIT:version>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": keywords[\"<STR_LIT>\"].strip(),<EOL>\"<STR_LIT>\": False, \"<STR_LIT:error>\": \"<STR_LIT>\", \"<STR_LIT:date>\": None}<EOL>", "docstring": "Get version information from git keywords.", "id": "f10548:m5"}
{"signature": "def define_pipeline_string(self, process_descriptions, tasks,<EOL>check_upstream,<EOL>check_downstream, count_forks, total_tasks,<EOL>forks):", "body": "tasks_array = tasks.split()<EOL>for task_unsplit in tasks_array:<EOL><INDENT>task = task_unsplit.split(\"<STR_LIT:=>\")[<NUM_LIT:0>]<EOL>if task not in process_descriptions.keys():<EOL><INDENT>logger.error(<EOL>colored_print(<EOL>\"<STR_LIT>\".format(task),<EOL>\"<STR_LIT>\"<EOL>)<EOL>)<EOL>sys.exit()<EOL><DEDENT>else:<EOL><INDENT>process_split = task_unsplit.split(\"<STR_LIT:=>\")<EOL>if len(process_split) > <NUM_LIT:1>:<EOL><INDENT>self.process_to_id[process_split[<NUM_LIT:0>]] = process_split[<NUM_LIT:1>]<EOL><DEDENT><DEDENT>if not bool([x for x in forks if task in x]) and not bool([y for y in forks if process_descriptions[task][<NUM_LIT:2>] in y]):<EOL><INDENT>task_pipeline = []<EOL>if task in process_descriptions:<EOL><INDENT>if check_upstream:<EOL><INDENT>task_pipeline = self.build_upstream(<EOL>process_descriptions,<EOL>task,<EOL>tasks_array,<EOL>task_pipeline,<EOL>count_forks,<EOL>total_tasks,<EOL>forks<EOL>)<EOL><DEDENT>task_pipeline.append(task)<EOL>if check_downstream:<EOL><INDENT>task_pipeline = self.build_downstream(<EOL>process_descriptions,<EOL>task,<EOL>tasks_array,<EOL>task_pipeline,<EOL>count_forks,<EOL>total_tasks,<EOL>forks<EOL>)<EOL><DEDENT><DEDENT>forks.append(list(OrderedDict.fromkeys(task_pipeline)))<EOL><DEDENT>elif bool([y for y in forks if process_descriptions[task][<NUM_LIT:2>] in y]):<EOL><INDENT>for fork in forks:<EOL><INDENT>if task not in fork:<EOL><INDENT>try:<EOL><INDENT>dependent_index = fork.index(process_descriptions[task][<NUM_LIT:2>])<EOL>fork.insert(dependent_index, task)<EOL><DEDENT>except ValueError:<EOL><INDENT>continue<EOL><DEDENT><DEDENT><DEDENT><DEDENT><DEDENT>for i in range(<NUM_LIT:0>, len(forks)):<EOL><INDENT>for j in range(<NUM_LIT:0>, len(forks[i])):<EOL><INDENT>try:<EOL><INDENT>if len(forks[i][j].split(\"<STR_LIT:|>\")) > <NUM_LIT:1>:<EOL><INDENT>forks[i][j] = forks[i][j].split(\"<STR_LIT:|>\")<EOL>tmp_fork = []<EOL>for s in forks[i][j]:<EOL><INDENT>if s in total_tasks:<EOL><INDENT>tmp_fork.append(s)<EOL><DEDENT><DEDENT>forks[i][j] = tmp_fork<EOL><DEDENT><DEDENT>except AttributeError as e:<EOL><INDENT>continue<EOL><DEDENT><DEDENT><DEDENT>return forks<EOL>", "docstring": "Builds the possible forks and connections between the provided\n        processes\n\n        This method loops through all the provided tasks and builds the\n        upstream and downstream pipeline if required. It then returns all\n        possible forks than need to be merged \u00e0 posteriori`\n\n        Parameters\n        ----------\n        process_descriptions : dict\n            Information of processes input, output and if is forkable\n        tasks : str\n            Space separated processes\n        check_upstream : bool\n            If is to build the upstream pipeline of the current task\n        check_downstream : bool\n            If is to build the downstream pipeline of the current task\n        count_forks : int\n            Number of current forks\n        total_tasks : str\n            All space separated processes\n        forks : list\n            Current forks\n\n        Returns\n        -------\n        list : List with all the possible pipeline forks", "id": "f6651:c0:m4"}
{"signature": "def write(self, output_stream, kmip_version=enums.KMIPVersion.KMIP_1_0):", "body": "local_stream = utils.BytearrayStream()<EOL>if self._unique_identifier:<EOL><INDENT>self._unique_identifier.write(<EOL>local_stream,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT>self.length = local_stream.length()<EOL>super(ArchiveRequestPayload, self).write(<EOL>output_stream,<EOL>kmip_version=kmip_version<EOL>)<EOL>output_stream.write(local_stream.buffer)<EOL>", "docstring": "Write the data encoding the Archive request payload to a stream.\n\nArgs:\n    output_stream (stream): A data stream in which to encode object\n        data, supporting a write method; usually a BytearrayStream\n        object.\n    kmip_version (KMIPVersion): An enumeration defining the KMIP\n        version with which the object will be encoded. Optional,\n        defaults to KMIP 1.0.\n\nRaises:\n    ValueError: Raised if the data attribute is not defined.", "id": "f15102:c0:m4"}
{"signature": "def valid_choices(choices):", "body": "for key, value in choices:<EOL><INDENT>if isinstance(value, (list, tuple)):<EOL><INDENT>for key, _ in value:<EOL><INDENT>yield key<EOL><DEDENT><DEDENT>else:<EOL><INDENT>yield key<EOL><DEDENT><DEDENT>", "docstring": "Return list of choices's keys", "id": "f10409:m0"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/config (container)\n\nYANG Description: This container defines interface ISIS level configuration.", "id": "f22422:c1:m5"}
{"signature": "def _get_segment_routing(self):", "body": "return self.__segment_routing<EOL>", "docstring": "Getter method for segment_routing, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/segment_routing (container)\n\n    YANG Description: MPLS-specific Segment Routing configuration and operational state\nparameters", "id": "f22326:c1:m5"}
{"signature": "def add(self, image_path=None,<EOL>image_uri=None,<EOL>image_name=None,<EOL>url=None,<EOL>metadata=None,<EOL>save=True, <EOL>copy=False):", "body": "from sregistry.database.models import (<EOL>Container,<EOL>Collection<EOL>)<EOL>if image_path is not None:<EOL><INDENT>if not os.path.exists(image_path) and save is True:<EOL><INDENT>bot.error('<STR_LIT>' %image_path)<EOL>sys.exit(<NUM_LIT:1>)<EOL><DEDENT><DEDENT>if image_uri is None:<EOL><INDENT>bot.error('<STR_LIT>')<EOL>sys.exit(<NUM_LIT:1>)<EOL><DEDENT>names = parse_image_name( remove_uri(image_uri) )<EOL>bot.debug('<STR_LIT>' % names['<STR_LIT>'])    <EOL>metadata = self.get_metadata(image_path, names=names)<EOL>collection = self.get_or_create_collection(names['<STR_LIT>'])<EOL>version = names.get('<STR_LIT:version>')<EOL>if version == None:<EOL><INDENT>if image_path != None:<EOL><INDENT>version = get_image_hash(image_path)<EOL><DEDENT>else:<EOL><INDENT>version = '<STR_LIT>'  <EOL><DEDENT>names = parse_image_name( remove_uri(image_uri), version=version )<EOL><DEDENT>if save is True and image_path is not None:<EOL><INDENT>if image_name is None:      <EOL><INDENT>image_name = self._get_storage_name(names)<EOL><DEDENT>if copy is True:<EOL><INDENT>copyfile(image_path, image_name)<EOL><DEDENT>else:<EOL><INDENT>shutil.move(image_path, image_name)<EOL><DEDENT>image_path = image_name<EOL><DEDENT>if url is None and \"<STR_LIT:url>\" in metadata:<EOL><INDENT>url = metadata['<STR_LIT:url>']<EOL><DEDENT>container = self.get_container(name=names['<STR_LIT:image>'],<EOL>collection_id=collection.id, <EOL>tag=names['<STR_LIT>'],<EOL>version=version)<EOL>if container is None:<EOL><INDENT>action = \"<STR_LIT>\"<EOL>container = Container(metrics=json.dumps(metadata),<EOL>name=names['<STR_LIT:image>'],<EOL>image=image_path,<EOL>client=self.client_name,<EOL>tag=names['<STR_LIT>'],<EOL>version=version,<EOL>url=url,<EOL>uri=names['<STR_LIT>'],<EOL>collection_id=collection.id)<EOL>self.session.add(container)<EOL>collection.containers.append(container)<EOL><DEDENT>else:<EOL><INDENT>action=\"<STR_LIT>\"<EOL>metrics=json.loads(container.metrics)<EOL>metrics.update(metadata)<EOL>container.url= url<EOL>container.client=self.client_name<EOL>if image_path is not None:<EOL><INDENT>container.image=image_path<EOL><DEDENT>container.metrics=json.dumps(metrics)<EOL><DEDENT>self.session.commit()<EOL>bot.info(\"<STR_LIT>\" % (action,names['<STR_LIT>']))<EOL>return container<EOL>", "docstring": "get or create a container, including the collection to add it to.\n    This function can be used from a file on the local system, or via a URL\n    that has been downloaded. Either way, if one of url, version, or image_file\n    is not provided, the model is created without it. If a version is not\n    provided but a file path is, then the file hash is used.\n\n    Parameters\n    ==========\n    image_path: full path to image file\n    image_name: if defined, the user wants a custom name (and not based on uri)\n    metadata: any extra metadata to keep for the image (dict)\n    save: if True, move the image to the cache if it's not there\n    copy: If True, copy the image instead of moving it.\n\n    image_name: a uri that gets parsed into a names object that looks like:\n\n    {'collection': 'vsoch',\n     'image': 'hello-world',\n     'storage': 'vsoch/hello-world-latest.img',\n     'tag': 'latest',\n     'version': '12345'\n     'uri': 'vsoch/hello-world:latest@12345'}\n\n    After running add, the user will take some image in a working\n    directory, add it to the database, and have it available for search\n    and use under SREGISTRY_STORAGE/<collection>/<container>\n\n    If the container was retrieved from a webby place, it should have version\n    If no version is found, the file hash is used.", "id": "f9896:m11"}
{"signature": "def get_metrics(self) -> Dict[str, Metric]:", "body": "return self._metrics.copy()<EOL>", "docstring": "Return a dict mapping names to metrics.", "id": "f13330:c3:m3"}
{"signature": "@pexdoc.pcontracts.contract(wave=Waveform)<EOL>def real(wave):", "body": "return _operation(wave, \"<STR_LIT>\", wave.dep_units, np.real)<EOL>", "docstring": "r\"\"\"\n    Return the real part of a waveform's dependent variable vector.\n\n    :param wave: Waveform\n    :type  wave: :py:class:`peng.eng.Waveform`\n\n    :rtype: :py:class:`peng.eng.Waveform`\n\n    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc()) ]]]\n    .. Auto-generated exceptions documentation for\n    .. peng.wave_functions.real\n\n    :raises: RuntimeError (Argument \\`wave\\` is not valid)\n\n    .. [[[end]]]", "id": "f6752:m43"}
{"signature": "def _set_local_ipv6_addresses(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(<EOL>allowed_type=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>)<EOL>),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__local_ipv6_addresses = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for local_ipv6_addresses, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/traffic_engineering/tlvs/tlv/node_attribute/sub_tlvs/sub_tlv/state/local_ipv6_addresses (inet:ipv6-prefix)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_local_ipv6_addresses is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_local_ipv6_addresses() directly.\n\nYANG Description: The local IPv6 addreses of the node", "id": "f23057:c0:m9"}
{"signature": "def sync_roles(self):", "body": "self.log.debug('<STR_LIT>')<EOL>self.create_perm_vm_for_all_dag()<EOL>for config in self.ROLE_CONFIGS:<EOL><INDENT>role = config['<STR_LIT>']<EOL>vms = config['<STR_LIT>']<EOL>perms = config['<STR_LIT>']<EOL>self.init_role(role, vms, perms)<EOL><DEDENT>self.create_custom_dag_permission_view()<EOL>self.update_admin_perm_view()<EOL>self.clean_perms()<EOL>", "docstring": "1. Init the default role(Admin, Viewer, User, Op, public)\n   with related permissions.\n2. Init the custom role(dag-user) with related permissions.\n\n:return: None.", "id": "f9435:c0:m14"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/interface_ref/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configured reference to interface / subinterface", "id": "f22400:c0:m3"}
{"signature": "@classmethod<EOL><INDENT>def divide(cls, divisions, problem_data):<DEDENT>", "body": "tspp = TSPProblem(**problem_data)<EOL>def routes_for_subgroup(cs):<EOL><INDENT>for city in cs:<EOL><INDENT>if city == tspp.start_city:<EOL><INDENT>continue<EOL><DEDENT>cities = tspp.cities.keys()<EOL>cities.remove(tspp.start_city)<EOL>cities.remove(city)<EOL>random.shuffle(cities)<EOL>route = [tspp.start_city, city] + cities<EOL>assert len(set(route)) == len(route)<EOL>assert len(route) == len(tspp.cities)<EOL>yield json.dumps(route)<EOL><DEDENT><DEDENT>if divisions:<EOL><INDENT>chunk_size = int(math.ceil(len(tspp.cities) / divisions))<EOL><DEDENT>else:<EOL><INDENT>chunk_size = <NUM_LIT:1><EOL><DEDENT>for subgroup in chunks(tspp.cities.keys(), chunk_size):<EOL><INDENT>routes = list(routes_for_subgroup(subgroup))<EOL>if routes:<EOL><INDENT>yield routes<EOL><DEDENT><DEDENT>", "docstring": "divide\n\n        :type problem_data: dict", "id": "f15885:c0:m4"}
{"signature": "def deallocate(<EOL>self, resource_group_name, vm_scale_set_name, instance_id, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._deallocate_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_scale_set_name=vm_scale_set_name,<EOL>instance_id=instance_id,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deallocates a specific virtual machine in a VM scale set. Shuts down\n        the virtual machine and releases the compute resources it uses. You are\n        not billed for the compute resources of this virtual machine once it is\n        deallocated.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_scale_set_name: The name of the VM scale set.\n        :type vm_scale_set_name: str\n        :param instance_id: The instance ID of the virtual machine.\n        :type instance_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns OperationStatusResponse\n         or ClientRawResponse<OperationStatusResponse> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2017_03_30.models.OperationStatusResponse]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2017_03_30.models.OperationStatusResponse]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f26064:c0:m6"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/named_explicit_paths/named_explicit_path/explicit_route_objects/explicit_route_object/config (container)\n\n    YANG Description: Configuration parameters relating to an explicit\nroute", "id": "f22235:c0:m5"}
{"signature": "def _set_autocommit(self, autocommit):", "body": "pass<EOL>", "docstring": "Default method must be overridden, eventhough not used.\n\nTODO: For future reference, setting two phase commits and rollbacks\nmight require populating this method.", "id": "f21179:c2:m4"}
{"signature": "def prepare_network_policies(<EOL>self, resource_group_name, virtual_network_name, subnet_name, prepare_network_policies_request_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._prepare_network_policies_initial(<EOL>resource_group_name=resource_group_name,<EOL>virtual_network_name=virtual_network_name,<EOL>subnet_name=subnet_name,<EOL>prepare_network_policies_request_parameters=prepare_network_policies_request_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Prepares a subnet by applying network intent policies.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_name: The name of the virtual network.\n        :type virtual_network_name: str\n        :param subnet_name: The name of the subnet.\n        :type subnet_name: str\n        :param prepare_network_policies_request_parameters: Parameters\n         supplied to prepare subnet by applying network intent policies.\n        :type prepare_network_policies_request_parameters:\n         ~azure.mgmt.network.v2018_12_01.models.PrepareNetworkPoliciesRequest\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29240:c0:m7"}
{"signature": "def get_stats(<EOL>self, resource_group_name, circuit_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_stats.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", circuit_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the stats from an express route circuit in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ExpressRouteCircuitStats or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2017_10_01.models.ExpressRouteCircuitStats or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f33126:c0:m14"}
{"signature": "def run_next(self, next_job):", "body": "self.log.info('<STR_LIT>', str(next_job))<EOL>key, command, kube_executor_config = next_job<EOL>dag_id, task_id, execution_date, try_number = key<EOL>self.log.debug(\"<STR_LIT>\", command)<EOL>self.log.debug(\"<STR_LIT>\", self.kube_config.kube_image)<EOL>pod = self.worker_configuration.make_pod(<EOL>namespace=self.namespace, worker_uuid=self.worker_uuid,<EOL>pod_id=self._create_pod_id(dag_id, task_id),<EOL>dag_id=self._make_safe_label_value(dag_id),<EOL>task_id=self._make_safe_label_value(task_id),<EOL>try_number=try_number,<EOL>execution_date=self._datetime_to_label_safe_datestring(execution_date),<EOL>airflow_command=command, kube_executor_config=kube_executor_config<EOL>)<EOL>self.launcher.run_pod_async(pod)<EOL>self.log.debug(\"<STR_LIT>\")<EOL>", "docstring": "The run_next command will check the task_queue for any un-run jobs.\nIt will then create a unique job-id, launch that job in the cluster,\nand store relevant info in the current_jobs map so we can track the job's\nstatus", "id": "f9229:c3:m3"}
{"signature": "def delete(<EOL>self, resource_group_name, job_collection_name, job_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", job_collection_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", job_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes a job.\n\n        :param resource_group_name: The resource group name.\n        :type resource_group_name: str\n        :param job_collection_name: The job collection name.\n        :type job_collection_name: str\n        :param job_name: The job name.\n        :type job_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f39170:c0:m4"}
{"signature": "def taubin(script, iterations=<NUM_LIT:10>, t_lambda=<NUM_LIT:0.5>, t_mu=-<NUM_LIT>, selected=False):", "body": "filter_xml = '<STR_LIT>'.join([<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'.format(t_lambda),<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'.format(t_mu),<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'.format(iterations),<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'.format(str(selected).lower()),<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>'])<EOL>util.write_filter(script, filter_xml)<EOL>return None<EOL>", "docstring": "The lambda & mu Taubin smoothing, it make two steps of smoothing, forth\n        and back, for each iteration.\n\n    Based on:\n    Gabriel Taubin\n    \"A signal processing approach to fair surface design\"\n    Siggraph 1995\n\n    Args:\n        script: the FilterScript object or script filename to write\n            the filter to.\n        iterations (int): The number of times that the taubin smoothing is\n            iterated. Usually it requires a larger number of iteration than the\n            classical laplacian.\n        t_lambda (float): The lambda parameter of the Taubin Smoothing algorithm\n        t_mu (float): The mu parameter of the Taubin Smoothing algorithm\n        selected (bool): If selected the filter is performed only on the\n            selected faces\n\n    Layer stack:\n        No impacts\n\n    MeshLab versions:\n        2016.12\n        1.3.4BETA", "id": "f9653:m2"}
{"signature": "def _set_NOTIFICATION(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:64>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__NOTIFICATION = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for NOTIFICATION, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/state/messages/sent/NOTIFICATION (uint64)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_NOTIFICATION is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_NOTIFICATION() directly.\n\n    YANG Description: Number of BGP NOTIFICATION messages indicating an\nerror condition has occurred exchanged.", "id": "f23275:c1:m6"}
{"signature": "def _set_priority(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__priority = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority (uint8)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_priority is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_priority() directly.\n\nYANG Description: Priority of the neighboring IS(LAN Hello only).", "id": "f22419:c1:m21"}
{"signature": "def clean(self):", "body": "for f in sorted(self.components.keys()):<EOL><INDENT>unused = not any(self.switches[a][f] for a in self.analytes)<EOL>if unused:<EOL><INDENT>self.remove(f)<EOL><DEDENT><DEDENT>", "docstring": "Remove unused filters.", "id": "f2434:c0:m5"}
{"signature": "@register.assignment_tag()<EOL>def sizeof(collection):", "body": "size = len(collection)<EOL>return size<EOL>", "docstring": "Usage:\n{% sizeof mylist as mylistsize %}", "id": "f14851:m0"}
{"signature": "@abstractmethod<EOL><INDENT>def json(self) -> Union[list, dict]:<DEDENT>", "body": "pass<EOL>", "docstring": "Returns json compatible state of the control instance including\n        its nested controls.\n\n        Returns:\n            control: Json representation of control state.", "id": "f3143:c0:m0"}
{"signature": "def update_registry(self, registry, registry_user, registry_pass, insecure=False, registry_type=\"<STR_LIT>\", validate=True):", "body": "if self._registry_string_is_valid(registry):<EOL><INDENT>return [False, \"<STR_LIT>\"]<EOL><DEDENT>payload = {<EOL>'<STR_LIT>': registry,<EOL>'<STR_LIT>': registry_user,<EOL>'<STR_LIT>': registry_pass,<EOL>'<STR_LIT>': registry_type,<EOL>'<STR_LIT>': not insecure}<EOL>url = \"<STR_LIT>\".format(<EOL>base_url=self.url,<EOL>registry=registry,<EOL>validate=validate)<EOL>res = requests.put(url, data=json.dumps(payload), headers=self.hdrs, verify=self.ssl_verify)<EOL>if not self._checkResponse(res):<EOL><INDENT>return [False, self.lasterr]<EOL><DEDENT>return [True, res.json()]<EOL>", "docstring": "**Description**\n            Update an existing image registry.\n\n        **Arguments**\n            - registry: Full hostname/port of registry. Eg. myrepo.example.com:5000\n            - registry_user: Username\n            - registry_pass: Password\n            - insecure: Allow connection to registry without SSL cert checks (ex: if registry uses a self-signed SSL certificate)\n            - registry_type: Specify the registry type. 'docker_v2' and 'awsecr' are supported (default='docker_v2')\n            - validate: If set to 'False' will not attempt to validate registry/creds on registry add\n\n        **Success Return Value**\n            A JSON object representing the registry.", "id": "f17821:c0:m12"}
{"signature": "def _set_sid_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={\"<STR_LIT>\": {}, \"<STR_LIT>\": {}},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__sid_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for sid_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_prefix/tlvs/tlv/sid_label_binding/tlvs/tlv/sid_label_binding/state/sid_type (oc-ospf-types:sr-sid-type)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_sid_type is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_sid_type() directly.\n\nYANG Description: The type of the value contained within the sub-TLV", "id": "f23005:c1:m3"}
{"signature": "def _check_compatible_regs(self, rhs):", "body": "list1 = self.qregs + self.cregs<EOL>list2 = rhs.qregs + rhs.cregs<EOL>for element1 in list1:<EOL><INDENT>for element2 in list2:<EOL><INDENT>if element2.name == element1.name:<EOL><INDENT>if element1 != element2:<EOL><INDENT>raise QiskitError(\"<STR_LIT>\")<EOL><DEDENT><DEDENT><DEDENT><DEDENT>", "docstring": "Raise exception if the circuits are defined on incompatible registers", "id": "f10739:c0:m25"}
{"signature": "def delete_file(self, path):", "body": "conn = self.get_conn()<EOL>conn.delete(path)<EOL>", "docstring": "Removes a file on the FTP Server.\n\n:param path: full path to the remote file\n:type path: str", "id": "f9158:c0:m11"}
{"signature": "def comparison_plots(df, els=['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']):", "body": "<EOL>As = []<EOL>Rs = []<EOL>analytes = [c for c in df.columns if ('<STR_LIT>' not in c) and ('<STR_LIT>' not in c)]<EOL>ratios = [c for c in df.columns if ('<STR_LIT>' in c)]<EOL>for e in els:<EOL><INDENT>if e == '<STR_LIT>':<EOL><INDENT>As.append('<STR_LIT>')<EOL><DEDENT>elif e == '<STR_LIT>':<EOL><INDENT>As.append('<STR_LIT>')<EOL><DEDENT>else:<EOL><INDENT>As.append([a for a in analytes if e in a][<NUM_LIT:0>])<EOL><DEDENT>Rs.append([r for r in ratios if e in r][<NUM_LIT:0>][:-<NUM_LIT:2>])<EOL><DEDENT>fig, axs = plt.subplots(len(els), <NUM_LIT:3>, figsize=(<NUM_LIT>, len(els) * <NUM_LIT:2>))<EOL>for i, (e, a) in enumerate(zip(Rs, As)):<EOL><INDENT>if a == '<STR_LIT>':<EOL><INDENT>m = <NUM_LIT><EOL>u = '<STR_LIT>'<EOL><DEDENT>else:<EOL><INDENT>m = <NUM_LIT:1><EOL>u = '<STR_LIT>'<EOL><DEDENT>c = element_colour(a)<EOL>tax, lax, hax = axs[i]<EOL>x = df.loc[:, e + '<STR_LIT>'].values * m<EOL>yt = df.loc[:, e + '<STR_LIT>'].values * m<EOL>yl = df.loc[:, a].values * m<EOL>rt = yt - x<EOL>rl = yl - x<EOL>tax.scatter(x, yt, c=c, s=<NUM_LIT:15>, lw=<NUM_LIT:0.5>, edgecolor='<STR_LIT:k>', alpha=<NUM_LIT:0.5>)<EOL>lax.scatter(x, yl, c=c, s=<NUM_LIT:15>, lw=<NUM_LIT:0.5>, edgecolor='<STR_LIT:k>', alpha=<NUM_LIT:0.5>)<EOL>rt = rt[~np.isnan(rt)]<EOL>rl = rl[~np.isnan(rl)]<EOL>lims = np.percentile(np.hstack([rt, rl]), [<NUM_LIT>, <NUM_LIT:1>])<EOL>lims += lims.ptp() * np.array((-<NUM_LIT>, <NUM_LIT>))<EOL>bins = np.linspace(*lims, <NUM_LIT:100>)<EOL>kdt = stats.gaussian_kde(rt, <NUM_LIT>)<EOL>kdl = stats.gaussian_kde(rl, <NUM_LIT>)<EOL>hax.fill_between(bins, kdl(bins), facecolor=c, alpha=<NUM_LIT>, edgecolor='<STR_LIT:k>', lw=<NUM_LIT:0.5>, label='<STR_LIT>')<EOL>hax.fill_between(bins, kdt(bins), facecolor=c, alpha=<NUM_LIT>, edgecolor='<STR_LIT:k>', lw=<NUM_LIT:0.5>, label='<STR_LIT>')<EOL>hax.set_ylim([<NUM_LIT:0>, hax.get_ylim()[-<NUM_LIT:1>]])<EOL>hax.set_xlim(lims)<EOL>hax.axvline(<NUM_LIT:0>, c='<STR_LIT:k>', ls='<STR_LIT>', alpha=<NUM_LIT>)<EOL>hax.set_ylabel('<STR_LIT>')<EOL>tax.set_ylabel(e + '<STR_LIT>'+ u + '<STR_LIT:)>')<EOL>tax.text(<NUM_LIT>,<NUM_LIT>,fmt_RSS(rt), fontsize=<NUM_LIT:8>,<EOL>ha='<STR_LIT:left>', va='<STR_LIT>', transform=tax.transAxes)<EOL>lax.text(<NUM_LIT>,<NUM_LIT>,fmt_RSS(rl), fontsize=<NUM_LIT:8>,<EOL>ha='<STR_LIT:left>', va='<STR_LIT>', transform=lax.transAxes)<EOL>xlim = np.percentile(x[~np.isnan(x)], [<NUM_LIT:0>, <NUM_LIT>])<EOL>for ax in [tax, lax]:<EOL><INDENT>ax.set_xlim(xlim)<EOL>ax.set_ylim(xlim)<EOL>ax.plot(xlim, xlim, c='<STR_LIT:k>', ls='<STR_LIT>', alpha=<NUM_LIT>)<EOL><DEDENT>for ax in axs[i]:<EOL><INDENT>if ax.is_last_row():<EOL><INDENT>hax.set_xlabel('<STR_LIT>')<EOL>tax.set_xlabel('<STR_LIT>')<EOL>lax.set_xlabel('<STR_LIT>')<EOL>hax.legend(fontsize=<NUM_LIT:8>)<EOL><DEDENT>if ax.is_first_row():<EOL><INDENT>tax.set_title('<STR_LIT>', loc='<STR_LIT:left>')<EOL>lax.set_title('<STR_LIT>', loc='<STR_LIT:left>')<EOL><DEDENT><DEDENT><DEDENT>fig.tight_layout()<EOL>return fig, axs<EOL>", "docstring": "Function for plotting Test User and LAtools data comparison.\n\nParameters\n----------\ndf : pandas.DataFrame\n    A dataframe containing reference ('X/Ca_r'), test user \n    ('X/Ca_t') and LAtools ('X123') data.\nels : list\n    list of elements (names only) to plot.", "id": "f2452:m4"}
{"signature": "def check_children_name_availability(<EOL>self, group_name, service_name, name=None, type=None, custom_headers=None, raw=False, **operation_config):", "body": "parameters = models.NameAvailabilityRequest(name=name, type=type)<EOL>url = self.check_children_name_availability.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", service_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ApiErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Check nested resource name validity and availability.\n\n        This method checks whether a proposed nested resource name is valid and\n        available.\n\n        :param group_name: Name of the resource group\n        :type group_name: str\n        :param service_name: Name of the service\n        :type service_name: str\n        :param name: The proposed resource name\n        :type name: str\n        :param type: The resource type chain (e.g. virtualMachines/extensions)\n        :type type: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: NameAvailabilityResponse or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.datamigration.models.NameAvailabilityResponse or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ApiErrorException<azure.mgmt.datamigration.models.ApiErrorException>`", "id": "f41413:c0:m14"}
{"signature": "def crypto_sign_keypair(seed=None):", "body": "if seed is None:<EOL><INDENT>seed = os.urandom(PUBLICKEYBYTES)<EOL><DEDENT>else:<EOL><INDENT>warnings.warn(\"<STR_LIT>\",<EOL>RuntimeWarning)<EOL><DEDENT>if len(seed) != <NUM_LIT:32>:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>skbytes = seed<EOL>vkbytes = djbec.publickey(skbytes)<EOL>return Keypair(vkbytes, skbytes+vkbytes)<EOL>", "docstring": "Return (verifying, secret) key from a given seed, or os.urandom(32)", "id": "f17131:m0"}
{"signature": "def __init__(self, refname, **kwargs):", "body": "self.refname = refname<EOL>self.cat = kwargs.setdefault(\"<STR_LIT>\", self.cat)<EOL>self.failsafe = kwargs.setdefault(\"<STR_LIT>\", self.failsafe)<EOL>self.fuzzer = GramFuzzer.instance()<EOL>", "docstring": "Create a new ``Ref`` instance\n\n        :param str refname: The name of the rule to reference\n        :param str cat: The name of the category the rule is defined in", "id": "f5940:c13:m0"}
{"signature": "def set_timers(self):", "body": "logger.debug('<STR_LIT>')<EOL>self.set_timeout(self.current_state,<EOL>self.renewing_time_expires,<EOL>self.client.lease.renewal_time)<EOL>self.set_timeout(self.current_state,<EOL>self.rebinding_time_expires,<EOL>self.client.lease.rebinding_time)<EOL>", "docstring": "Set renewal, rebinding times.", "id": "f13067:c0:m10"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls/igp_ldp_sync/config (container)\n\nYANG Description: This container defines ISIS/IGP configuration.", "id": "f22505:c0:m2"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/mpls/te_global_attributes/srlgs/srlg/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration parameters related to the SRLG", "id": "f22182:c0:m6"}
{"signature": "def translate_ecosystem_intl_col_tern(s):", "body": "subst, attr, mode = s<EOL>return m(translate_ecosystem_intl_col(subst), m(m(attr)))<EOL>", "docstring": "O:.M:.-M:.-' => s.o.-k.o.-\u2018M:O:.-\u2018,M:.-',_", "id": "f12534:m25"}
{"signature": "def train_size(self):", "body": "train_set = self.train_set()<EOL>if isinstance(train_set, collections.Iterable):<EOL><INDENT>return len(list(train_set))<EOL><DEDENT>else:<EOL><INDENT>return None<EOL><DEDENT>", "docstring": "Return size of training data. (optional)\n:rtype: number", "id": "f6118:c0:m3"}
{"signature": "def error(self, status=None):", "body": "def decorator(callback):<EOL><INDENT>self._error_handlers[status] = callback<EOL>return callback<EOL><DEDENT>return decorator<EOL>", "docstring": "Decorator to add a callback that generates error page.\n\n        The *status* parameter specifies the HTTP response status code\n        for which the decorated callback should be invoked. If the\n        *status* argument is not specified, then the decorated callable\n        is considered to be a fallback callback.\n\n        A fallback callback, when defined, is invoked to generate the\n        error page for any HTTP response representing an error when\n        there is no error handler defined explicitly for the response\n        code of the HTTP response.\n\n        Arguments:\n          status(int, optional): HTTP response status code.\n\n        Returns:\n          function: Decorator function to add error handler.", "id": "f4315:c0:m7"}
{"signature": "def _compute_non_batch_kl(mu_a, sigma_a, mu_b, sigma_b):", "body": "<EOL>sigma_b_inv = np.linalg.inv(sigma_b)<EOL>t = np.trace(sigma_b_inv.dot(sigma_a))<EOL>q = (mu_b - mu_a).dot(sigma_b_inv).dot(mu_b - mu_a)<EOL>k = mu_a.shape[<NUM_LIT:0>]<EOL>l = np.log(np.linalg.det(sigma_b) / np.linalg.det(sigma_a))<EOL>return <NUM_LIT:0.5> * (t + q - k + l)<EOL>", "docstring": "Non-batch KL for N(mu_a, sigma_a), N(mu_b, sigma_b).", "id": "f15614:m0"}
{"signature": "def read(self, resource_id):", "body": "self.logger.debug('<STR_LIT>'.format(resource_id))<EOL>return self.driver._es.get(<EOL>index=self.driver._index,<EOL>id=resource_id,<EOL>doc_type='<STR_LIT>'<EOL>)['<STR_LIT>']<EOL>", "docstring": "Read object in elasticsearch using the resource_id.\n        :param resource_id: id of the object to be read.\n        :return: object value from elasticsearch.", "id": "f6004:c0:m3"}
{"signature": "def delete(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Delete schedule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param name: The name of the schedule.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f45878:c0:m5"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, circuit_name, peering_name, connection_name, express_route_circuit_connection_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>circuit_name=circuit_name,<EOL>peering_name=peering_name,<EOL>connection_name=connection_name,<EOL>express_route_circuit_connection_parameters=express_route_circuit_connection_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a Express Route Circuit Connection in the specified\n        express route circuits.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param peering_name: The name of the peering.\n        :type peering_name: str\n        :param connection_name: The name of the express route circuit\n         connection.\n        :type connection_name: str\n        :param express_route_circuit_connection_parameters: Parameters\n         supplied to the create or update express route circuit connection\n         operation.\n        :type express_route_circuit_connection_parameters:\n         ~azure.mgmt.network.v2018_08_01.models.ExpressRouteCircuitConnection\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         ExpressRouteCircuitConnection or\n         ClientRawResponse<ExpressRouteCircuitConnection> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_08_01.models.ExpressRouteCircuitConnection]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_08_01.models.ExpressRouteCircuitConnection]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31674:c0:m5"}
{"signature": "def _get_link_loss(self):", "body": "return self.__link_loss<EOL>", "docstring": "Getter method for link_loss, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/link_loss (container)\n\nYANG Description: This container defines unidirectional link loss delay.", "id": "f22720:c1:m65"}
{"signature": "def _get_state(self):", "body": "return self.__state<EOL>", "docstring": "Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/esh/state (container)\n\nYANG Description: Operational state relating to ESH PDUs", "id": "f22429:c0:m2"}
{"signature": "def add_plot_parser(subparsers):", "body": "argparser_replot = subparsers.add_parser(\"<STR_LIT>\", help=\"<STR_LIT>\")<EOL>group_replot = argparser_replot.add_argument_group(\"<STR_LIT>\")<EOL>group_replot.add_argument(\"<STR_LIT>\", \"<STR_LIT>\", action=\"<STR_LIT:store>\", dest=\"<STR_LIT>\", required=True, metavar='<STR_LIT>',<EOL>help=\"<STR_LIT>\")<EOL>add_output_option(group_replot)<EOL>group_replot.add_argument(\"<STR_LIT>\", \"<STR_LIT>\", action='<STR_LIT:store>', dest='<STR_LIT>', default=<NUM_LIT:1.0>, type=float, metavar='<STR_LIT:float>',<EOL>help='<STR_LIT>',)<EOL>return<EOL>", "docstring": "Add function 'plot' argument parsers.", "id": "f9752:m7"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, express_route_gateway_name, connection_name, put_express_route_connection_parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>express_route_gateway_name=express_route_gateway_name,<EOL>connection_name=connection_name,<EOL>put_express_route_connection_parameters=put_express_route_connection_parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates a connection between an ExpressRoute gateway and an\n        ExpressRoute circuit.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param express_route_gateway_name: The name of the ExpressRoute\n         gateway.\n        :type express_route_gateway_name: str\n        :param connection_name: The name of the connection subresource.\n        :type connection_name: str\n        :param put_express_route_connection_parameters: Parameters required in\n         an ExpressRouteConnection PUT operation.\n        :type put_express_route_connection_parameters:\n         ~azure.mgmt.network.v2019_02_01.models.ExpressRouteConnection\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns ExpressRouteConnection\n         or ClientRawResponse<ExpressRouteConnection> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2019_02_01.models.ExpressRouteConnection]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2019_02_01.models.ExpressRouteConnection]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34929:c0:m2"}
{"signature": "def term_echo(command, nindent=<NUM_LIT:0>, env=None, fpointer=None, cols=<NUM_LIT>):", "body": "<EOL>os.environ[\"<STR_LIT>\"] = str(cols)<EOL>command_int = command<EOL>if env:<EOL><INDENT>for var, repl in env.items():<EOL><INDENT>command_int = command_int.replace(\"<STR_LIT>\" + var + \"<STR_LIT:}>\", repl)<EOL><DEDENT><DEDENT>tokens = command_int.split(\"<STR_LIT:U+0020>\")<EOL>if (platform.system().lower() == \"<STR_LIT>\") and (tokens[<NUM_LIT:0>].endswith(\"<STR_LIT>\")):<EOL><INDENT>tokens = [sys.executable] + tokens<EOL><DEDENT>proc = subprocess.Popen(tokens, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)<EOL>stdout = proc.communicate()[<NUM_LIT:0>]<EOL>if sys.hexversion >= <NUM_LIT>:<EOL><INDENT>stdout = stdout.decode(\"<STR_LIT:utf-8>\")<EOL><DEDENT>stdout = stdout.split(\"<STR_LIT:\\n>\")<EOL>indent = nindent * \"<STR_LIT:U+0020>\"<EOL>fpointer(\"<STR_LIT:\\n>\", dedent=False)<EOL>fpointer(\"<STR_LIT>\".format(indent), dedent=False)<EOL>fpointer(\"<STR_LIT:\\n>\", dedent=False)<EOL>fpointer(\"<STR_LIT>\".format(indent, command), dedent=False)<EOL>for line in stdout:<EOL><INDENT>if line.strip():<EOL><INDENT>fpointer(indent + \"<STR_LIT:U+0020>\" + line.replace(\"<STR_LIT:\\t>\", \"<STR_LIT:U+0020>\") + \"<STR_LIT:\\n>\", dedent=False)<EOL><DEDENT>else:<EOL><INDENT>fpointer(\"<STR_LIT:\\n>\", dedent=False)<EOL><DEDENT><DEDENT>fpointer(\"<STR_LIT:\\n>\", dedent=False)<EOL>", "docstring": "Print STDOUT resulting from a Bash shell command formatted in reStructuredText.\n\n:param command: Bash shell command\n:type  command: string\n\n:param nindent: Indentation level\n:type  nindent: integer\n\n:param env: Environment variable replacement dictionary. The Bash\n            command is pre-processed and any environment variable\n            represented in the full notation (:bash:`${...}`) is replaced.\n            The dictionary key is the environment variable name and the\n            dictionary value is the replacement value. For example, if\n            **command** is :code:`'${PYTHON_CMD} -m \"x=5\"'` and **env**\n            is :code:`{'PYTHON_CMD':'python3'}` the actual command issued\n            is :code:`'python3 -m \"x=5\"'`\n:type  env: dictionary\n\n:param fpointer: Output function pointer. Normally is :code:`cog.out` but\n                 :code:`print` or other functions can be used for\n                 debugging\n:type  fpointer: function object\n\n:param cols: Number of columns of output\n:type  cols: integer", "id": "f6758:m1"}
{"signature": "def build_attrs(self, base_attrs, extra_attrs=None):", "body": "attrs = base_attrs.copy()<EOL>if extra_attrs is not None:<EOL><INDENT>attrs.update(extra_attrs)<EOL><DEDENT>return attrs<EOL>", "docstring": "Build an attribute dictionary.", "id": "f3813:c0:m7"}
{"signature": "def _get_origin(self):", "body": "return self.__origin<EOL>", "docstring": "Getter method for origin, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/addresses/address/state/origin (ip-address-origin)\n\n    YANG Description: The origin of this address, e.g., statically configured,\nassigned by DHCP, etc..", "id": "f22011:c0:m8"}
{"signature": "def _largest_integer_by_dtype(dt):", "body": "if not _is_known_dtype(dt):<EOL><INDENT>raise TypeError(\"<STR_LIT>\".format(dt.name))<EOL><DEDENT>if dt.is_floating:<EOL><INDENT>return int(<NUM_LIT:2>**(np.finfo(dt.as_numpy_dtype).nmant + <NUM_LIT:1>))<EOL><DEDENT>if dt.is_integer:<EOL><INDENT>return np.iinfo(dt.as_numpy_dtype).max<EOL><DEDENT>if dt.base_dtype == tf.bool:<EOL><INDENT>return int(<NUM_LIT:1>)<EOL><DEDENT>raise TypeError(\"<STR_LIT>\".format(dt.name))<EOL>", "docstring": "Helper returning the largest integer exactly representable by dtype.", "id": "f15574:m21"}
{"signature": "def list(<EOL>self, resource_group_name, load_balancer_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", load_balancer_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.BackendAddressPoolPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.BackendAddressPoolPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the load balancer backed address pools.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param load_balancer_name: The name of the load balancer.\n        :type load_balancer_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of BackendAddressPool\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.BackendAddressPoolPaged[~azure.mgmt.network.v2018_11_01.models.BackendAddressPool]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32760:c0:m1"}
{"signature": "def get_relationship_info(tree, media, image_sizes):", "body": "if tree is None:<EOL><INDENT>return {}<EOL><DEDENT>result = {}<EOL>for el in tree.iter():<EOL><INDENT>el_id = el.get('<STR_LIT>')<EOL>if el_id is None:<EOL><INDENT>continue<EOL><DEDENT>target = el.get('<STR_LIT>')<EOL>if any(<EOL>target.lower().endswith(ext) for<EOL>ext in IMAGE_EXTENSIONS_TO_SKIP):<EOL><INDENT>continue<EOL><DEDENT>if target in media:<EOL><INDENT>image_size = image_sizes.get(el_id)<EOL>target = convert_image(media[target], image_size)<EOL><DEDENT>result[el_id] = cgi.escape(target)<EOL><DEDENT>return result<EOL>", "docstring": "There is a separate file holds the targets to links as well as the targets\nfor images. Return a dictionary based on the relationship id and the\ntarget.", "id": "f11219:m31"}
{"signature": "def _read(self, n):", "body": "if n <= len(self._prefix):<EOL><INDENT>result = self._prefix[:n]<EOL>self._prefix = self._prefix[n:]<EOL>return result<EOL><DEDENT>n -= len(self._prefix)<EOL>result = self._prefix + self.f.read(n)<EOL>self._prefix = \"<STR_LIT>\"<EOL>return result<EOL>", "docstring": "Read (up to) 'n' bytes from the underlying file.  If any bytes\n        have been pushed in with _unread() those are returned first.", "id": "f18016:c0:m2"}
{"signature": "def share_vm_image(self, vm_image_name, permission):", "body": "_validate_not_none('<STR_LIT>', vm_image_name)<EOL>_validate_not_none('<STR_LIT>', permission)<EOL>path = self._get_sharing_path_using_vm_image_name(vm_image_name)<EOL>query = '<STR_LIT>' + permission<EOL>path = path + '<STR_LIT:?>' + query.lstrip('<STR_LIT:&>')<EOL>return self._perform_put(<EOL>path, None, as_async=True, x_ms_version='<STR_LIT>'<EOL>)<EOL>", "docstring": "Share an already replicated OS image. This operation is only for\npublishers. You have to be registered as image publisher with Windows\nAzure to be able to call this.\n\nvm_image_name:\n    The name of the virtual machine image to share\npermission:\n    The sharing permission: public, msdn, or private", "id": "f41502:c0:m73"}
{"signature": "def check_ip_address_availability(<EOL>self, resource_group_name, virtual_network_name, ip_address=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.check_ip_address_availability.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_network_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if ip_address is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", ip_address, '<STR_LIT:str>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Checks whether a private IP address is available for use.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_name: The name of the virtual network.\n        :type virtual_network_name: str\n        :param ip_address: The private IP address to be verified.\n        :type ip_address: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: IPAddressAvailabilityResult or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.network.v2017_06_01.models.IPAddressAvailabilityResult or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32290:c0:m8"}
{"signature": "def resubmit(<EOL>self, resource_group_name, workflow_name, trigger_name, history_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.resubmit.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", workflow_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", trigger_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", history_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Resubmits a workflow run based on the trigger history.\n\n        :param resource_group_name: The resource group name.\n        :type resource_group_name: str\n        :param workflow_name: The workflow name.\n        :type workflow_name: str\n        :param trigger_name: The workflow trigger name.\n        :type trigger_name: str\n        :param history_name: The workflow trigger history name. Corresponds to\n         the run name for triggers that resulted in a run.\n        :type history_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f39900:c0:m3"}
{"signature": "def _get_ignore_next_hop_igp_metric(self):", "body": "return self.__ignore_next_hop_igp_metric<EOL>", "docstring": "Getter method for ignore_next_hop_igp_metric, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/route_selection_options/config/ignore_next_hop_igp_metric (boolean)\n\n    YANG Description: Ignore the IGP metric to the next-hop when calculating\nBGP best-path. The default is to select the route for\nwhich the metric to the next-hop is lowest", "id": "f23405:c1:m17"}
{"signature": "def splitext(self):", "body": "filename, ext = os.path.splitext(self)<EOL>return self.__class__(filename), ext<EOL>", "docstring": "p.splitext() -> Return (p.stripext(), p.ext).\n\n        Split the filename extension from this path and return\n        the two parts.  Either part may be empty.\n\n        The extension is everything from '.' to the end of the\n        last path segment.  This has the property that if\n        (a, b) == p.splitext(), then a + b == p.", "id": "f21322:c1:m20"}
{"signature": "def list(<EOL>self, resource_group_name, account_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", account_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ApiErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.LiveEventPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.LiveEventPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "List Live Events.\n\n        Lists the Live Events in the account.\n\n        :param resource_group_name: The name of the resource group within the\n         Azure subscription.\n        :type resource_group_name: str\n        :param account_name: The Media Services account name.\n        :type account_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of LiveEvent\n        :rtype:\n         ~azure.mgmt.media.models.LiveEventPaged[~azure.mgmt.media.models.LiveEvent]\n        :raises:\n         :class:`ApiErrorException<azure.mgmt.media.models.ApiErrorException>`", "id": "f27819:c0:m1"}
{"signature": "def read(self, input_stream, kmip_version=enums.KMIPVersion.KMIP_1_0):", "body": "super(SignatureVerifyRequestPayload, self).read(<EOL>input_stream,<EOL>kmip_version=kmip_version<EOL>)<EOL>local_stream = utils.BytearrayStream(input_stream.read(self.length))<EOL>if self.is_tag_next(enums.Tags.UNIQUE_IDENTIFIER, local_stream):<EOL><INDENT>self._unique_identifier = primitives.TextString(<EOL>tag=enums.Tags.UNIQUE_IDENTIFIER<EOL>)<EOL>self._unique_identifier.read(<EOL>local_stream,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT>if self.is_tag_next(enums.Tags.CRYPTOGRAPHIC_PARAMETERS, local_stream):<EOL><INDENT>self._cryptographic_parameters =attributes.CryptographicParameters()<EOL>self._cryptographic_parameters.read(<EOL>local_stream,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT>if self.is_tag_next(enums.Tags.DATA, local_stream):<EOL><INDENT>self._data = primitives.ByteString(tag=enums.Tags.DATA)<EOL>self._data.read(local_stream, kmip_version=kmip_version)<EOL><DEDENT>if self.is_tag_next(enums.Tags.DIGESTED_DATA, local_stream):<EOL><INDENT>self._digested_data = primitives.ByteString(<EOL>tag=enums.Tags.DIGESTED_DATA<EOL>)<EOL>self._digested_data.read(local_stream, kmip_version=kmip_version)<EOL><DEDENT>if self.is_tag_next(enums.Tags.SIGNATURE_DATA, local_stream):<EOL><INDENT>self._signature_data = primitives.ByteString(<EOL>tag=enums.Tags.SIGNATURE_DATA<EOL>)<EOL>self._signature_data.read(local_stream, kmip_version=kmip_version)<EOL><DEDENT>if self.is_tag_next(enums.Tags.CORRELATION_VALUE, local_stream):<EOL><INDENT>self._correlation_value = primitives.ByteString(<EOL>tag=enums.Tags.CORRELATION_VALUE<EOL>)<EOL>self._correlation_value.read(<EOL>local_stream,<EOL>kmip_version=kmip_version<EOL>)<EOL><DEDENT>if self.is_tag_next(enums.Tags.INIT_INDICATOR, local_stream):<EOL><INDENT>self._init_indicator = primitives.Boolean(<EOL>tag=enums.Tags.INIT_INDICATOR<EOL>)<EOL>self._init_indicator.read(local_stream, kmip_version=kmip_version)<EOL><DEDENT>if self.is_tag_next(enums.Tags.FINAL_INDICATOR, local_stream):<EOL><INDENT>self._final_indicator = primitives.Boolean(<EOL>tag=enums.Tags.FINAL_INDICATOR<EOL>)<EOL>self._final_indicator.read(local_stream, kmip_version=kmip_version)<EOL><DEDENT>self.is_oversized(local_stream)<EOL>", "docstring": "Read the data encoding the SignatureVerify request payload and decode\nit into its constituent parts.\n\nArgs:\n    input_stream (stream): A data stream containing encoded object\n        data, supporting a read method; usually a BytearrayStream\n        object.\n    kmip_version (KMIPVersion): An enumeration defining the KMIP\n        version with which the object will be decoded. Optional,\n        defaults to KMIP 1.0.\n\nRaises:\n    ValueError: Raised if the data attribute is missing from the\n        encoded payload.", "id": "f15107:c0:m17"}
{"signature": "@property<EOL><INDENT>def name(self):<DEDENT>", "body": "return '<STR_LIT>'<EOL>", "docstring": "Return name of item.", "id": "f11560:c1:m1"}
{"signature": "def update_qsd(url, qsd=None, remove=None):", "body": "qsd = qsd or {}<EOL>remove = remove or []<EOL>parsed = urlparse(url)<EOL>current_qsd = OrderedDict(parse_qsl(parsed.query))<EOL>if remove == \"<STR_LIT:*>\":<EOL><INDENT>remove = list(current_qsd.keys())<EOL><DEDENT>for key in remove:<EOL><INDENT>if key not in qsd:<EOL><INDENT>del current_qsd[key]<EOL><DEDENT><DEDENT>for key, value in qsd.items():<EOL><INDENT>if value:<EOL><INDENT>current_qsd[key] = value<EOL><DEDENT><DEDENT>return parsed._replace(query=urlencode(current_qsd)).geturl()<EOL>", "docstring": "Update or remove keys from a query string in a URL\n\n:param url: URL to update\n:param qsd: dict of keys to update, a None value leaves it unchanged\n:param remove: list of keys to remove, or \"*\" to remove all\n               note: updated keys are never removed, even if unchanged\n:return: updated URL", "id": "f8059:m3"}
{"signature": "@property<EOL><INDENT>def distribution(self):<DEDENT>", "body": "return self._distribution<EOL>", "docstring": "Distribution of random variable.", "id": "f15804:c0:m1"}
{"signature": "def mini(self, axis=None):", "body": "if axis is None:<EOL><INDENT>return minimum(self)<EOL><DEDENT>else:<EOL><INDENT>return minimum.reduce(self, axis)<EOL><DEDENT>", "docstring": "Return the array minimum along the specified axis.\n\nParameters\n----------\naxis : int, optional\n    The axis along which to find the minima. Default is None, in which case\n    the minimum value in the whole array is returned.\n\nReturns\n-------\nmin : scalar or MaskedArray\n    If `axis` is None, the result is a scalar. Otherwise, if `axis` is\n    given and the array is at least 2-D, the result is a masked array with\n    dimension one smaller than the array on which `mini` is called.\n\nExamples\n--------\n>>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)\n>>> print x\n[[0 --]\n [2 3]\n [4 --]]\n>>> x.mini()\n0\n>>> x.mini(axis=0)\nmasked_array(data = [0 3],\n             mask = [False False],\n       fill_value = 999999)\n>>> print x.mini(axis=1)\n[0 2 4]", "id": "f18992:c13:m79"}
{"signature": "def bytesize(self, byteorder='<STR_LIT:@>'):", "body": "<EOL>seed_size = struct.calcsize(byteorder+'<STR_LIT:q>')<EOL>length_size = struct.calcsize(byteorder+'<STR_LIT:i>')<EOL>hashvalue_size = struct.calcsize(byteorder+'<STR_LIT:I>')<EOL>return seed_size + length_size + len(self) * hashvalue_size<EOL>", "docstring": "Compute the byte size after serialization.\n\n        Args:\n            byteorder (str, optional): This is byte order of the serialized data. Use one\n                of the `byte order characters\n                <https://docs.python.org/3/library/struct.html#byte-order-size-and-alignment>`_:\n                ``@``, ``=``, ``<``, ``>``, and ``!``.\n                Default is ``@`` -- the native order.\n\n        Returns:\n            int: Size in number of bytes after serialization.", "id": "f5115:c0:m4"}
{"signature": "def stream(self, url, <EOL>headers=None, <EOL>stream_to=None,<EOL>retry=True, <EOL>default_headers=True,<EOL>show_progress=True):", "body": "bot.debug(\"<STR_LIT>\" %url)<EOL>if headers == None:<EOL><INDENT>if self.headers is None:<EOL><INDENT>self._reset_headers()<EOL><DEDENT>headers = self.headers.copy()<EOL><DEDENT>response = requests.get(url,         <EOL>headers=headers,<EOL>verify=self._verify(),<EOL>stream=True)<EOL>if response.status_code == <NUM_LIT> and retry is True:<EOL><INDENT>if hasattr(self,'<STR_LIT>'):<EOL><INDENT>self._update_token(response)<EOL>return self.stream(url,<EOL>headers, <EOL>stream_to, <EOL>retry=False,<EOL>show_progress=show_progress)<EOL><DEDENT><DEDENT>if response.status_code == <NUM_LIT:200>: <EOL><INDENT>return self._stream(response,<EOL>stream_to=stream_to,<EOL>show_progress=show_progress)<EOL><DEDENT>bot.error(\"<STR_LIT>\" %(response.status_code))<EOL>sys.exit(<NUM_LIT:1>)<EOL>", "docstring": "stream is a get that will stream to file_name. This stream is intended\nto take a url and (optionally) a set of headers and file to stream to,\nand will generate a response with requests.get.\n\nParameters\n==========\nurl: the url to do a requests.get to\nheaders: any updated headers to use for the requets\nstream_to: the file to stream to\nshow_progress: boolean to show progress bar\nretry: should the client retry? (intended for use after token refresh)\n       by default we retry once after token refresh, then fail.", "id": "f9947:m9"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/config (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_config is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_config() directly.\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23410:c1:m3"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/config (container)\n\n    YANG Description: Configuration parameters relating to the prefix\nlimit for the AFI-SAFI", "id": "f23431:c0:m2"}
{"signature": "def delete_hierarchical_entity_role(<EOL>self, app_id, version_id, h_entity_id, role_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete_hierarchical_entity_role.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", app_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", version_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", h_entity_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", role_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Delete a role for a given hierarchical role in a version of the\n        application.\n\n        :param app_id: The application ID.\n        :type app_id: str\n        :param version_id: The version ID.\n        :type version_id: str\n        :param h_entity_id: The hierarchical entity extractor ID.\n        :type h_entity_id: str\n        :param role_id: The entity role Id.\n        :type role_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: OperationStatus or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.cognitiveservices.language.luis.authoring.models.OperationStatus\n         or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException>`", "id": "f43227:c0:m100"}
{"signature": "def pull(self, images, <EOL>file_name=None, <EOL>save=True, <EOL>force=False, <EOL>base=None, <EOL>**kwargs):", "body": "if not isinstance(images,list):<EOL><INDENT>images = [images]<EOL><DEDENT>bot.debug('<STR_LIT>' %len(images))<EOL>finished = []<EOL>for image in images:<EOL><INDENT>base = self._update_base(image)<EOL>q = parse_image_name(remove_uri(image), base=base)<EOL>image_file = self._pull(file_name=file_name, <EOL>save=save, <EOL>force=force, <EOL>names=q,<EOL>kwargs=kwargs)<EOL>finished.append(image_file)<EOL><DEDENT>if len(finished) == <NUM_LIT:1>:<EOL><INDENT>finished = finished[<NUM_LIT:0>]<EOL><DEDENT>return finished<EOL>", "docstring": "pull an image from a docker hub. This is a (less than ideal) workaround\n       that actually does the following:\n\n       - creates a sandbox folder\n       - adds docker layers, metadata folder, and custom metadata to it\n       - converts to a squashfs image with build\n\n    the docker manifests are stored with registry metadata.\n\n    Parameters\n    ==========\n    images: refers to the uri given by the user to pull in the format\n    <collection>/<namespace>. You should have an API that is able to \n    retrieve a container based on parsing this uri.\n    file_name: the user's requested name for the file. It can \n               optionally be None if the user wants a default.\n    save: if True, you should save the container to the database\n          using self.add()\n    base: the registry base, in case the client doesn't want to set in env.\n\n    Returns\n    =======\n    finished: a single container path, or list of paths", "id": "f9925:m0"}
{"signature": "@staticmethod<EOL><INDENT>def parse_channel_info(raw_channel_info):<DEDENT>", "body": "result = json.loads(raw_channel_info)<EOL>return result['<STR_LIT>']<EOL>", "docstring": "Parse a channel info JSON stream.\n\n        This method parses a JSON stream, containing the information\n        from a channel, and returns a dict with the parsed data.\n\n        :param raw_channel_info\n\n        :returns: a dict with the parsed information about a channel", "id": "f13174:c0:m8"}
{"signature": "@containers<EOL>def xPa7isagt3Lq(app):", "body": "@contrib.shared_task<EOL>class Container(Injector):<EOL><INDENT>name = \"<STR_LIT>\"<EOL>run = Run<EOL><DEDENT>return Container<EOL>", "docstring": "Shared task decorator.", "id": "f5020:m2"}
{"signature": "def create(<EOL>self, resource_group_name, automation_account_name, source_control_name, source_control_sync_job_id, commit_id, custom_headers=None, raw=False, **operation_config):", "body": "parameters = models.SourceControlSyncJobCreateParameters(commit_id=commit_id)<EOL>url = self.create.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", automation_account_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", source_control_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", source_control_sync_job_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.put(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Creates the sync job for a source control.\n\n        :param resource_group_name: Name of an Azure Resource group.\n        :type resource_group_name: str\n        :param automation_account_name: The name of the automation account.\n        :type automation_account_name: str\n        :param source_control_name: The source control name.\n        :type source_control_name: str\n        :param source_control_sync_job_id: The source control sync job id.\n        :type source_control_sync_job_id: str\n        :param commit_id: The commit id of the source control sync job. If not\n         syncing to a commitId, enter an empty string.\n        :type commit_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: SourceControlSyncJob or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.automation.models.SourceControlSyncJob or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.automation.models.ErrorResponseException>`", "id": "f43567:c0:m1"}
{"signature": "def list_web_apps_by_hybrid_connection(<EOL>self, resource_group_name, name, namespace_name, relay_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_web_apps_by_hybrid_connection.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", namespace_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", relay_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.StrPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.StrPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get all apps that use a Hybrid Connection in an App Service Plan.\n\n        Get all apps that use a Hybrid Connection in an App Service Plan.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the App Service plan.\n        :type name: str\n        :param namespace_name: Name of the Hybrid Connection namespace.\n        :type namespace_name: str\n        :param relay_name: Name of the Hybrid Connection relay.\n        :type relay_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of str\n        :rtype: ~azure.mgmt.web.models.StrPaged[str]\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44983:c0:m12"}
{"signature": "def run_command(<EOL>self, resource_group_name, vm_scale_set_name, instance_id, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._run_command_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_scale_set_name=vm_scale_set_name,<EOL>instance_id=instance_id,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, lro_options={'<STR_LIT>': '<STR_LIT:location>'}, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Run command on a virtual machine in a VM scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_scale_set_name: The name of the VM scale set.\n        :type vm_scale_set_name: str\n        :param instance_id: The instance ID of the virtual machine.\n        :type instance_id: str\n        :param parameters: Parameters supplied to the Run command operation.\n        :type parameters:\n         ~azure.mgmt.compute.v2018_04_01.models.RunCommandInput\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns RunCommandResult or\n         ClientRawResponse<RunCommandResult> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2018_04_01.models.RunCommandResult]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2018_04_01.models.RunCommandResult]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25732:c0:m25"}
{"signature": "def _get_extended_admin_group(self):", "body": "return self.__extended_admin_group<EOL>", "docstring": "Getter method for extended_admin_group, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/extended_admin_group (container)\n\nYANG Description: This container defines sub-TLV 14.", "id": "f22592:c1:m32"}
{"signature": "@any_form_field.register(forms.DecimalField)<EOL>def decimal_field_data(field, **kwargs):", "body": "min_value = <NUM_LIT:0><EOL>max_value = <NUM_LIT:10><EOL>from django.core.validators import MinValueValidator, MaxValueValidator <EOL>for elem in field.validators:<EOL><INDENT>if isinstance(elem, MinValueValidator):<EOL><INDENT>min_value = elem.limit_value<EOL><DEDENT>if isinstance(elem, MaxValueValidator):<EOL><INDENT>max_value = elem.limit_value<EOL><DEDENT><DEDENT>if (field.max_digits and field.decimal_places):<EOL><INDENT>from decimal import Decimal<EOL>max_value = min(max_value,<EOL>Decimal('<STR_LIT>' % ('<STR_LIT>'*(field.max_digits-field.decimal_places),<EOL>'<STR_LIT>'*field.decimal_places)))<EOL><DEDENT>min_value = kwargs.get('<STR_LIT>') or min_value<EOL>max_value = kwargs.get('<STR_LIT>') or max_value<EOL>return str(xunit.any_decimal(min_value=min_value,<EOL>max_value=max_value,<EOL>decimal_places = field.decimal_places or <NUM_LIT:2>))<EOL>", "docstring": "Return random value for DecimalField\n\n>>> result = any_form_field(forms.DecimalField(max_value=100, min_value=11, max_digits=4, decimal_places = 2))\n>>> type(result)\n<type 'str'>\n>>> from decimal import Decimal\n>>> Decimal(result) >= 11, Decimal(result) <= Decimal('99.99')\n(True, True)", "id": "f10407:m5"}
{"signature": "@track_production<EOL><INDENT>def p_class_invocation_statement(self, p):<DEDENT>", "body": "p[<NUM_LIT:2>].__class__ = ClassInvocationNode<EOL>p[<NUM_LIT:0>] = InvocationStatementNode(p[<NUM_LIT:2>])<EOL>", "docstring": "statement : TRANSFORM implicit_invocation", "id": "f14752:c65:m57"}
{"signature": "def warn(message, category=None, stacklevel=<NUM_LIT:1>):", "body": "<EOL>if isinstance(message, Warning):<EOL><INDENT>category = message.__class__<EOL><DEDENT>if category is None:<EOL><INDENT>category = UserWarning<EOL><DEDENT>assert issubclass(category, Warning)<EOL>try:<EOL><INDENT>caller = sys._getframe(stacklevel)<EOL><DEDENT>except ValueError:<EOL><INDENT>globals = sys.__dict__<EOL>lineno = <NUM_LIT:1><EOL><DEDENT>else:<EOL><INDENT>globals = caller.f_globals<EOL>lineno = caller.f_lineno<EOL><DEDENT>if '<STR_LIT>' in globals:<EOL><INDENT>module = globals['<STR_LIT>']<EOL><DEDENT>else:<EOL><INDENT>module = \"<STR_LIT>\"<EOL><DEDENT>filename = globals.get('<STR_LIT>')<EOL>if filename:<EOL><INDENT>fnl = filename.lower()<EOL>if fnl.endswith((\"<STR_LIT>\", \"<STR_LIT>\")):<EOL><INDENT>filename = filename[:-<NUM_LIT:1>]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>if module == \"<STR_LIT:__main__>\":<EOL><INDENT>try:<EOL><INDENT>filename = sys.argv[<NUM_LIT:0>]<EOL><DEDENT>except AttributeError:<EOL><INDENT>filename = '<STR_LIT:__main__>'<EOL><DEDENT><DEDENT>if not filename:<EOL><INDENT>filename = module<EOL><DEDENT><DEDENT>registry = globals.setdefault(\"<STR_LIT>\", {})<EOL>warn_explicit(message, category, filename, lineno, module, registry,<EOL>globals)<EOL>", "docstring": "Issue a warning, or maybe ignore it or raise an exception.", "id": "f17324:m10"}
{"signature": "def get_templates(self):", "body": "base = '<STR_LIT>'<EOL>base = self._get_and_update_setting('<STR_LIT>', base)<EOL>base = \"<STR_LIT>\" %base<EOL>return self._get(base)<EOL>", "docstring": "list templates in the builder bundle library. If a name is provided,\n       look it up", "id": "f9972:m3"}
{"signature": "def _get_neighbors(self):", "body": "return self.__neighbors<EOL>", "docstring": "Getter method for neighbors, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors (container)\n\nYANG Description: This container describes IS neighbors.", "id": "f22633:c0:m5"}
{"signature": "def sender_failed(self, sender_link, error):", "body": "LOG.debug(\"<STR_LIT>\", error)<EOL>sender_link.close()<EOL>", "docstring": "Protocol error occurred.", "id": "f4874:c1:m5"}
{"signature": "def get_items(self, query_params=None):", "body": "return self.fetch_json(<EOL>uri_path=self.base_uri + '<STR_LIT>',<EOL>query_params=query_params or {}<EOL>)<EOL>", "docstring": "Get all the items for this label. Returns a list of dictionaries.\nEach dictionary has the values for an item.", "id": "f12589:c0:m2"}
{"signature": "def loss(self, layers, outputs):", "body": "return <NUM_LIT:0.><EOL>", "docstring": "Compute a scalar term to add to the loss function for a model.\n\n        Parameters\n        ----------\n        layers : list of :class:`theanets.layers.Layer`\n            A list of the layers in the model being regularized.\n        outputs : dict of Theano expressions\n            A dictionary mapping string expression names to their corresponding\n            Theano expressions in the computation graph. This dictionary\n            contains the fully-scoped name of every layer output in the graph.", "id": "f7169:c0:m3"}
{"signature": "def _pivot_col(T, tol=<NUM_LIT>, bland=False):", "body": "ma = np.ma.masked_where(T[-<NUM_LIT:1>, :-<NUM_LIT:1>] >= -tol, T[-<NUM_LIT:1>, :-<NUM_LIT:1>], copy=False)<EOL>if ma.count() == <NUM_LIT:0>:<EOL><INDENT>return False, np.nan<EOL><DEDENT>if bland:<EOL><INDENT>return True, np.where(ma.mask == False)[<NUM_LIT:0>][<NUM_LIT:0>]<EOL><DEDENT>return True, np.ma.where(ma == ma.min())[<NUM_LIT:0>][<NUM_LIT:0>]<EOL>", "docstring": "Given a linear programming simplex tableau, determine the column\nof the variable to enter the basis.\n\nParameters\n----------\nT : 2D ndarray\n    The simplex tableau.\ntol : float\n    Elements in the objective row larger than -tol will not be considered\n    for pivoting.  Nominally this value is zero, but numerical issues\n    cause a tolerance about zero to be necessary.\nbland : bool\n    If True, use Bland's rule for selection of the column (select the\n    first column with a negative coefficient in the objective row,\n    regardless of magnitude).\n\nReturns\n-------\nstatus: bool\n    True if a suitable pivot column was found, otherwise False.\n    A return of False indicates that the linear programming simplex\n    algorithm is complete.\ncol: int\n    The index of the column of the pivot element.\n    If status is False, col will be returned as nan.", "id": "f19417:m2"}
{"signature": "def __init__(self, file, ignore_perms=False, **kwargs):", "body": "super(Config, self).__init__(**kwargs)<EOL>if not os.path.lexists(file):<EOL><INDENT>raise ConfigFileNotFoundError(file)<EOL><DEDENT>if not ignore_perms and ((not os.getuid() and not only_root_write(file)) or oth_w_perm(file)):<EOL><INDENT>file = os.path.abspath(file)<EOL>raise SecurityException(<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>'.format(<EOL>file=file, user=get_file_owner(file),<EOL>group=get_file_group(file), perms=os.stat(file).st_mode & <NUM_LIT>,<EOL>msg='<STR_LIT>' if os.getuid()<EOL>else '<STR_LIT>'))<EOL><DEDENT>self.file = file<EOL>self.read()<EOL>", "docstring": "Set the config file and validate file permissions\n\n        :param str file: path to file\n        :param kwargs: default values in dict", "id": "f2811:c0:m0"}
{"signature": "def autorange(t, sig, gwin=<NUM_LIT:7>, swin=None, win=<NUM_LIT:30>,<EOL>on_mult=(<NUM_LIT>, <NUM_LIT:1.>), off_mult=(<NUM_LIT:1.>, <NUM_LIT>),<EOL>nbin=<NUM_LIT:10>, transform='<STR_LIT>', thresh=None):", "body": "failed = []<EOL>if swin is not None:<EOL><INDENT>sigs = fastsmooth(sig, swin)<EOL><DEDENT>else:<EOL><INDENT>sigs = sig<EOL><DEDENT>if transform == '<STR_LIT>':<EOL><INDENT>tsigs = np.log10(sigs)<EOL><DEDENT>else:<EOL><INDENT>tsigs = sigs<EOL><DEDENT>if thresh is None:<EOL><INDENT>bins = <NUM_LIT:50><EOL>kde_x = np.linspace(tsigs.min(), tsigs.max(), bins)<EOL>kde = gaussian_kde(tsigs)<EOL>yd = kde.pdf(kde_x)<EOL>mins = findmins(kde_x, yd)  <EOL>if len(mins) > <NUM_LIT:0>:<EOL><INDENT>bkg = tsigs < (mins[<NUM_LIT:0>])  <EOL><DEDENT>else:<EOL><INDENT>bkg = np.ones(tsigs.size, dtype=bool)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>bkg = tsigs < thresh<EOL><DEDENT>fbkg = bkg<EOL>fsig = ~bkg<EOL>zeros = bool_2_indices(fsig)<EOL>g = abs(fastgrad(sigs, gwin))  <EOL>if zeros is not None:<EOL><INDENT>zeros = zeros.flatten()<EOL>for z in zeros:  <EOL><INDENT>if z - win < <NUM_LIT:0>:<EOL><INDENT>lo = gwin // <NUM_LIT:2><EOL>hi = int(z + win)<EOL><DEDENT>elif z + win > (len(sig) - gwin // <NUM_LIT:2>):<EOL><INDENT>lo = int(z - win)<EOL>hi = len(sig) - gwin // <NUM_LIT:2><EOL><DEDENT>else:<EOL><INDENT>lo = int(z - win)<EOL>hi = int(z + win)<EOL><DEDENT>xs = t[lo:hi]<EOL>ys = g[lo:hi]<EOL>mid = (hi + lo) // <NUM_LIT:2><EOL>tp = sigs[mid + <NUM_LIT:3>] > sigs[mid - <NUM_LIT:3>]  <EOL>c = t[z]  <EOL>width = (t[<NUM_LIT:1>] - t[<NUM_LIT:0>]) * <NUM_LIT:2><EOL>try:<EOL><INDENT>pg, _ = curve_fit(gauss, xs, ys,<EOL>p0=(np.nanmax(ys),<EOL>c,<EOL>width),<EOL>sigma=(xs - c)**<NUM_LIT:2> + <NUM_LIT>)<EOL>fwhm = abs(<NUM_LIT:2> * pg[-<NUM_LIT:1>] * np.sqrt(<NUM_LIT:2> * np.log(<NUM_LIT:2>)))<EOL>if tp:<EOL><INDENT>lim = np.array([-fwhm, fwhm]) * on_mult + pg[<NUM_LIT:1>]<EOL><DEDENT>else:<EOL><INDENT>lim = np.array([-fwhm, fwhm]) * off_mult + pg[<NUM_LIT:1>]<EOL><DEDENT>fbkg[(t > lim[<NUM_LIT:0>]) & (t < lim[<NUM_LIT:1>])] = False<EOL>fsig[(t > lim[<NUM_LIT:0>]) & (t < lim[<NUM_LIT:1>])] = False<EOL><DEDENT>except RuntimeError:<EOL><INDENT>failed.append([c, tp])<EOL>pass<EOL><DEDENT><DEDENT><DEDENT>ftrn = ~fbkg & ~fsig<EOL>if len(failed) > <NUM_LIT:0>:<EOL><INDENT>trns = t[bool_2_indices(ftrn)]<EOL>tr_mean = (trns[:, <NUM_LIT:1>] - trns[:, <NUM_LIT:0>]).mean() / <NUM_LIT:2><EOL>for f, tp in failed:<EOL><INDENT>if tp:<EOL><INDENT>ind = (t >= f - tr_mean *<EOL>on_mult[<NUM_LIT:0>]) & (t <= f + tr_mean * on_mult[<NUM_LIT:0>])<EOL><DEDENT>else:<EOL><INDENT>ind = (t >= f - tr_mean *<EOL>off_mult[<NUM_LIT:0>]) & (t <= f + tr_mean * off_mult[<NUM_LIT:0>])<EOL><DEDENT>fsig[ind] = False<EOL>fbkg[ind] = False<EOL>ftrn[ind] = False<EOL><DEDENT><DEDENT>return fbkg, fsig, ftrn, [f[<NUM_LIT:0>] for f in failed]<EOL>", "docstring": "Automatically separates signal and background in an on/off data stream.\n\n**Step 1: Thresholding.**\nThe background signal is determined using a gaussian kernel density\nestimator (kde) of all the data. Under normal circumstances, this\nkde should find two distinct data distributions, corresponding to\n'signal' and 'background'. The minima between these two distributions\nis taken as a rough threshold to identify signal and background\nregions. Any point where the trace crosses this thrshold is identified\nas a 'transition'.\n\n**Step 2: Transition Removal.**\nThe width of the transition regions between signal and background are\nthen determined, and the transitions are excluded from analysis. The\nwidth of the transitions is determined by fitting a gaussian to the\nsmoothed first derivative of the analyte trace, and determining its\nwidth at a point where the gaussian intensity is at at `conf` time the\ngaussian maximum. These gaussians are fit to subsets of the data\ncentered around the transitions regions determined in Step 1, +/- `win`\ndata points. The peak is further isolated by finding the minima and\nmaxima of a second derivative within this window, and the gaussian is\nfit to the isolated peak.\n\nParameters\n----------\nt : array-like\n    Independent variable (usually time).\nsig : array-like\n    Dependent signal, with distinctive 'on' and 'off' regions.\ngwin : int\n    The window used for calculating first derivative.\n    Defaults to 7.\nswin : int\n    The window used for signal smoothing. If None, ``gwin // 2``.\nwin : int\n    The width (c +/- win) of the transition data subsets.\n    Defaults to 20.\non_mult and off_mult : tuple, len=2\n    Control the width of the excluded transition regions, which is defined\n    relative to the peak full-width-half-maximum (FWHM) of the transition\n    gradient. The region n * FHWM below the transition, and m * FWHM above\n    the tranision will be excluded, where (n, m) are specified in `on_mult`\n    and `off_mult`.\n    `on_mult` and `off_mult` apply to the off-on and on-off transitions,\n    respectively.\n    Defaults to (1.5, 1) and (1, 1.5).\ntransform : str\n    How to transform the data. Default is 'log'.\n\nReturns\n-------\nfbkg, fsig, ftrn, failed : tuple\n    where fbkg, fsig and ftrn are boolean arrays the same length as sig,\n    that are True where sig is background, signal and transition, respecively.\n    failed contains a list of transition positions where gaussian fitting\n    has failed.", "id": "f2440:m0"}
{"signature": "def parentonly(func):", "body": "def wrapper(*args, **kwargs):<EOL><INDENT>pid = os.getpid()<EOL>if pid == parent_pid:<EOL><INDENT>return func(*args, **kwargs)<EOL><DEDENT><DEDENT>wrapper.__name__ = func.__name__<EOL>return wrapper<EOL>", "docstring": "Only execute the decorated function in the parent thread.", "id": "f11641:m0"}
{"signature": "def list_usage(<EOL>self, resource_group_name, virtual_network_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_usage.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_network_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualNetworkUsagePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualNetworkUsagePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists usage stats.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_name: The name of the virtual network.\n        :type virtual_network_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualNetworkUsage\n        :rtype:\n         ~azure.mgmt.network.v2018_10_01.models.VirtualNetworkUsagePaged[~azure.mgmt.network.v2018_10_01.models.VirtualNetworkUsage]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30298:c0:m11"}
{"signature": "@contextlib.contextmanager<EOL><INDENT>def _name_scope(self, name=None, values=None):<DEDENT>", "body": "with tf.compat.v1.name_scope(self.name):<EOL><INDENT>values = [] if values is None else values<EOL>with tf.compat.v1.name_scope(name, values=values) as scope:<EOL><INDENT>yield scope<EOL><DEDENT><DEDENT>", "docstring": "Helper function to standardize op scope.", "id": "f15786:c0:m6"}
{"signature": "def setencoding():", "body": "encoding = \"<STR_LIT:ascii>\" <EOL>if <NUM_LIT:0>:<EOL><INDENT>import locale<EOL>loc = locale.getdefaultlocale()<EOL>if loc[<NUM_LIT:1>]:<EOL><INDENT>encoding = loc[<NUM_LIT:1>]<EOL><DEDENT><DEDENT>if <NUM_LIT:0>:<EOL><INDENT>encoding = \"<STR_LIT>\"<EOL><DEDENT>if encoding != \"<STR_LIT:ascii>\":<EOL><INDENT>sys.setdefaultencoding(encoding)<EOL><DEDENT>", "docstring": "Set the string encoding used by the Unicode implementation.  The\n    default is 'ascii', but if you're willing to experiment, you can\n    change this.", "id": "f21260:m15"}
{"signature": "def _get_topologies(self):", "body": "return self.__topologies<EOL>", "docstring": "Getter method for topologies, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/multi_topology/topologies (container)\n\nYANG Description: This container describes IS topologies.", "id": "f22894:c0:m5"}
{"signature": "def __init__(self, *args, **kwords):", "body": "N = len(args)<EOL>if N == <NUM_LIT:2>:  <EOL><INDENT>self._num, self._den = normalize(*args)<EOL>self._update(N)<EOL>self.inputs = <NUM_LIT:1><EOL>if len(self.num.shape) > <NUM_LIT:1>:<EOL><INDENT>self.outputs = self.num.shape[<NUM_LIT:0>]<EOL><DEDENT>else:<EOL><INDENT>self.outputs = <NUM_LIT:1><EOL><DEDENT><DEDENT>elif N == <NUM_LIT:3>:      <EOL><INDENT>self._zeros, self._poles, self._gain = args<EOL>self._update(N)<EOL>self.zeros = numpy.asarray(self.zeros)<EOL>self.poles = numpy.asarray(self.poles)<EOL>self.inputs = <NUM_LIT:1><EOL>if len(self.zeros.shape) > <NUM_LIT:1>:<EOL><INDENT>self.outputs = self.zeros.shape[<NUM_LIT:0>]<EOL><DEDENT>else:<EOL><INDENT>self.outputs = <NUM_LIT:1><EOL><DEDENT><DEDENT>elif N == <NUM_LIT:4>:       <EOL><INDENT>self._A, self._B, self._C, self._D = abcd_normalize(*args)<EOL>self._update(N)<EOL>self.inputs = self.B.shape[-<NUM_LIT:1>]<EOL>self.outputs = self.C.shape[<NUM_LIT:0>]<EOL><DEDENT>else:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>", "docstring": "Initialize the LTI system using either:\n\n    - (numerator, denominator)\n    - (zeros, poles, gain)\n    - (A, B, C, D) : state-space.", "id": "f19246:c0:m0"}
{"signature": "def load_panel_app(adapter, panel_id=None, institute='<STR_LIT>'):", "body": "base_url = '<STR_LIT>'<EOL>hgnc_map = adapter.genes_by_alias()<EOL>if panel_id:<EOL><INDENT>panel_ids = [panel_id]<EOL><DEDENT>if not panel_id:<EOL><INDENT>LOG.info(\"<STR_LIT>\")<EOL>data = get_request(base_url.format('<STR_LIT>'))<EOL>json_lines = json.loads(data)<EOL>panel_ids = [panel_info['<STR_LIT>'] for panel_info in json_lines['<STR_LIT:result>']]<EOL><DEDENT>for panel_id in panel_ids:<EOL><INDENT>panel_data = get_request(base_url.format('<STR_LIT>') + panel_id)<EOL>parsed_panel = parse_panel_app_panel(<EOL>panel_info = json.loads(panel_data)['<STR_LIT:result>'], <EOL>hgnc_map=hgnc_map,<EOL>institute=institute<EOL>)<EOL>parsed_panel['<STR_LIT>'] = panel_id<EOL>if len(parsed_panel['<STR_LIT>']) == <NUM_LIT:0>:<EOL><INDENT>LOG.warning(\"<STR_LIT>\".format(parsed_panel['<STR_LIT>']))<EOL>continue<EOL><DEDENT>try:<EOL><INDENT>adapter.load_panel(parsed_panel=parsed_panel)<EOL><DEDENT>except Exception as err:<EOL><INDENT>raise err<EOL><DEDENT><DEDENT>", "docstring": "Load PanelApp panels into scout database\n\n    If no panel_id load all PanelApp panels \n\n    Args:\n        adapter(scout.adapter.MongoAdapter)\n        panel_id(str): The panel app panel id", "id": "f13807:m1"}
{"signature": "def lsqr(A, b, damp=<NUM_LIT:0.0>, atol=<NUM_LIT>, btol=<NUM_LIT>, conlim=<NUM_LIT>,<EOL>iter_lim=None, show=False, calc_var=False):", "body": "A = aslinearoperator(A)<EOL>if len(b.shape) > <NUM_LIT:1>:<EOL><INDENT>b = b.squeeze()<EOL><DEDENT>m, n = A.shape<EOL>if iter_lim is None:<EOL><INDENT>iter_lim = <NUM_LIT:2> * n<EOL><DEDENT>var = np.zeros(n)<EOL>msg = ('<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>')<EOL>if show:<EOL><INDENT>print('<STR_LIT:U+0020>')<EOL>print('<STR_LIT>')<EOL>str1 = '<STR_LIT>' % (m, n)<EOL>str2 = '<STR_LIT>' % (damp, calc_var)<EOL>str3 = '<STR_LIT>' % (atol, conlim)<EOL>str4 = '<STR_LIT>' % (btol, iter_lim)<EOL>print(str1)<EOL>print(str2)<EOL>print(str3)<EOL>print(str4)<EOL><DEDENT>itn = <NUM_LIT:0><EOL>istop = <NUM_LIT:0><EOL>nstop = <NUM_LIT:0><EOL>ctol = <NUM_LIT:0><EOL>if conlim > <NUM_LIT:0>:<EOL><INDENT>ctol = <NUM_LIT:1>/conlim<EOL><DEDENT>anorm = <NUM_LIT:0><EOL>acond = <NUM_LIT:0><EOL>dampsq = damp**<NUM_LIT:2><EOL>ddnorm = <NUM_LIT:0><EOL>res2 = <NUM_LIT:0><EOL>xnorm = <NUM_LIT:0><EOL>xxnorm = <NUM_LIT:0><EOL>z = <NUM_LIT:0><EOL>cs2 = -<NUM_LIT:1><EOL>sn2 = <NUM_LIT:0><EOL>\"\"\"<STR_LIT>\"\"\"<EOL>__xm = np.zeros(m)  <EOL>__xn = np.zeros(n)  <EOL>v = np.zeros(n)<EOL>u = b<EOL>x = np.zeros(n)<EOL>alfa = <NUM_LIT:0><EOL>beta = np.linalg.norm(u)<EOL>w = np.zeros(n)<EOL>if beta > <NUM_LIT:0>:<EOL><INDENT>u = (<NUM_LIT:1>/beta) * u<EOL>v = A.rmatvec(u)<EOL>alfa = np.linalg.norm(v)<EOL><DEDENT>if alfa > <NUM_LIT:0>:<EOL><INDENT>v = (<NUM_LIT:1>/alfa) * v<EOL>w = v.copy()<EOL><DEDENT>rhobar = alfa<EOL>phibar = beta<EOL>bnorm = beta<EOL>rnorm = beta<EOL>r1norm = rnorm<EOL>r2norm = rnorm<EOL>arnorm = alfa * beta<EOL>if arnorm == <NUM_LIT:0>:<EOL><INDENT>print(msg[<NUM_LIT:0>])<EOL>return x, istop, itn, r1norm, r2norm, anorm, acond, arnorm, xnorm, var<EOL><DEDENT>head1 = '<STR_LIT>'<EOL>head2 = '<STR_LIT>'<EOL>if show:<EOL><INDENT>print('<STR_LIT:U+0020>')<EOL>print(head1, head2)<EOL>test1 = <NUM_LIT:1><EOL>test2 = alfa / beta<EOL>str1 = '<STR_LIT>' % (itn, x[<NUM_LIT:0>])<EOL>str2 = '<STR_LIT>' % (r1norm, r2norm)<EOL>str3 = '<STR_LIT>' % (test1, test2)<EOL>print(str1, str2, str3)<EOL><DEDENT>while itn < iter_lim:<EOL><INDENT>itn = itn + <NUM_LIT:1><EOL>\"\"\"<STR_LIT>\"\"\"<EOL>u = A.matvec(v) - alfa * u<EOL>beta = np.linalg.norm(u)<EOL>if beta > <NUM_LIT:0>:<EOL><INDENT>u = (<NUM_LIT:1>/beta) * u<EOL>anorm = sqrt(anorm**<NUM_LIT:2> + alfa**<NUM_LIT:2> + beta**<NUM_LIT:2> + damp**<NUM_LIT:2>)<EOL>v = A.rmatvec(u) - beta * v<EOL>alfa = np.linalg.norm(v)<EOL>if alfa > <NUM_LIT:0>:<EOL><INDENT>v = (<NUM_LIT:1> / alfa) * v<EOL><DEDENT><DEDENT>rhobar1 = sqrt(rhobar**<NUM_LIT:2> + damp**<NUM_LIT:2>)<EOL>cs1 = rhobar / rhobar1<EOL>sn1 = damp / rhobar1<EOL>psi = sn1 * phibar<EOL>phibar = cs1 * phibar<EOL>cs, sn, rho = _sym_ortho(rhobar1, beta)<EOL>theta = sn * alfa<EOL>rhobar = -cs * alfa<EOL>phi = cs * phibar<EOL>phibar = sn * phibar<EOL>tau = sn * phi<EOL>t1 = phi / rho<EOL>t2 = -theta / rho<EOL>dk = (<NUM_LIT:1> / rho) * w<EOL>x = x + t1 * w<EOL>w = v + t2 * w<EOL>ddnorm = ddnorm + np.linalg.norm(dk)**<NUM_LIT:2><EOL>if calc_var:<EOL><INDENT>var = var + dk**<NUM_LIT:2><EOL><DEDENT>delta = sn2 * rho<EOL>gambar = -cs2 * rho<EOL>rhs = phi - delta * z<EOL>zbar = rhs / gambar<EOL>xnorm = sqrt(xxnorm + zbar**<NUM_LIT:2>)<EOL>gamma = sqrt(gambar**<NUM_LIT:2> + theta**<NUM_LIT:2>)<EOL>cs2 = gambar / gamma<EOL>sn2 = theta / gamma<EOL>z = rhs / gamma<EOL>xxnorm = xxnorm + z**<NUM_LIT:2><EOL>acond = anorm * sqrt(ddnorm)<EOL>res1 = phibar**<NUM_LIT:2><EOL>res2 = res2 + psi**<NUM_LIT:2><EOL>rnorm = sqrt(res1 + res2)<EOL>arnorm = alfa * abs(tau)<EOL>r1sq = rnorm**<NUM_LIT:2> - dampsq * xxnorm<EOL>r1norm = sqrt(abs(r1sq))<EOL>if r1sq < <NUM_LIT:0>:<EOL><INDENT>r1norm = -r1norm<EOL><DEDENT>r2norm = rnorm<EOL>test1 = rnorm / bnorm<EOL>test2 = arnorm / (anorm * rnorm + eps)<EOL>test3 = <NUM_LIT:1> / (acond + eps)<EOL>t1 = test1 / (<NUM_LIT:1> + anorm * xnorm / bnorm)<EOL>rtol = btol + atol * anorm * xnorm / bnorm<EOL>if itn >= iter_lim:<EOL><INDENT>istop = <NUM_LIT:7><EOL><DEDENT>if <NUM_LIT:1> + test3 <= <NUM_LIT:1>:<EOL><INDENT>istop = <NUM_LIT:6><EOL><DEDENT>if <NUM_LIT:1> + test2 <= <NUM_LIT:1>:<EOL><INDENT>istop = <NUM_LIT:5><EOL><DEDENT>if <NUM_LIT:1> + t1 <= <NUM_LIT:1>:<EOL><INDENT>istop = <NUM_LIT:4><EOL><DEDENT>if test3 <= ctol:<EOL><INDENT>istop = <NUM_LIT:3><EOL><DEDENT>if test2 <= atol:<EOL><INDENT>istop = <NUM_LIT:2><EOL><DEDENT>if test1 <= rtol:<EOL><INDENT>istop = <NUM_LIT:1><EOL><DEDENT>prnt = False<EOL>if n <= <NUM_LIT>:<EOL><INDENT>prnt = True<EOL><DEDENT>if itn <= <NUM_LIT:10>:<EOL><INDENT>prnt = True<EOL><DEDENT>if itn >= iter_lim-<NUM_LIT:10>:<EOL><INDENT>prnt = True<EOL><DEDENT>if test3 <= <NUM_LIT:2>*ctol:<EOL><INDENT>prnt = True<EOL><DEDENT>if test2 <= <NUM_LIT:10>*atol:<EOL><INDENT>prnt = True<EOL><DEDENT>if test1 <= <NUM_LIT:10>*rtol:<EOL><INDENT>prnt = True<EOL><DEDENT>if istop != <NUM_LIT:0>:<EOL><INDENT>prnt = True<EOL><DEDENT>if prnt:<EOL><INDENT>if show:<EOL><INDENT>str1 = '<STR_LIT>' % (itn, x[<NUM_LIT:0>])<EOL>str2 = '<STR_LIT>' % (r1norm, r2norm)<EOL>str3 = '<STR_LIT>' % (test1, test2)<EOL>str4 = '<STR_LIT>' % (anorm, acond)<EOL>print(str1, str2, str3, str4)<EOL><DEDENT><DEDENT>if istop != <NUM_LIT:0>:<EOL><INDENT>break<EOL><DEDENT><DEDENT>if show:<EOL><INDENT>print('<STR_LIT:U+0020>')<EOL>print('<STR_LIT>')<EOL>print(msg[istop])<EOL>print('<STR_LIT:U+0020>')<EOL>str1 = '<STR_LIT>' % (istop, r1norm)<EOL>str2 = '<STR_LIT>' % (anorm, arnorm)<EOL>str3 = '<STR_LIT>' % (itn, r2norm)<EOL>str4 = '<STR_LIT>' % (acond, xnorm)<EOL>print(str1 + '<STR_LIT:U+0020>' + str2)<EOL>print(str3 + '<STR_LIT:U+0020>' + str4)<EOL>print('<STR_LIT:U+0020>')<EOL><DEDENT>return x, istop, itn, r1norm, r2norm, anorm, acond, arnorm, xnorm, var<EOL>", "docstring": "Find the least-squares solution to a large, sparse, linear system\n    of equations.\n\n    The function solves ``Ax = b``  or  ``min ||b - Ax||^2`` or\n    ``min ||Ax - b||^2 + d^2 ||x||^2``.\n\n    The matrix A may be square or rectangular (over-determined or\n    under-determined), and may have any rank.\n\n    ::\n\n      1. Unsymmetric equations --    solve  A*x = b\n\n      2. Linear least squares  --    solve  A*x = b\n                                     in the least-squares sense\n\n      3. Damped least squares  --    solve  (   A    )*x = ( b )\n                                            ( damp*I )     ( 0 )\n                                     in the least-squares sense\n\n    Parameters\n    ----------\n    A : {sparse matrix, ndarray, LinearOperator}\n        Representation of an m-by-n matrix.  It is required that\n        the linear operator can produce ``Ax`` and ``A^T x``.\n    b : (m,) ndarray\n        Right-hand side vector ``b``.\n    damp : float\n        Damping coefficient.\n    atol, btol : float\n        Stopping tolerances. If both are 1.0e-9 (say), the final\n        residual norm should be accurate to about 9 digits.  (The\n        final x will usually have fewer correct digits, depending on\n        cond(A) and the size of damp.)\n    conlim : float\n        Another stopping tolerance.  lsqr terminates if an estimate of\n        ``cond(A)`` exceeds `conlim`.  For compatible systems ``Ax =\n        b``, `conlim` could be as large as 1.0e+12 (say).  For\n        least-squares problems, conlim should be less than 1.0e+8.\n        Maximum precision can be obtained by setting ``atol = btol =\n        conlim = zero``, but the number of iterations may then be\n        excessive.\n    iter_lim : int\n        Explicit limitation on number of iterations (for safety).\n    show : bool\n        Display an iteration log.\n    calc_var : bool\n        Whether to estimate diagonals of ``(A'A + damp^2*I)^{-1}``.\n\n    Returns\n    -------\n    x : ndarray of float\n        The final solution.\n    istop : int\n        Gives the reason for termination.\n        1 means x is an approximate solution to Ax = b.\n        2 means x approximately solves the least-squares problem.\n    itn : int\n        Iteration number upon termination.\n    r1norm : float\n        ``norm(r)``, where ``r = b - Ax``.\n    r2norm : float\n        ``sqrt( norm(r)^2  +  damp^2 * norm(x)^2 )``.  Equal to `r1norm` if\n        ``damp == 0``.\n    anorm : float\n        Estimate of Frobenius norm of ``Abar = [[A]; [damp*I]]``.\n    acond : float\n        Estimate of ``cond(Abar)``.\n    arnorm : float\n        Estimate of ``norm(A'*r - damp^2*x)``.\n    xnorm : float\n        ``norm(x)``\n    var : ndarray of float\n        If ``calc_var`` is True, estimates all diagonals of\n        ``(A'A)^{-1}`` (if ``damp == 0``) or more generally ``(A'A +\n        damp^2*I)^{-1}``.  This is well defined if A has full column\n        rank or ``damp > 0``.  (Not sure what var means if ``rank(A)\n        < n`` and ``damp = 0.``)\n\n    Notes\n    -----\n    LSQR uses an iterative method to approximate the solution.  The\n    number of iterations required to reach a certain accuracy depends\n    strongly on the scaling of the problem.  Poor scaling of the rows\n    or columns of A should therefore be avoided where possible.\n\n    For example, in problem 1 the solution is unaltered by\n    row-scaling.  If a row of A is very small or large compared to\n    the other rows of A, the corresponding row of ( A  b ) should be\n    scaled up or down.\n\n    In problems 1 and 2, the solution x is easily recovered\n    following column-scaling.  Unless better information is known,\n    the nonzero columns of A should be scaled so that they all have\n    the same Euclidean norm (e.g., 1.0).\n\n    In problem 3, there is no freedom to re-scale if damp is\n    nonzero.  However, the value of damp should be assigned only\n    after attention has been paid to the scaling of A.\n\n    The parameter damp is intended to help regularize\n    ill-conditioned systems, by preventing the true solution from\n    being very large.  Another aid to regularization is provided by\n    the parameter acond, which may be used to terminate iterations\n    before the computed solution becomes very large.\n\n    If some initial estimate ``x0`` is known and if ``damp == 0``,\n    one could proceed as follows:\n\n      1. Compute a residual vector ``r0 = b - A*x0``.\n      2. Use LSQR to solve the system  ``A*dx = r0``.\n      3. Add the correction dx to obtain a final solution ``x = x0 + dx``.\n\n    This requires that ``x0`` be available before and after the call\n    to LSQR.  To judge the benefits, suppose LSQR takes k1 iterations\n    to solve A*x = b and k2 iterations to solve A*dx = r0.\n    If x0 is \"good\", norm(r0) will be smaller than norm(b).\n    If the same stopping tolerances atol and btol are used for each\n    system, k1 and k2 will be similar, but the final solution x0 + dx\n    should be more accurate.  The only way to reduce the total work\n    is to use a larger stopping tolerance for the second system.\n    If some value btol is suitable for A*x = b, the larger value\n    btol*norm(b)/norm(r0)  should be suitable for A*dx = r0.\n\n    Preconditioning is another way to reduce the number of iterations.\n    If it is possible to solve a related system ``M*x = b``\n    efficiently, where M approximates A in some helpful way (e.g. M -\n    A has low rank or its elements are small relative to those of A),\n    LSQR may converge more rapidly on the system ``A*M(inverse)*z =\n    b``, after which x can be recovered by solving M*x = z.\n\n    If A is symmetric, LSQR should not be used!\n\n    Alternatives are the symmetric conjugate-gradient method (cg)\n    and/or SYMMLQ.  SYMMLQ is an implementation of symmetric cg that\n    applies to any symmetric A and will converge more rapidly than\n    LSQR.  If A is positive definite, there are other implementations\n    of symmetric cg that require slightly less work per iteration than\n    SYMMLQ (but will take the same number of iterations).\n\n    References\n    ----------\n    .. [1] C. C. Paige and M. A. Saunders (1982a).\n           \"LSQR: An algorithm for sparse linear equations and\n           sparse least squares\", ACM TOMS 8(1), 43-71.\n    .. [2] C. C. Paige and M. A. Saunders (1982b).\n           \"Algorithm 583.  LSQR: Sparse linear equations and least\n           squares problems\", ACM TOMS 8(2), 195-209.\n    .. [3] M. A. Saunders (1995).  \"Solution of sparse rectangular\n           systems using LSQR and CRAIG\", BIT 35, 588-604.", "id": "f19546:m1"}
{"signature": "def _create_msg(self, to, subject, msgHtml, msgPlain, attachments=None):", "body": "sender = self.sender<EOL>if attachments and isinstance(attachments, str):<EOL><INDENT>attachments = [attachments]<EOL><DEDENT>else:<EOL><INDENT>attachments = list(attachments or [])<EOL><DEDENT>msg = MIMEMultipart('<STR_LIT>')<EOL>msg['<STR_LIT>'] = subject<EOL>msg['<STR_LIT>'] = sender<EOL>msg['<STR_LIT>'] = to<EOL>msg.attach(MIMEText(msgPlain, '<STR_LIT>'))<EOL>msg.attach(MIMEText(msgHtml, '<STR_LIT:html>'))<EOL>for path in attachments:<EOL><INDENT>_attachment = self._prep_attachment(path)<EOL>msg.attach(_attachment)<EOL><DEDENT>raw = base64.urlsafe_b64encode(msg.as_bytes()).decode()<EOL>body = {'<STR_LIT>': raw}<EOL>return body<EOL>", "docstring": "attachments should be a list of paths", "id": "f1630:c0:m5"}
{"signature": "def fit(self, Z):", "body": "self.fit_transform(Z)<EOL>return self<EOL>", "docstring": "Fit LSI model on training data X.\n\n        Parameters\n        ----------\n        X : {array-like, sparse matrix}, shape (n_samples, n_features)\n            Training data.\n\n        Returns\n        -------\n        self : object\n            Returns the transformer object.", "id": "f16768:c0:m1"}
{"signature": "def get_prices(self, date: str, currency: str) -> List[PriceModel]:", "body": "from .repositories import PriceRepository<EOL>session = self.session<EOL>repo = PriceRepository(session)<EOL>query = repo.query<EOL>if date:<EOL><INDENT>query = query.filter(dal.Price.date == date)<EOL><DEDENT>if currency:<EOL><INDENT>query = query.filter(dal.Price.currency == currency)<EOL><DEDENT>query = query.order_by(dal.Price.namespace, dal.Price.symbol)<EOL>price_entities = query.all()<EOL>mapper = mappers.PriceMapper()<EOL>result = []<EOL>for entity in price_entities:<EOL><INDENT>model = mapper.map_entity(entity)<EOL>result.append(model)<EOL><DEDENT>return result<EOL>", "docstring": "Fetches all the prices for the given arguments", "id": "f11337:c0:m8"}
{"signature": "def Walk(root='<STR_LIT:.>', recurse=True, pattern='<STR_LIT:*>'):", "body": "for path, subdirs, files in os.walk(root):<EOL><INDENT>for name in files:<EOL><INDENT>if fnmatch.fnmatch(name, pattern):<EOL><INDENT>yield os.path.join(path, name)<EOL><DEDENT><DEDENT>if not recurse:<EOL><INDENT>break<EOL><DEDENT><DEDENT>", "docstring": "Generator for walking a directory tree.\nStarts at specified root folder, returning files that match our pattern. \nOptionally will also recurse through sub-folders.\n\nParameters\n----------\nroot : string (default is *'.'*)\n    Path for the root folder to look in.\nrecurse : bool (default is *True*)\n    If *True*, will also look in the subfolders.\npattern : string (default is :emphasis:`'*'`, which means all the files are concerned)\n    The pattern to look for in the files' name.\n\nReturns\n-------\ngenerator\n    **Walk** yields a generator from the matching files paths.", "id": "f18908:m7"}
{"signature": "def _set_value(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:value>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__value = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for value, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/lan_adjacency_sid/sid/state/value (uint32)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_value is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_value() directly.\n\nYANG Description: LAN Adjacency-SID value.", "id": "f22868:c1:m3"}
{"signature": "def _set_type(self, v, load=False):", "body": "parent = getattr(self, \"<STR_LIT>\", None)<EOL>if parent is not None and load is False:<EOL><INDENT>raise AttributeError(<EOL>\"<STR_LIT>\" + \"<STR_LIT>\"<EOL>)<EOL><DEDENT>if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:type>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>is_keyval=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/type (leafref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_type() directly.\n\n    YANG Description: A reference for the LSA type being described within\nthe LSDB", "id": "f22978:c0:m3"}
{"signature": "def connection_remote_closed(self, connection, pn_condition):", "body": "LOG.debug(\"<STR_LIT>\", pn_condition)<EOL>connection.close()<EOL>", "docstring": "Peer has closed its end of the connection.", "id": "f4876:c0:m1"}
{"signature": "@meta.hook(BasicParser, \"<STR_LIT>\")<EOL>def dump_nodes(self):", "body": "print(\"<STR_LIT>\")<EOL>try:<EOL><INDENT>print(\"<STR_LIT>\")<EOL>for k, v in self.id_cache.items():<EOL><INDENT>print(\"<STR_LIT>\" % (k, v))<EOL><DEDENT>print(\"<STR_LIT>\")<EOL>for k, v in self.tag_cache.items():<EOL><INDENT>print(\"<STR_LIT>\" % (k, v))<EOL><DEDENT>print(\"<STR_LIT>\")<EOL>for k, v in self.rule_nodes.items():<EOL><INDENT>txt = \"<STR_LIT>\" % (k, id(v))<EOL>if k in self.tag_cache:<EOL><INDENT>tag = self.tag_cache[k]<EOL>txt += \"<STR_LIT>\" % tag<EOL>k = \"<STR_LIT>\" % (tag._begin, tag._end)<EOL>if k in self._stream.value_cache:<EOL><INDENT>txt += \"<STR_LIT>\" % self._stream.value_cache[k]<EOL><DEDENT><DEDENT>print(txt)<EOL><DEDENT><DEDENT>except Exception as err:<EOL><INDENT>print(\"<STR_LIT>\" % err)<EOL><DEDENT>import sys<EOL>sys.stdout.flush()<EOL>return True<EOL>", "docstring": "Dump tag,rule,id and value cache. For debug.\n\nexample::\n\n    R = [\n        #dump_nodes\n    ]", "id": "f4946:m0"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/authentication/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: This container defines ISIS authentication state.", "id": "f22460:c1:m6"}
{"signature": "def solve(a, b):", "body": "a, _ = _makearray(a)<EOL>_assertRankAtLeast2(a)<EOL>_assertNdSquareness(a)<EOL>b, wrap = _makearray(b)<EOL>t, result_t = _commonType(a, b)<EOL>if b.ndim == a.ndim - <NUM_LIT:1>:<EOL><INDENT>if a.shape[-<NUM_LIT:1>] == <NUM_LIT:0> and b.shape[-<NUM_LIT:1>] == <NUM_LIT:0>:<EOL><INDENT>a = a.reshape(a.shape[:-<NUM_LIT:1>])<EOL>bc = broadcast(a, b)<EOL>return wrap(empty(bc.shape, dtype=result_t))<EOL><DEDENT>gufunc = _umath_linalg.solve1<EOL><DEDENT>else:<EOL><INDENT>if b.size == <NUM_LIT:0>:<EOL><INDENT>if (a.shape[-<NUM_LIT:1>] == <NUM_LIT:0> and b.shape[-<NUM_LIT:2>] == <NUM_LIT:0>) or b.shape[-<NUM_LIT:1>] == <NUM_LIT:0>:<EOL><INDENT>a = a[:,:<NUM_LIT:1>].reshape(a.shape[:-<NUM_LIT:1>] + (<NUM_LIT:1>,))<EOL>bc = broadcast(a, b)<EOL>return wrap(empty(bc.shape, dtype=result_t))<EOL><DEDENT><DEDENT>gufunc = _umath_linalg.solve<EOL><DEDENT>signature = '<STR_LIT>' if isComplexType(t) else '<STR_LIT>'<EOL>extobj = get_linalg_error_extobj(_raise_linalgerror_singular)<EOL>r = gufunc(a, b, signature=signature, extobj=extobj)<EOL>return wrap(r.astype(result_t))<EOL>", "docstring": "Solve a linear matrix equation, or system of linear scalar equations.\n\nComputes the \"exact\" solution, `x`, of the well-determined, i.e., full\nrank, linear matrix equation `ax = b`.\n\nParameters\n----------\na : (..., M, M) array_like\n    Coefficient matrix.\nb : {(..., M,), (..., M, K)}, array_like\n    Ordinate or \"dependent variable\" values.\n\nReturns\n-------\nx : {(..., M,), (..., M, K)} ndarray\n    Solution to the system a x = b.  Returned shape is identical to `b`.\n\nRaises\n------\nLinAlgError\n    If `a` is singular or not square.\n\nNotes\n-----\nBroadcasting rules apply, see the `numpy.linalg` documentation for\ndetails.\n\nThe solutions are computed using LAPACK routine _gesv\n\n`a` must be square and of full-rank, i.e., all rows (or, equivalently,\ncolumns) must be linearly independent; if either is not true, use\n`lstsq` for the least-squares best \"solution\" of the\nsystem/equation.\n\nReferences\n----------\n.. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,\n       FL, Academic Press, Inc., 1980, pg. 22.\n\nExamples\n--------\nSolve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:\n\n>>> a = np.array([[3,1], [1,2]])\n>>> b = np.array([9,8])\n>>> x = np.linalg.solve(a, b)\n>>> x\narray([ 2.,  3.])\n\nCheck that the solution is correct:\n\n>>> np.allclose(np.dot(a, x), b)\nTrue", "id": "f18969:m21"}
{"signature": "def add_months_to_date(months, date):", "body": "month = date.month<EOL>new_month = month + months<EOL>years = <NUM_LIT:0><EOL>while new_month < <NUM_LIT:1>:<EOL><INDENT>new_month += <NUM_LIT:12><EOL>years -= <NUM_LIT:1><EOL><DEDENT>while new_month > <NUM_LIT:12>:<EOL><INDENT>new_month -= <NUM_LIT:12><EOL>years += <NUM_LIT:1><EOL><DEDENT>year = date.year + years<EOL>try:<EOL><INDENT>return datetime.date(year, new_month, date.day)<EOL><DEDENT>except ValueError:<EOL><INDENT>if months > <NUM_LIT:0>:<EOL><INDENT>new_month += <NUM_LIT:1><EOL>if new_month > <NUM_LIT:12>:<EOL><INDENT>new_month -= <NUM_LIT:12><EOL>year += <NUM_LIT:1><EOL><DEDENT>return datetime.datetime(year, new_month, <NUM_LIT:1>)<EOL><DEDENT>else:<EOL><INDENT>new_day = calendar.monthrange(year, new_month)[<NUM_LIT:1>]<EOL>return datetime.datetime(year, new_month, new_day)<EOL><DEDENT><DEDENT>", "docstring": "Add a number of months to a date", "id": "f7521:m20"}
{"signature": "def notify_exception(self, transfer_id, exception):", "body": "<EOL>self._transfer_states[transfer_id].exception = exception<EOL>", "docstring": "Notify an exception was encountered for a transfer\n\n        :param transfer_id: Unique identifier for the transfer\n        :param exception: The exception encountered for that transfer", "id": "f10184:c5:m5"}
{"signature": "def _set_af(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGListType(<EOL>\"<STR_LIT>\",<EOL>af.af,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>is_container=\"<STR_LIT:list>\",<EOL>user_ordered=False,<EOL>path_helper=self._path_helper,<EOL>yang_keys=\"<STR_LIT>\",<EOL>extensions=None,<EOL>),<EOL>is_container=\"<STR_LIT:list>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:list>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:list>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__af = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for af, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af (list)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_af is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_af() directly.\n\nYANG Description: Address-family/Subsequent Address-family list.", "id": "f22438:c1:m3"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, server_name, database_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>server_name=server_name,<EOL>database_name=database_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates a new database or updates an existing database.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server.\n        :type server_name: str\n        :param database_name: The name of the database.\n        :type database_name: str\n        :param parameters: The requested database resource state.\n        :type parameters: ~azure.mgmt.sql.models.Database\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns Database or\n         ClientRawResponse<Database> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.sql.models.Database]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.sql.models.Database]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38343:c0:m14"}
{"signature": "@staticmethod<EOL><INDENT>def _convert_date_to_dict(field_date):<DEDENT>", "body": "return {DAY: field_date.day, MONTH: field_date.month, YEAR: field_date.year}<EOL>", "docstring": "Convert native python ``datetime.date`` object  to a format supported by the API", "id": "f9287:c0:m6"}
{"signature": "def table(name, auth=None, eager=True):", "body": "auth = auth or []<EOL>dynamodb = boto.connect_dynamodb(*auth)<EOL>table = dynamodb.get_table(name)<EOL>return Table(table=table, eager=eager)<EOL>", "docstring": "Returns a given table for the given user.", "id": "f8:m0"}
{"signature": "def _get_dropped(self):", "body": "return self.__dropped<EOL>", "docstring": "Getter method for dropped, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/unknown/state/dropped (yang:counter32)\n\n    YANG Description: The number of the specified type of PDU received on the interface\nthat have been dropped.", "id": "f22423:c1:m8"}
{"signature": "def _parse_image_name(self, image, retry=True):", "body": "try:<EOL><INDENT>job_id, collection, job_name = image.split('<STR_LIT:U+002C>')<EOL><DEDENT>except:<EOL><INDENT>if retry:<EOL><INDENT>return self._parse_image_name(\"<STR_LIT>\" %(image, self.job),<EOL>retry=False)<EOL><DEDENT>bot.exit('''<STR_LIT>''')<EOL><DEDENT>return job_id, collection, job_name<EOL>", "docstring": "starting with an image string in either of the following formats:\n           job_id|collection\n           job_id|collection|job_name\n\n           Parse the job_name, job_id, and collection uri from it. If the user\n           provides the first option, we use the job_name set by the client\n           (default is build).\n\n           Parameters\n           ==========\n           image: the string to parse, with values separated by |\n           retry: the client can call itself recursively once, providing the\n                  default job_name if the user doesn't.", "id": "f9930:c0:m6"}
{"signature": "def __eof_qubit(rho):", "body": "c = concurrence(rho)<EOL>c = <NUM_LIT:0.5> + <NUM_LIT:0.5> * np.sqrt(<NUM_LIT:1> - c * c)<EOL>return shannon_entropy([c, <NUM_LIT:1> - c])<EOL>", "docstring": "Compute the Entanglement of Formation of a 2-qubit density matrix.\n\nArgs:\n    rho ((array_like): (4,4) array_like, input density matrix.\n\nReturns:\n    float: The entanglement of formation.", "id": "f10704:m17"}
{"signature": "def list(<EOL>self, location, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT:location>': self._serialize.url(\"<STR_LIT:location>\", location, '<STR_LIT:str>', pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.UsagePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.UsagePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists compute usages for a subscription.\n\n        :param location: The location where resource usage is queried.\n        :type location: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Usage\n        :rtype:\n         ~azure.mgmt.network.v2015_06_15.models.UsagePaged[~azure.mgmt.network.v2015_06_15.models.Usage]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34395:c0:m1"}
{"signature": "def _validate(self, qobj):", "body": "n_qubits = qobj.config.n_qubits<EOL>max_qubits = self.configuration().n_qubits<EOL>if n_qubits > max_qubits:<EOL><INDENT>raise BasicAerError('<STR_LIT>'.format(n_qubits) +<EOL>'<STR_LIT>'.format(max_qubits) +<EOL>'<STR_LIT>'.format(self.name()))<EOL><DEDENT>if qobj.config.shots != <NUM_LIT:1>:<EOL><INDENT>logger.info('<STR_LIT>',<EOL>self.name())<EOL>qobj.config.shots = <NUM_LIT:1><EOL><DEDENT>for experiment in qobj.experiments:<EOL><INDENT>name = experiment.header.name<EOL>if getattr(experiment.config, '<STR_LIT>', <NUM_LIT:1>) != <NUM_LIT:1>:<EOL><INDENT>logger.info('<STR_LIT>'<EOL>'<STR_LIT>',<EOL>self.name(), name)<EOL>experiment.config.shots = <NUM_LIT:1><EOL><DEDENT><DEDENT>", "docstring": "Semantic validations of the qobj which cannot be done via schemas.\n        Some of these may later move to backend schemas.\n\n        1. No shots\n        2. No measurements in the middle", "id": "f10949:c0:m2"}
{"signature": "def run_setup(script_name, script_args=None, stop_after=\"<STR_LIT>\"):", "body": "if stop_after not in ('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'):<EOL><INDENT>raise ValueError(\"<STR_LIT>\" % stop_after)<EOL><DEDENT>core._setup_stop_after = stop_after<EOL>save_argv = sys.argv<EOL>glocals = copy(globals())<EOL>glocals['<STR_LIT>'] = script_name<EOL>glocals['<STR_LIT>'] = \"<STR_LIT:__main__>\"<EOL>try:<EOL><INDENT>try:<EOL><INDENT>sys.argv[<NUM_LIT:0>] = script_name<EOL>if script_args is not None:<EOL><INDENT>sys.argv[<NUM_LIT:1>:] = script_args<EOL><DEDENT>f = open(script_name)<EOL>try:<EOL><INDENT>exec(f.read(), glocals, glocals)<EOL><DEDENT>finally:<EOL><INDENT>f.close()<EOL><DEDENT><DEDENT>finally:<EOL><INDENT>sys.argv = save_argv<EOL>core._setup_stop_after = None<EOL><DEDENT><DEDENT>except Exception:<EOL><INDENT>logging.warn(\"<STR_LIT>\", exc_info=True)<EOL><DEDENT>if core._setup_distribution is None:<EOL><INDENT>raise RuntimeError(<EOL>\"<STR_LIT>\"<EOL>\"<STR_LIT>\" %<EOL>script_name)<EOL><DEDENT>return core._setup_distribution<EOL>", "docstring": "Run a setup script in a somewhat controlled environment, and\n    return the Distribution instance that drives things.  This is useful\n    if you need to find out the distribution meta-data (passed as\n    keyword args from 'script' to 'setup()', or the contents of the\n    config files or command-line.\n\n    'script_name' is a file that will be run with 'execfile()';\n    'sys.argv[0]' will be replaced with 'script' for the duration of the\n    call.  'script_args' is a list of strings; if supplied,\n    'sys.argv[1:]' will be replaced by 'script_args' for the duration of\n    the call.\n\n    'stop_after' tells 'setup()' when to stop processing; possible\n    values:\n      init\n        stop after the Distribution instance has been created and\n        populated with the keyword arguments to 'setup()'\n      config\n        stop after config files have been parsed (and their data\n        stored in the Distribution instance)\n      commandline\n        stop after the command-line ('sys.argv[1:]' or 'script_args')\n        have been parsed (and the data stored in the Distribution)\n      run [default]\n        stop after all commands have been run (the same as if 'setup()'\n        had been called in the usual way\n\n    Returns the Distribution instance, which provides all information\n    used to drive the Distutils.", "id": "f6103:m0"}
{"signature": "def encode_pretty_printed_json(json_object):", "body": "return _pretty_encoder.encode(json_object).encode(\"<STR_LIT:ascii>\")<EOL>", "docstring": "Encodes the JSON object dict as human readable ascii bytes.", "id": "f14426:m3"}
{"signature": "@classmethod<EOL><INDENT>def has_resuming(cls):<DEDENT>", "body": "return False<EOL>", "docstring": "Returns whether it supports to resume the fetch process.\n\n        :returns: this backend does not support items resuming", "id": "f13157:c0:m4"}
{"signature": "def read_csv_and_convert(path, shuffle=False, copy_index=True, **kwargs):", "body": "from concurrent.futures import ProcessPoolExecutor<EOL>import pandas as pd<EOL>filenames = glob.glob(path)<EOL>if len(filenames) > <NUM_LIT:1>:<EOL><INDENT>filename_hdf5 = _convert_name(filenames, shuffle=shuffle)<EOL>filename_hdf5_noshuffle = _convert_name(filenames, shuffle=False)<EOL>if not os.path.exists(filename_hdf5):<EOL><INDENT>if not os.path.exists(filename_hdf5_noshuffle):<EOL><INDENT>for filename in filenames:<EOL><INDENT>read_csv_and_convert(filename, shuffle=shuffle, copy_index=copy_index, **kwargs)<EOL><DEDENT>ds = open_many([_convert_name(k, shuffle=shuffle) for k in filenames])<EOL><DEDENT>else:<EOL><INDENT>ds = open(filename_hdf5_noshuffle)<EOL><DEDENT>ds.export_hdf5(filename_hdf5, shuffle=shuffle)<EOL><DEDENT>return open(filename_hdf5)<EOL><DEDENT>else:<EOL><INDENT>filename = filenames[<NUM_LIT:0>]<EOL>filename_hdf5 = _convert_name(filename, shuffle=shuffle)<EOL>filename_hdf5_noshuffle = _convert_name(filename, shuffle=False)<EOL>if not os.path.exists(filename_hdf5):<EOL><INDENT>if not os.path.exists(filename_hdf5_noshuffle):<EOL><INDENT>df = pd.read_csv(filename, **kwargs)<EOL>ds = from_pandas(df, copy_index=copy_index)<EOL><DEDENT>else:<EOL><INDENT>ds = open(filename_hdf5_noshuffle)<EOL><DEDENT>ds.export_hdf5(filename_hdf5, shuffle=shuffle)<EOL><DEDENT>return open(filename_hdf5)<EOL><DEDENT>", "docstring": "Convert a path (or glob pattern) to a single hdf5 file, will open the hdf5 file if exists.\n\n    Example:\n            >>> vaex.read_csv_and_convert('test-*.csv', shuffle=True)  # this may take a while\n            >>> vaex.read_csv_and_convert('test-*.csv', shuffle=True)  # 2nd time it is instant\n\n    :param str path: path of file or glob pattern for multiple files\n    :param bool shuffle: shuffle DataFrame when converting to hdf5\n    :param bool copy_index: by default pandas will create an index (row number), set to false if you want to drop that\n    :param kwargs: parameters passed to pandas' read_cvs", "id": "f6963:m15"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/use_multiple_paths/config (container)\n\nYANG Description: Configuration parameters relating to multipath", "id": "f23455:c0:m2"}
{"signature": "def _get_out_reservation_tear_messages(self):", "body": "return self.__out_reservation_tear_messages<EOL>", "docstring": "Getter method for out_reservation_tear_messages, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/global/state/counters/out_reservation_tear_messages (yang:counter64)\n\nYANG Description: Number of sent RSVP Resv Tear messages", "id": "f22321:c1:m53"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, virtual_network_gateway_connection_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>virtual_network_gateway_connection_name=virtual_network_gateway_connection_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a virtual network gateway connection in the\n        specified resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_gateway_connection_name: The name of the\n         virtual network gateway connection.\n        :type virtual_network_gateway_connection_name: str\n        :param parameters: Parameters supplied to the create or update virtual\n         network gateway connection operation.\n        :type parameters:\n         ~azure.mgmt.network.v2017_09_01.models.VirtualNetworkGatewayConnection\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns\n         VirtualNetworkGatewayConnection or\n         ClientRawResponse<VirtualNetworkGatewayConnection> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_09_01.models.VirtualNetworkGatewayConnection]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_09_01.models.VirtualNetworkGatewayConnection]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29794:c0:m2"}
{"signature": "def last_blank(src):", "body": "if not src: return False<EOL>ll  = src.splitlines()[-<NUM_LIT:1>]<EOL>return (ll == '<STR_LIT>') or ll.isspace()<EOL>", "docstring": "Determine if the input source ends in a blank.\n\n    A blank is either a newline or a line consisting of whitespace.\n\n    Parameters\n    ----------\n    src : string\n      A single or multiline string.", "id": "f21466:m1"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/graceful_restart/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration parameters relating to graceful-restart", "id": "f23377:c1:m3"}
{"signature": "def _set_attribute_on_managed_object(self, managed_object, attribute):", "body": "attribute_name = attribute[<NUM_LIT:0>]<EOL>attribute_value = attribute[<NUM_LIT:1>]<EOL>if self._attribute_policy.is_attribute_multivalued(attribute_name):<EOL><INDENT>if attribute_name == '<STR_LIT:Name>':<EOL><INDENT>managed_object.names.extend(<EOL>[x.name_value.value for x in attribute_value]<EOL>)<EOL>for name in managed_object.names:<EOL><INDENT>if managed_object.names.count(name) > <NUM_LIT:1>:<EOL><INDENT>raise exceptions.InvalidField(<EOL>\"<STR_LIT>\"<EOL>)<EOL><DEDENT><DEDENT><DEDENT>else:<EOL><INDENT>raise exceptions.InvalidField(<EOL>\"<STR_LIT>\".format(attribute_name)<EOL>)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>field = None<EOL>value = attribute_value.value<EOL>if attribute_name == '<STR_LIT>':<EOL><INDENT>field = '<STR_LIT>'<EOL><DEDENT>elif attribute_name == '<STR_LIT>':<EOL><INDENT>field = '<STR_LIT>'<EOL><DEDENT>elif attribute_name == '<STR_LIT>':<EOL><INDENT>field = '<STR_LIT>'<EOL>value = list()<EOL>for e in enums.CryptographicUsageMask:<EOL><INDENT>if e.value & attribute_value.value:<EOL><INDENT>value.append(e)<EOL><DEDENT><DEDENT><DEDENT>elif attribute_name == '<STR_LIT>':<EOL><INDENT>field = '<STR_LIT>'<EOL><DEDENT>if field:<EOL><INDENT>existing_value = getattr(managed_object, field)<EOL>if existing_value:<EOL><INDENT>if existing_value != value:<EOL><INDENT>raise exceptions.InvalidField(<EOL>\"<STR_LIT>\".format(<EOL>attribute_name<EOL>)<EOL>)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>setattr(managed_object, field, value)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>raise exceptions.InvalidField(<EOL>\"<STR_LIT>\".format(attribute_name)<EOL>)<EOL><DEDENT><DEDENT>", "docstring": "Set the attribute value on the kmip.pie managed object.", "id": "f15155:c0:m16"}
{"signature": "def provider(self):", "body": "return self._provider<EOL>", "docstring": "Return the backend Provider.\n\n        Returns:\n            BaseProvider: the Provider responsible for the backend.", "id": "f10957:c0:m4"}
{"signature": "def save_page(self, path=None):", "body": "path = _prepare_path(path, \"<STR_LIT:html>\")<EOL>with open(path, \"<STR_LIT:wb>\") as f:<EOL><INDENT>f.write(encode_string(self.body))<EOL><DEDENT>return path<EOL>", "docstring": "Save a snapshot of the page.\n\nIf invoked without arguments, it will save a file to :data:`capybara.save_path` and the\nfile will be given a randomly generated filename. If invoked with a relative path, the path\nwill be relative to :data:`capybara.save_path`.\n\nArgs:\n    path (str, optional): The path to where it should be saved.\n\nReturns:\n    str: The path to which the file was saved.", "id": "f16683:c0:m32"}
{"signature": "def process_data(data, number_to_keep):", "body": "result = dict()<EOL>if number_to_keep != <NUM_LIT:0>:<EOL><INDENT>data_temp = dict(Counter(data).most_common(number_to_keep))<EOL>data_temp['<STR_LIT>'] = sum(data.values()) - sum(data_temp.values())<EOL>data = data_temp<EOL><DEDENT>labels = data<EOL>values = np.array([data[key] for key in labels], dtype=float)<EOL>pvalues = values / sum(values)<EOL>for position, label in enumerate(labels):<EOL><INDENT>result[label] = round(pvalues[position], <NUM_LIT:5>)<EOL><DEDENT>return result<EOL>", "docstring": "Prepare received data for representation.\n\n        Args:\n            data (dict): values to represent (ex. {'001' : 130})\n            number_to_keep (int): number of elements to show individually.\n\n        Returns:\n            dict: processed data to show.", "id": "f10875:m0"}
{"signature": "def create_user(self, user, account_id=None):", "body": "if account_id is None:<EOL><INDENT>account_id = self._canvas_account_id<EOL>if account_id is None:<EOL><INDENT>raise MissingAccountID()<EOL><DEDENT><DEDENT>url = ACCOUNTS_API.format(account_id) + \"<STR_LIT>\"<EOL>data = self._post_resource(url, user.post_data())<EOL>return CanvasUser(data=data)<EOL>", "docstring": "Create and return a new user and pseudonym for an account.\n\nhttps://canvas.instructure.com/doc/api/users.html#method.users.create", "id": "f15926:c0:m4"}
{"signature": "@asyncio.coroutine<EOL><INDENT>def request(self, subject, payload, timeout=<NUM_LIT:0.5>, expected=<NUM_LIT:1>, cb=None):<DEDENT>", "body": "if self.is_draining_pubs:<EOL><INDENT>raise ErrConnectionDraining<EOL><DEDENT>if cb is not None:<EOL><INDENT>next_inbox = INBOX_PREFIX[:]<EOL>next_inbox.extend(self._nuid.next())<EOL>inbox = next_inbox.decode()<EOL>sid = yield from self.subscribe(inbox, cb=cb)<EOL>yield from self.auto_unsubscribe(sid, expected)<EOL>yield from self.publish_request(subject, inbox, payload)<EOL>return sid<EOL><DEDENT>if self._resp_sub_prefix is None:<EOL><INDENT>self._resp_map = {}<EOL>self._resp_sub_prefix = INBOX_PREFIX[:]<EOL>self._resp_sub_prefix.extend(self._nuid.next())<EOL>self._resp_sub_prefix.extend(b'<STR_LIT:.>')<EOL>resp_mux_subject = self._resp_sub_prefix[:]<EOL>resp_mux_subject.extend(b'<STR_LIT:*>')<EOL>sub = Subscription(subject=resp_mux_subject.decode())<EOL>sub.pending_msgs_limit = DEFAULT_SUB_PENDING_MSGS_LIMIT<EOL>sub.pending_bytes_limit = DEFAULT_SUB_PENDING_BYTES_LIMIT<EOL>sub.pending_queue = asyncio.Queue(<EOL>maxsize=sub.pending_msgs_limit,<EOL>loop=self._loop,<EOL>)<EOL>@asyncio.coroutine<EOL>def wait_for_msgs():<EOL><INDENT>nonlocal sub<EOL>while True:<EOL><INDENT>try:<EOL><INDENT>msg = yield from sub.pending_queue.get()<EOL>token = msg.subject[INBOX_PREFIX_LEN:]<EOL>try:<EOL><INDENT>fut = self._resp_map[token]<EOL>fut.set_result(msg)<EOL>del self._resp_map[token]<EOL><DEDENT>except (asyncio.CancelledError, asyncio.InvalidStateError):<EOL><INDENT>del self._resp_map[token]<EOL>continue<EOL><DEDENT>except KeyError:<EOL><INDENT>continue<EOL><DEDENT><DEDENT>except asyncio.CancelledError:<EOL><INDENT>break<EOL><DEDENT><DEDENT><DEDENT>sub.wait_for_msgs_task = self._loop.create_task(<EOL>wait_for_msgs())<EOL>self._ssid += <NUM_LIT:1><EOL>ssid = self._ssid<EOL>self._subs[ssid] = sub<EOL>yield from self._subscribe(sub, ssid)<EOL><DEDENT>token = self._nuid.next()<EOL>inbox = self._resp_sub_prefix[:]<EOL>inbox.extend(token)<EOL>future = asyncio.Future(loop=self._loop)<EOL>self._resp_map[token.decode()] = future<EOL>yield from self.publish_request(subject, inbox.decode(), payload)<EOL>try:<EOL><INDENT>msg = yield from asyncio.wait_for(future, timeout, loop=self._loop)<EOL>return msg<EOL><DEDENT>except asyncio.TimeoutError:<EOL><INDENT>future.cancel()<EOL>raise ErrTimeout<EOL><DEDENT>", "docstring": "Implements the request/response pattern via pub/sub\nusing a single wildcard subscription that handles\nthe responses.", "id": "f14034:c3:m15"}
{"signature": "@staticmethod<EOL><INDENT>def metadata_id(item):<DEDENT>", "body": "return str(item['<STR_LIT:url>'])<EOL>", "docstring": "Extracts the identifier from a Build item.", "id": "f13175:c0:m5"}
{"signature": "def hessian(f, delta=DELTA):", "body": "def hessian_f(*args, **kwargs):<EOL><INDENT>if len(args) == <NUM_LIT:1>:<EOL><INDENT>x, = args<EOL>hessianf_x = (<EOL>f(x+delta) + f(x-delta) - <NUM_LIT:2>*f(x)<EOL>)/delta**<NUM_LIT:2><EOL>return hessianf_x<EOL><DEDENT>elif len(args) == <NUM_LIT:2>:<EOL><INDENT>x, y = args<EOL>if type(x) in [float, int] and type(y) in [float, int]:<EOL><INDENT>hess_xx = (<EOL>f(x + delta, y) + f(x - delta, y) - <NUM_LIT:2>*f(x, y)<EOL>)/delta**<NUM_LIT:2><EOL>hess_yy = (<EOL>f(x, y + delta) + f(x, y - delta) - <NUM_LIT:2>*f(x, y)<EOL>)/delta**<NUM_LIT:2><EOL>hess_xy = (<EOL>+ f(x+delta/<NUM_LIT:2>, y+delta/<NUM_LIT:2>)<EOL>+ f(x-delta/<NUM_LIT:2>, y-delta/<NUM_LIT:2>)<EOL>- f(x+delta/<NUM_LIT:2>, y-delta/<NUM_LIT:2>)<EOL>- f(x-delta/<NUM_LIT:2>, y+delta/<NUM_LIT:2>)<EOL>)/delta**<NUM_LIT:2><EOL>return hess_xx, hess_xy, hess_yy<EOL><DEDENT><DEDENT><DEDENT>return hessian_f<EOL>", "docstring": "Returns numerical hessian function of given input function\nInput: f, scalar function of one or two variables\n       delta(optional), finite difference step\nOutput: hessian function object", "id": "f16518:m1"}
{"signature": "def __init__(self, url, version=WPS_DEFAULT_VERSION, username=None, password=None, verbose=False, skip_caps=False,<EOL>headers=None, verify=True, cert=None, timeout=None):", "body": "<EOL>self.url = clean_ows_url(url)<EOL>self.username = username<EOL>self.password = password<EOL>self.version = version<EOL>self.verbose = verbose<EOL>self.headers = headers<EOL>self.verify = verify<EOL>self.cert = cert<EOL>self.timeout = timeout<EOL>self._capabilities = None<EOL>self.identification = None<EOL>self.provider = None<EOL>self.operations = []<EOL>self.processes = []<EOL>if not skip_caps:<EOL><INDENT>self.getcapabilities()<EOL><DEDENT>", "docstring": "Initialization method resets the object status.\nBy default it will execute a GetCapabilities invocation to the remote service,\nwhich can be skipped by using skip_caps=True.", "id": "f4759:c1:m0"}
{"signature": "def get(<EOL>self, billing_period_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", billing_period_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a named billing period.  This is only supported for Azure\n        Web-Direct subscriptions. Other subscription types which were not\n        purchased directly through the Azure web portal are not supported\n        through this preview API.\n\n        :param billing_period_name: The name of a BillingPeriod resource.\n        :type billing_period_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: BillingPeriod or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.billing.models.BillingPeriod or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.billing.models.ErrorResponseException>`", "id": "f37955:c0:m2"}
{"signature": "def to_cryptography(self):", "body": "from cryptography.hazmat.backends.openssl.x509 import (<EOL>_CertificateRevocationList<EOL>)<EOL>backend = _get_backend()<EOL>return _CertificateRevocationList(backend, self._crl)<EOL>", "docstring": "Export as a ``cryptography`` CRL.\n\n:rtype: ``cryptography.x509.CertificateRevocationList``\n\n.. versionadded:: 17.1.0", "id": "f4638:c13:m1"}
{"signature": "def read(self, dir_path: str, dataset: Optional[str] = '<STR_LIT>', url: Optional[str] = None, *args,<EOL>**kwargs) -> Dict[str, Dict[str, Any]]:", "body": "if url is not None:<EOL><INDENT>self.url = url<EOL><DEDENT>elif dataset == '<STR_LIT>':<EOL><INDENT>self.url = self.url_multi_squad_retr<EOL><DEDENT>elif dataset == '<STR_LIT>':<EOL><INDENT>self.url = self.url_multi_squad_ru_retr<EOL><DEDENT>else:<EOL><INDENT>raise RuntimeError('<STR_LIT>'.format(dataset))<EOL><DEDENT>dir_path = Path(dir_path)<EOL>required_files = ['<STR_LIT>'.format(dt) for dt in ['<STR_LIT:train>', '<STR_LIT>']]<EOL>if not dir_path.exists():<EOL><INDENT>dir_path.mkdir(parents=True)<EOL><DEDENT>if not all((dir_path / f).exists() for f in required_files):<EOL><INDENT>download_decompress(self.url, dir_path)<EOL><DEDENT>dataset = {}<EOL>for f in required_files:<EOL><INDENT>if '<STR_LIT>' in f:<EOL><INDENT>dataset['<STR_LIT>'] = dir_path.joinpath(f)<EOL><DEDENT>else:<EOL><INDENT>dataset['<STR_LIT:train>'] = dir_path.joinpath(f)<EOL><DEDENT><DEDENT>return dataset<EOL>", "docstring": "Args:\n    dir_path: path to save data\n    dataset: default dataset names: ``'MultiSQuADRetr'``, ``'MultiSQuADRuRetr'``\n    url: link to archive with dataset, use url argument if non-default dataset is used\n\nReturns:\n    dataset split on train/valid\n\nRaises:\n    RuntimeError: if `dataset` is not one of these: ``'MultiSQuADRetr'``, ``'MultiSQuADRuRetr'``.", "id": "f3016:c1:m0"}
{"signature": "def _get_include(self):", "body": "return self.__include<EOL>", "docstring": "Getter method for include, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/global/timers/max_metric/state/include (identityref)\n\n    YANG Description: By default, the maximum metric is advertised for all\nnon-stub interfaces of a device. When identities are\nspecified within this leaf-list, additional entities\nare also advertised with the maximum metric according\nto the values within the list.", "id": "f23144:c0:m8"}
{"signature": "@register.simple_tag<EOL>def jsfile(url):", "body": "if not url.startswith('<STR_LIT>') and not url[:<NUM_LIT:1>] == '<STR_LIT:/>':<EOL><INDENT>url = settings.STATIC_URL + url<EOL><DEDENT>return '<STR_LIT>'.format(<EOL>src=url)<EOL>", "docstring": "Output a script tag to a js file.", "id": "f1609:m2"}
{"signature": "def _get_facility(self):", "body": "return self.__facility<EOL>", "docstring": "Getter method for facility, mapped from YANG variable /system/logging/console/selectors/selector/state/facility (identityref)\n\nYANG Description: Specifies the facility, or class of messages to log", "id": "f21845:c0:m2"}
{"signature": "@property<EOL><INDENT>def subnets(self):<DEDENT>", "body": "api_version = self._get_api_version('<STR_LIT>')<EOL>if api_version == '<STR_LIT>':<EOL><INDENT>from .v2015_06_15.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2016_09_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2016_12_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_03_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_06_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_08_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_09_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_10_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2017_11_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_01_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_02_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_04_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_06_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_07_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_08_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_10_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_11_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_12_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>elif api_version == '<STR_LIT>':<EOL><INDENT>from .v2019_02_01.operations import SubnetsOperations as OperationClass<EOL><DEDENT>else:<EOL><INDENT>raise NotImplementedError(\"<STR_LIT>\".format(api_version))<EOL><DEDENT>return OperationClass(self._client, self.config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))<EOL>", "docstring": "Instance depends on the API version:\n\n           * 2015-06-15: :class:`SubnetsOperations<azure.mgmt.network.v2015_06_15.operations.SubnetsOperations>`\n           * 2016-09-01: :class:`SubnetsOperations<azure.mgmt.network.v2016_09_01.operations.SubnetsOperations>`\n           * 2016-12-01: :class:`SubnetsOperations<azure.mgmt.network.v2016_12_01.operations.SubnetsOperations>`\n           * 2017-03-01: :class:`SubnetsOperations<azure.mgmt.network.v2017_03_01.operations.SubnetsOperations>`\n           * 2017-06-01: :class:`SubnetsOperations<azure.mgmt.network.v2017_06_01.operations.SubnetsOperations>`\n           * 2017-08-01: :class:`SubnetsOperations<azure.mgmt.network.v2017_08_01.operations.SubnetsOperations>`\n           * 2017-09-01: :class:`SubnetsOperations<azure.mgmt.network.v2017_09_01.operations.SubnetsOperations>`\n           * 2017-10-01: :class:`SubnetsOperations<azure.mgmt.network.v2017_10_01.operations.SubnetsOperations>`\n           * 2017-11-01: :class:`SubnetsOperations<azure.mgmt.network.v2017_11_01.operations.SubnetsOperations>`\n           * 2018-01-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_01_01.operations.SubnetsOperations>`\n           * 2018-02-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_02_01.operations.SubnetsOperations>`\n           * 2018-04-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_04_01.operations.SubnetsOperations>`\n           * 2018-06-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_06_01.operations.SubnetsOperations>`\n           * 2018-07-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_07_01.operations.SubnetsOperations>`\n           * 2018-08-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_08_01.operations.SubnetsOperations>`\n           * 2018-10-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_10_01.operations.SubnetsOperations>`\n           * 2018-11-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_11_01.operations.SubnetsOperations>`\n           * 2018-12-01: :class:`SubnetsOperations<azure.mgmt.network.v2018_12_01.operations.SubnetsOperations>`\n           * 2019-02-01: :class:`SubnetsOperations<azure.mgmt.network.v2019_02_01.operations.SubnetsOperations>`", "id": "f30333:c1:m59"}
{"signature": "def fromarrays(arrayList, dtype=None, shape=None, formats=None,<EOL>names=None, titles=None, aligned=False, byteorder=None):", "body": "arrayList = [sb.asarray(x) for x in arrayList]<EOL>if shape is None or shape == <NUM_LIT:0>:<EOL><INDENT>shape = arrayList[<NUM_LIT:0>].shape<EOL><DEDENT>if isinstance(shape, int):<EOL><INDENT>shape = (shape,)<EOL><DEDENT>if formats is None and dtype is None:<EOL><INDENT>formats = []<EOL>for obj in arrayList:<EOL><INDENT>if not isinstance(obj, ndarray):<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>formats.append(obj.dtype.str)<EOL><DEDENT>formats = '<STR_LIT:U+002C>'.join(formats)<EOL><DEDENT>if dtype is not None:<EOL><INDENT>descr = sb.dtype(dtype)<EOL>_names = descr.names<EOL><DEDENT>else:<EOL><INDENT>parsed = format_parser(formats, names, titles, aligned, byteorder)<EOL>_names = parsed._names<EOL>descr = parsed._descr<EOL><DEDENT>if len(descr) != len(arrayList):<EOL><INDENT>raise ValueError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL><DEDENT>d0 = descr[<NUM_LIT:0>].shape<EOL>nn = len(d0)<EOL>if nn > <NUM_LIT:0>:<EOL><INDENT>shape = shape[:-nn]<EOL><DEDENT>for k, obj in enumerate(arrayList):<EOL><INDENT>nn = len(descr[k].shape)<EOL>testshape = obj.shape[:len(obj.shape) - nn]<EOL>if testshape != shape:<EOL><INDENT>raise ValueError(\"<STR_LIT>\" % k)<EOL><DEDENT><DEDENT>_array = recarray(shape, descr)<EOL>for i in range(len(arrayList)):<EOL><INDENT>_array[_names[i]] = arrayList[i]<EOL><DEDENT>return _array<EOL>", "docstring": "create a record array from a (flat) list of arrays\n\n    >>> x1=np.array([1,2,3,4])\n    >>> x2=np.array(['a','dd','xyz','12'])\n    >>> x3=np.array([1.1,2,3,4])\n    >>> r = np.core.records.fromarrays([x1,x2,x3],names='a,b,c')\n    >>> print r[1]\n    (2, 'dd', 2.0)\n    >>> x1[1]=34\n    >>> r.a\n    array([1, 2, 3, 4])", "id": "f19047:m1"}
{"signature": "def _get_recovery_time(self):", "body": "return self.__recovery_time<EOL>", "docstring": "Getter method for recovery_time, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/global/graceful_restart/config/recovery_time (uint32)\n\nYANG Description: RSVP state recovery time", "id": "f22315:c1:m8"}
{"signature": "def sensible_axes(self):", "body": "<EOL>axes = [<NUM_LIT:1>, <NUM_LIT:1>, <NUM_LIT:1>]<EOL>if self.v0.x == self.v1.x == self.v2.x:<EOL><INDENT>axes[<NUM_LIT:0>] = <NUM_LIT:0><EOL><DEDENT>if self.v0.y == self.v1.y == self.v2.y:<EOL><INDENT>axes[<NUM_LIT:1>] = <NUM_LIT:0><EOL><DEDENT>if self.v0.z == self.v1.z == self.v2.z:<EOL><INDENT>axes[<NUM_LIT:2>] = <NUM_LIT:0><EOL><DEDENT>u = [<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>]<EOL>for i in range(<NUM_LIT:3>):<EOL><INDENT>if axes[i] == <NUM_LIT:1>:<EOL><INDENT>u[i] = <NUM_LIT:1><EOL>axes[i] = <NUM_LIT:0><EOL>break<EOL><DEDENT><DEDENT>v = [<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>]<EOL>for i in range(<NUM_LIT:3>):<EOL><INDENT>if axes[i] == <NUM_LIT:1>:<EOL><INDENT>v[i] = -<NUM_LIT:1><EOL>break<EOL><DEDENT><DEDENT>uaxis = Axis(u[<NUM_LIT:0>], u[<NUM_LIT:1>], u[<NUM_LIT:2>])<EOL>vaxis = Axis(v[<NUM_LIT:0>], v[<NUM_LIT:1>], v[<NUM_LIT:2>])<EOL>return (uaxis, vaxis)<EOL>", "docstring": "Returns a sensible uaxis and vaxis for this plane.", "id": "f3342:c5:m2"}
{"signature": "def validate(self):", "body": "if (self.data.get('<STR_LIT>') or self.data.get('<STR_LIT:body>')) andself.data.get('<STR_LIT>', '<STR_LIT>').lower() not in CONTENT_TYPE_METHODS:<EOL><INDENT>raise InvalidConfig(<EOL>extra_body='<STR_LIT>'<EOL>'<STR_LIT>'.format('<STR_LIT:U+002CU+0020>'.join(CONTENT_TYPE_METHODS), self.name)<EOL>)<EOL><DEDENT>self.data['<STR_LIT>'] = CONTENT_TYPE_ALIASES.get(self.data.get('<STR_LIT>'),<EOL>self.data.get('<STR_LIT>'))<EOL>form_type = CONTENT_TYPE_ALIASES['<STR_LIT>']<EOL>if self.data.get('<STR_LIT:body>') and (self.data.get('<STR_LIT>') or form_type) == form_type:<EOL><INDENT>try:<EOL><INDENT>self.data['<STR_LIT:body>'] = json.loads(self.data['<STR_LIT:body>'])<EOL><DEDENT>except JSONDecodeError:<EOL><INDENT>raise InvalidConfig(<EOL>extra_body='<STR_LIT>'.format(self.name)<EOL>)<EOL><DEDENT><DEDENT>", "docstring": "Check self.data. Raise InvalidConfig on error\n\n        :return: None", "id": "f2823:c2:m0"}
{"signature": "def fetch_items(self, category, **kwargs):", "body": "from_date = kwargs['<STR_LIT>']<EOL>reviews_api = kwargs['<STR_LIT>']<EOL>mediawiki_version = self.client.get_version()<EOL>logger.info(\"<STR_LIT>\", mediawiki_version)<EOL>if reviews_api:<EOL><INDENT>if ((mediawiki_version[<NUM_LIT:0>] == <NUM_LIT:1> and mediawiki_version[<NUM_LIT:1>] >= <NUM_LIT>) or mediawiki_version[<NUM_LIT:0>] > <NUM_LIT:1>):<EOL><INDENT>fetcher = self.__fetch_1_27(from_date)<EOL><DEDENT>else:<EOL><INDENT>logger.warning(\"<STR_LIT>\")<EOL>logger.warning(\"<STR_LIT>\")<EOL>fetcher = self.__fetch_pre1_27(from_date)<EOL><DEDENT><DEDENT>else:<EOL><INDENT>fetcher = self.__fetch_pre1_27(from_date)<EOL><DEDENT>for page_reviews in fetcher:<EOL><INDENT>yield page_reviews<EOL><DEDENT>", "docstring": "Fetch the pages\n\n        :param category: the category of items to fetch\n        :param kwargs: backend arguments\n\n        :returns: a generator of items", "id": "f13173:c0:m2"}
{"signature": "async def read(self, buffer_size):", "body": "return self.msg[<NUM_LIT:0>:buffer_size]<EOL>", "docstring": "Read a message.", "id": "f60:c0:m1"}
{"signature": "def p_gate_op_4e0(self, program):", "body": "raise QasmError(\"<STR_LIT>\"<EOL>+ \"<STR_LIT>\")<EOL>", "docstring": "gate_op : id '(' ')'  error", "id": "f10971:c0:m60"}
{"signature": "def _get_out_reservation_error_messages(self):", "body": "return self.__out_reservation_error_messages<EOL>", "docstring": "Getter method for out_reservation_error_messages, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/global/state/counters/out_reservation_error_messages (yang:counter64)\n\nYANG Description: Number of sent RSVP Resv Error messages", "id": "f22321:c1:m50"}
{"signature": "def get(<EOL>self, device_name, name, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", device_name, '<STR_LIT:str>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the details of a specified job on a data box edge/gateway device.\n\n        :param device_name: The device name.\n        :type device_name: str\n        :param name: The job name.\n        :type name: str\n        :param resource_group_name: The resource group name.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: Job or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.edgegateway.models.Job or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37049:c0:m1"}
{"signature": "def prepareTestLoader(self, loader):", "body": "pass<EOL>", "docstring": "Called before tests are loaded. To replace the test loader,\n        return a test loader. To allow other plugins to process the\n        test loader, return None. Only one plugin may replace the test\n        loader. Only valid when using nose.TestProgram.\n\n        :param loader: :class:`nose.loader.TestLoader` \n             (or other loader) instance", "id": "f21776:c1:m35"}
{"signature": "def show_details(item_data: Dict[Any, Any]) -> str:", "body": "txt = \"<STR_LIT>\"<EOL>for key, value in item_data.items():<EOL><INDENT>txt += \"<STR_LIT>\" + str(key) + \"<STR_LIT>\" + '<STR_LIT>' + str(value) + \"<STR_LIT>\"<EOL><DEDENT>return txt<EOL>", "docstring": "Format catalog item output\n\n    Parameters:\n        item_data: item's attributes values\n\n    Returns:\n        [rich_message]: list of formatted rich message", "id": "f3132:m2"}
{"signature": "def get(<EOL>self, name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a enrollment account by name.\n\n        :param name: Enrollment Account name.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: EnrollmentAccount or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.billing.models.EnrollmentAccount or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.billing.models.ErrorResponseException>`", "id": "f37954:c0:m2"}
{"signature": "def get_empty_storage():", "body": "return {<EOL>'<STR_LIT>': None,<EOL>'<STR_LIT>': None,<EOL>'<STR_LIT>': [],<EOL>'<STR_LIT>': deque(),<EOL>}<EOL>", "docstring": "Return an empty storage skeleton, usable for testing", "id": "f6710:m14"}
{"signature": "def delete_backup_configuration_slot(<EOL>self, resource_group_name, name, slot, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete_backup_configuration_slot.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", slot, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes the backup configuration of an app.\n\n        Deletes the backup configuration of an app.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of the app.\n        :type name: str\n        :param slot: Name of the deployment slot. If a slot is not specified,\n         the API will delete the backup configuration for the production slot.\n        :type slot: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f44988:c0:m183"}
{"signature": "def list_by_route_filter(<EOL>self, resource_group_name, route_filter_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_route_filter.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", route_filter_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.RouteFilterRulePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.RouteFilterRulePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all RouteFilterRules in a route filter.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_filter_name: The name of the route filter.\n        :type route_filter_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of RouteFilterRule\n        :rtype:\n         ~azure.mgmt.network.v2018_01_01.models.RouteFilterRulePaged[~azure.mgmt.network.v2018_01_01.models.RouteFilterRule]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32028:c0:m8"}
{"signature": "def idd_copycols(A, k, idx):", "body": "A = np.asfortranarray(A)<EOL>return _id.idd_copycols(A, k, idx)<EOL>", "docstring": "Reconstruct skeleton matrix from real ID.\n\n:param A:\n    Original matrix.\n:type A: :class:`numpy.ndarray`\n:param k:\n    Rank of ID.\n:type k: int\n:param idx:\n    Column index array.\n:type idx: :class:`numpy.ndarray`\n\n:return:\n    Skeleton matrix.\n:rtype: :class:`numpy.ndarray`", "id": "f19309:m11"}
{"signature": "def _get_neighbor_id(self):", "body": "return self.__neighbor_id<EOL>", "docstring": "Getter method for neighbor_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/lan_adjacency_sid/sid/state/neighbor_id (oc-isis-types:system-id)\n\n    YANG Description: System ID of the neighbor associated with the LAN-Adj-Segment-ID\nvalue.", "id": "f22615:c0:m11"}
{"signature": "def remove_tier(self, name_num):", "body": "if isinstance(name_num, int):<EOL><INDENT>del(self.tiers[name_num-<NUM_LIT:1>])<EOL><DEDENT>else:<EOL><INDENT>self.tiers = [i for i in self.tiers if i.name != name_num]<EOL><DEDENT>", "docstring": "Remove a tier, when multiple tiers exist with that name only the\n        first is removed.\n\n        :param name_num: Name or number of the tier to remove.\n        :type name_num: int or str\n        :raises IndexError: If there is no tier with that number.", "id": "f14844:c0:m4"}
{"signature": "def delete_at_management_group(<EOL>self, policy_set_definition_name, management_group_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.delete_at_management_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", policy_set_definition_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", management_group_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.delete(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Deletes a policy set definition.\n\n        This operation deletes the policy set definition in the given\n        management group with the given name.\n\n        :param policy_set_definition_name: The name of the policy set\n         definition to delete.\n        :type policy_set_definition_name: str\n        :param management_group_id: The ID of the management group.\n        :type management_group_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.mgmt.resource.policy.v2018_03_01.models.ErrorResponseException>`", "id": "f37443:c0:m8"}
{"signature": "def add_dialog(self, dialog: Dialog) -> object:", "body": "self._dialogs.add(dialog)<EOL>if not self.initial_dialog_id:<EOL><INDENT>self.initial_dialog_id = dialog.id<EOL><DEDENT>return self<EOL>", "docstring": "Adds a dialog to the component dialog.\nAdding a new dialog will inherit the BotTelemetryClient of the ComponentDialog.\n:param dialog: The dialog to add.\n:return: The updated ComponentDialog", "id": "f10282:c0:m8"}
{"signature": "def update_tags(<EOL>self, resource_group_name, virtual_network_gateway_name, tags=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_tags_initial(<EOL>resource_group_name=resource_group_name,<EOL>virtual_network_gateway_name=virtual_network_gateway_name,<EOL>tags=tags,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Updates a virtual network gateway tags.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_gateway_name: The name of the virtual network\n         gateway.\n        :type virtual_network_gateway_name: str\n        :param tags: Resource tags.\n        :type tags: dict[str, str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns VirtualNetworkGateway\n         or ClientRawResponse<VirtualNetworkGateway> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2018_01_01.models.VirtualNetworkGateway]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2018_01_01.models.VirtualNetworkGateway]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32026:c0:m7"}
{"signature": "def price_converter(obj):", "body": "if isinstance(obj, str):<EOL><INDENT>obj = PriceClass.parse(obj)<EOL><DEDENT>return obj<EOL>", "docstring": "Ensures that string prices are converted into Price objects.", "id": "f11378:m0"}
{"signature": "def _get_prefer(self):", "body": "return self.__prefer<EOL>", "docstring": "Getter method for prefer, mapped from YANG variable /system/ntp/servers/server/config/prefer (boolean)\n\n    YANG Description: [adapted from IETF system model RFC 7317]\n\nIndicates whether this server should be preferred\nor not.", "id": "f21871:c0:m17"}
{"signature": "def _get_csnp_authentication(self):", "body": "return self.__csnp_authentication<EOL>", "docstring": "Getter method for csnp_authentication, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/authentication/state/csnp_authentication (boolean)\n\nYANG Description: Enable or disable for IS-IS CSNPs.", "id": "f22969:c0:m2"}
{"signature": "def _set_csnp_authentication(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__csnp_authentication = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for csnp_authentication, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/authentication/config/csnp_authentication (boolean)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_csnp_authentication is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_csnp_authentication() directly.\n\nYANG Description: Enable or disable for IS-IS CSNPs.", "id": "f22973:c0:m3"}
{"signature": "def list_sessions(self, updated_since=None, max_results=<NUM_LIT:100>, skip=<NUM_LIT:0>):", "body": "if int(max_results) < <NUM_LIT:1>:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>self._can_run()<EOL>message = {<EOL>'<STR_LIT>': updated_since or datetime.datetime.utcfromtimestamp(<NUM_LIT:0>),<EOL>'<STR_LIT>': skip,<EOL>'<STR_LIT>': max_results,<EOL>}<EOL>return self._mgmt_request_response(<EOL>REQUEST_RESPONSE_GET_MESSAGE_SESSIONS_OPERATION,<EOL>message,<EOL>mgmt_handlers.list_sessions_op)<EOL>", "docstring": "List session IDs.\n\n        List the Session IDs with pending messages in the queue where the state of the session\n        has been updated since the timestamp provided. If no timestamp is provided, all will be returned.\n        If the state of a Session has never been set, it will not be returned regardless of whether\n        there are messages pending.\n\n        :param updated_since: The UTC datetime from which to return updated pending Session IDs.\n        :type updated_since: datetime.datetime\n        :param max_results: The maximum number of Session IDs to return. Default value is 100.\n        :type max_results: int\n        :param skip: The page value to jump to. Default value is 0.\n        :type skip: int\n        :rtype: list[str]\n\n        Example:\n            .. literalinclude:: ../examples/test_examples.py\n                :start-after: [START list_sessions]\n                :end-before: [END list_sessions]\n                :language: python\n                :dedent: 4\n                :caption: List the ids of sessions with pending messages", "id": "f39481:c1:m10"}
{"signature": "def update_tags(<EOL>self, resource_group_name, network_interface_name, tags=None, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_tags_initial(<EOL>resource_group_name=resource_group_name,<EOL>network_interface_name=network_interface_name,<EOL>tags=tags,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Updates a network interface tags.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param network_interface_name: The name of the network interface.\n        :type network_interface_name: str\n        :param tags: Resource tags.\n        :type tags: dict[str, str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns NetworkInterface or\n         ClientRawResponse<NetworkInterface> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.network.v2017_11_01.models.NetworkInterface]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.network.v2017_11_01.models.NetworkInterface]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f28642:c0:m7"}
{"signature": "def on_click(self, element, event):", "body": "return False<EOL>", "docstring": "Override this method in subclass to process\n        click events. Note that element can be None\n        (click on empty space).", "id": "f16117:c0:m28"}
{"signature": "def submit(self):", "body": "if self._future is not None:<EOL><INDENT>raise JobError(\"<STR_LIT>\")<EOL><DEDENT>validate_qobj_against_schema(self._qobj)<EOL>self._future = self._executor.submit(self._fn, self._job_id, self._qobj)<EOL>", "docstring": "Submit the job to the backend for execution.\n\n        Raises:\n            QobjValidationError: if the JSON serialization of the Qobj passed\n            during construction does not validate against the Qobj schema.\n\n            JobError: if trying to re-submit the job.", "id": "f10952:c0:m1"}
{"signature": "def delete(<EOL>self, resource_group_name, public_ip_address_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>public_ip_address_name=public_ip_address_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified public IP address.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param public_ip_address_name: The name of the subnet.\n        :type public_ip_address_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f34219:c0:m2"}
{"signature": "def _post_unpack(self,items):", "body": "return items<EOL>", "docstring": "perform data modification of any values, after unpacking from a buffer.", "id": "f2234:c0:m3"}
{"signature": "def Item(self, key):<EOL>", "body": "return self._compose_optic(optics.ItemLens(key))<EOL>", "docstring": "A lens that focuses a single item (key-value pair) in a\n        dictionary by its key. Set an item to `None` to remove it from\n        the dictionary.\n\n            >>> from lenses import lens\n            >>> from collections import OrderedDict\n            >>> data = OrderedDict([(1, 10), (2, 20)])\n            >>> lens.Item(1)\n            UnboundLens(ItemLens(1))\n            >>> lens.Item(1).get()(data)\n            (1, 10)\n            >>> lens.Item(3).get()(data) is None\n            True\n            >>> lens.Item(1).set((1, 11))(data)\n            OrderedDict([(1, 11), (2, 20)])\n            >>> lens.Item(1).set(None)(data)\n            OrderedDict([(2, 20)])", "id": "f12060:c0:m18"}
{"signature": "def publish_latex(data, metadata=None):", "body": "publish_display_data(<EOL>u'<STR_LIT>',<EOL>{'<STR_LIT>':data},<EOL>metadata=metadata<EOL>)<EOL>", "docstring": "Publish raw LaTeX data to all frontends.\n\n    Parameters\n    ----------\n    data : unicode\n        The raw LaTeX data to publish.\n    metadata : dict\n        A dictionary for metadata related to the data. This can contain\n        arbitrary key, value pairs that frontends can use to interpret\n        the data.", "id": "f21468:m3"}
{"signature": "def get_feature_data(self, ids=None, features=None, dense=True):", "body": "result = self.data<EOL>if ids is not None:<EOL><INDENT>result = result.ix[ids]<EOL><DEDENT>if features is not None:<EOL><INDENT>result = result.ix[:, features]<EOL><DEDENT>return result.to_dense() if dense else result<EOL>", "docstring": "Slices and returns a subset of feature data.\n\n        Args:\n            ids (list, array): A list or 1D numpy array of study ids to\n                return rows for. If None, returns data for all studies\n                (i.e., all rows in array).\n            features (list, array): A list or 1D numpy array of named features\n                to return. If None, returns data for all features (i.e., all\n                columns in array).\n            dense (bool): Optional boolean. When True (default), convert the\n                result to a dense array before returning. When False, keep as\n                sparse matrix. Note that if ids is not None, the returned array\n                will always be dense.\n        Returns:\n          A pandas DataFrame with study IDs in rows and features incolumns.", "id": "f5203:c2:m3"}
{"signature": "def method2(self):", "body": "", "docstring": "bad docstring 1", "id": "f18831:c0:m1"}
{"signature": "def shutdown(self):", "body": "pass<EOL>", "docstring": "Do an orderly shutdown of this stage.\n\n        Incremental transforms are generally simple Python code and\n        a complicated shutdown is not required.  The pipeline does not\n        call this method.", "id": "f18036:c3:m2"}
{"signature": "def _get_setup_priority(self):", "body": "return self.__setup_priority<EOL>", "docstring": "Getter method for setup_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/unreserved_bandwidth/setup_priority/state/setup_priority (uint8)\n\n    YANG Description: Setup priority level of 0 through 7 to be used by Unreserved Bandwidth\nsub-TLV 11.", "id": "f22787:c1:m2"}
{"signature": "def configure(backends, raise_errors=False):", "body": "good_backends = []<EOL>for backend in backends:<EOL><INDENT>clspath = backend['<STR_LIT:class>']<EOL>options = backend.get('<STR_LIT>', {})<EOL>if isinstance(clspath, str):<EOL><INDENT>modpath, clsname = split_clspath(clspath)<EOL>try:<EOL><INDENT>__import__(modpath)<EOL>module = sys.modules[modpath]<EOL>cls = getattr(module, clsname)<EOL><DEDENT>except Exception:<EOL><INDENT>logger.exception('<STR_LIT>', clspath)<EOL>if raise_errors:<EOL><INDENT>raise<EOL><DEDENT>continue<EOL><DEDENT><DEDENT>else:<EOL><INDENT>cls = clspath<EOL><DEDENT>try:<EOL><INDENT>good_backends.append(cls(options))<EOL><DEDENT>except Exception:<EOL><INDENT>logger.exception(<EOL>'<STR_LIT>',<EOL>clspath,<EOL>options<EOL>)<EOL>if raise_errors:<EOL><INDENT>raise<EOL><DEDENT><DEDENT><DEDENT>_change_metrics(good_backends)<EOL>", "docstring": "Instantiate and configures backends.\n\n    :arg list-of-dicts backends: the backend configuration as a list of dicts where\n        each dict specifies a separate backend.\n\n        Each backend dict consists of two things:\n\n        1. ``class`` with a value that is either a Python class or a dotted\n           Python path to one\n\n        2. ``options`` dict with options for the backend in question to\n           configure it\n\n        See the documentation for the backends you're using to know what is\n        configurable in the options dict.\n\n    :arg raise_errors bool: whether or not to raise an exception if something\n        happens in configuration; if it doesn't raise an exception, it'll log\n        the exception\n\n    For example, this sets up a\n    :py:class:`markus.backends.logging.LoggingMetrics` backend::\n\n        markus.configure([\n            {\n                'class': 'markus.backends.logging.LoggingMetrics',\n                'options': {\n                    'logger_name': 'metrics'\n                }\n            }\n        ])\n\n\n    You can set up as many backends as you like.\n\n    .. Note::\n\n       During application startup, Markus should get configured before the app\n       starts generating metrics. Any metrics generated before Markus is\n       configured will get dropped.\n\n       However, anything can call :py:func:`markus.get_metrics` and get a\n       :py:class:`markus.main.MetricsInterface` before Markus has been\n       configured including at module load time.", "id": "f12343:m4"}
{"signature": "def pathIndex(self, path):", "body": "if path == self.root.path:<EOL><INDENT>return QModelIndex()<EOL><DEDENT>if not path.startswith(self.root.path):<EOL><INDENT>return QModelIndex()<EOL><DEDENT>parts = []<EOL>while True:<EOL><INDENT>if path == self.root.path:<EOL><INDENT>break<EOL><DEDENT>head, tail = os.path.split(path)<EOL>if head == path:<EOL><INDENT>if path:<EOL><INDENT>parts.append(path)<EOL><DEDENT>break<EOL><DEDENT>parts.append(tail)<EOL>path = head<EOL><DEDENT>parts.reverse()<EOL>if parts:<EOL><INDENT>item = self.root<EOL>count = <NUM_LIT:0><EOL>for count, part in enumerate(parts):<EOL><INDENT>matched = False<EOL>for child in item.children:<EOL><INDENT>if child.name == part:<EOL><INDENT>item = child<EOL>matched = True<EOL>break<EOL><DEDENT><DEDENT>if not matched:<EOL><INDENT>break<EOL><DEDENT><DEDENT>if count + <NUM_LIT:1> == len(parts):<EOL><INDENT>return self.createIndex(item.row, <NUM_LIT:0>, item)<EOL><DEDENT><DEDENT>return QModelIndex()<EOL>", "docstring": "Return index of item with *path*.", "id": "f11560:c6:m5"}
{"signature": "def get(<EOL>self, resource_group_name, route_filter_name, expand=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", route_filter_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if expand is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", expand, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified route filter.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_filter_name: The name of the route filter.\n        :type route_filter_name: str\n        :param expand: Expands referenced express route bgp peering resources.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: RouteFilter or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2016_12_01.models.RouteFilter or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29498:c0:m3"}
{"signature": "@classmethod<EOL><INDENT>def factory(cls, filename, mode, on_close):<DEDENT>", "body": "_temp_file = tempfile.TemporaryFile()<EOL>proxy = cls(_temp_file, filename, mode, on_close=on_close)<EOL>return proxy<EOL>", "docstring": "Create a S3File backed with a temporary file.", "id": "f3662:c0:m0"}
{"signature": "def _get_subinterface(self):", "body": "return self.__subinterface<EOL>", "docstring": "Getter method for subinterface, mapped from YANG variable /network_instances/network_instance/mpls/global/interface_attributes/interface/interface_ref/state/subinterface (leafref)\n\n    YANG Description: Reference to a subinterface -- this requires the base\ninterface to be specified using the interface leaf in\nthis container.  If only a reference to a base interface\nis requuired, this leaf should not be set.", "id": "f22195:c1:m5"}
{"signature": "def _construct_doc(self, docdict, shapes_vals=None):", "body": "tempdict = docdict.copy()<EOL>tempdict['<STR_LIT:name>'] = self.name or '<STR_LIT>'<EOL>tempdict['<STR_LIT>'] = self.shapes or '<STR_LIT>'<EOL>if shapes_vals is None:<EOL><INDENT>shapes_vals = ()<EOL><DEDENT>vals = '<STR_LIT:U+002CU+0020>'.join(str(_) for _ in shapes_vals)<EOL>tempdict['<STR_LIT>'] = vals<EOL>if self.shapes:<EOL><INDENT>tempdict['<STR_LIT>'] = '<STR_LIT>' % (self.shapes, vals)<EOL><DEDENT>else:<EOL><INDENT>tempdict['<STR_LIT>'] = '<STR_LIT>'<EOL><DEDENT>if self.shapes is None:<EOL><INDENT>for item in ['<STR_LIT>', '<STR_LIT:default>', '<STR_LIT>']:<EOL><INDENT>tempdict[item] = tempdict[item].replace(<EOL>\"<STR_LIT>\", \"<STR_LIT>\")<EOL><DEDENT><DEDENT>for i in range(<NUM_LIT:2>):<EOL><INDENT>if self.shapes is None:<EOL><INDENT>self.__doc__ = self.__doc__.replace(\"<STR_LIT>\", \"<STR_LIT>\")<EOL><DEDENT>self.__doc__ = doccer.docformat(self.__doc__, tempdict)<EOL><DEDENT>self.__doc__ = self.__doc__.replace('<STR_LIT>', '<STR_LIT:(>').replace('<STR_LIT>', '<STR_LIT:)>')<EOL>", "docstring": "Construct the instance docstring with string substitutions.", "id": "f19688:c1:m2"}
{"signature": "def get_stats(<EOL>self, resource_group_name, resource_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_stats.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorDetailsException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get the statistics from an IoT hub.\n\n        Get the statistics from an IoT hub.\n\n        :param resource_group_name: The name of the resource group that\n         contains the IoT hub.\n        :type resource_group_name: str\n        :param resource_name: The name of the IoT hub.\n        :type resource_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: RegistryStatistics or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.iothub.models.RegistryStatistics or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorDetailsException<azure.mgmt.iothub.models.ErrorDetailsException>`", "id": "f45355:c0:m10"}
{"signature": "def get_job(self, callback):", "body": "assert not self._closed<EOL>if self._active_js is None or not self._active_js.job_available():<EOL><INDENT>self._ready_callbacks.append(callback)<EOL><DEDENT>else:<EOL><INDENT>job = self._active_js.get_job()<EOL>self._job_sources[job] = self._active_js<EOL>callback(job)<EOL><DEDENT>", "docstring": "Calls the given callback function when a job becomes available.", "id": "f576:c6:m3"}
{"signature": "def update(self, alert):", "body": "data = {<EOL>'<STR_LIT:id>': alert['<STR_LIT:id>'],<EOL>'<STR_LIT:args>': alert['<STR_LIT:args>'],<EOL>'<STR_LIT>': alert['<STR_LIT>'],<EOL>'<STR_LIT>': alert['<STR_LIT>'],<EOL>'<STR_LIT>': alert['<STR_LIT>'],<EOL>'<STR_LIT>': alert['<STR_LIT>'],<EOL>'<STR_LIT>': alert['<STR_LIT>'],<EOL>'<STR_LIT>': alert['<STR_LIT>'],<EOL>'<STR_LIT:type>': alert['<STR_LIT:type>'],<EOL>}<EOL>return self._post(<EOL>request=ApiActions.UPDATE.value,<EOL>uri=ApiUri.ACTIONS.value,<EOL>params=data<EOL>)<EOL>", "docstring": "Update an alert\n\n:param alert: The data to update. Must include keys:\n\n    * id (str)\n    * rate_count (int)\n    * rate_range (str): 'day' or 'hour'\n    * limit_count (int)\n    * limit_range (str): 'day' or 'hour'\n    * type (str)\n    * schedule (list)\n    * args (dict)\n:type alert: dict\n\nExample:\n\n.. code-block:: python\n\n    Alert().update(\n        alert={\n            'id': 'd9d4596e-49e4-4135-b3b3-847f9e7c1f43',\n            'args': {'direct': 'you@example.com'},\n            'rate_count': 1,\n            'rate_range': 'hour',\n            'limit_count': 1,\n            'limit_range': 'hour',\n            'schedule': [],\n            'enabled': True,\n            'type': 'mailto',\n        }\n    )\n\n:return:\n:rtype: dict", "id": "f8650:c6:m3"}
{"signature": "def to_python(self):", "body": "if len(self.elements) == <NUM_LIT:0>:<EOL><INDENT>return None<EOL><DEDENT>if len(self.elements) == <NUM_LIT:1>:<EOL><INDENT>return self.elements[<NUM_LIT:0>].to_python()<EOL><DEDENT>operator = self.operator or Operator('<STR_LIT:;>')<EOL>return [operator.to_python()] +[elem.to_python() for elem in self.elements]<EOL>", "docstring": "Deconstruct the ``Expression`` instance to a list or tuple\n        (If ``Expression`` contains only one ``Constraint``).\n\n        Returns:\n            list or tuple: The deconstructed ``Expression``.", "id": "f5318:c1:m7"}
{"signature": "@manager.command<EOL>def live():", "body": "from livereload import Server<EOL>server = Server(app)<EOL>map(server.watch, glob2.glob(\"<STR_LIT>\"))  <EOL>map(server.watch, glob2.glob(\"<STR_LIT>\"))  <EOL>map(server.watch, glob2.glob(\"<STR_LIT>\"))  <EOL>server.serve(port=PORT)<EOL>", "docstring": "Run livereload server", "id": "f7097:m1"}
{"signature": "def register_callbacks(self, callbacks):", "body": "self._callbacks.extend(callbacks)<EOL>", "docstring": "\\\n        Hook for registering custom callbacks for dispatch patterns", "id": "f828:c0:m12"}
{"signature": "def get_deleted_sas_definitions(<EOL>self, vault_base_url, storage_account_name, maxresults=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.get_deleted_sas_definitions.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", vault_base_url, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", storage_account_name, '<STR_LIT:str>', pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if maxresults is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", maxresults, '<STR_LIT:int>', maximum=<NUM_LIT>, minimum=<NUM_LIT:1>)<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(<EOL>request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.KeyVaultErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.DeletedSasDefinitionItemPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.DeletedSasDefinitionItemPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists deleted SAS definitions for the specified vault and storage\n        account.\n\n        The Get Deleted Sas Definitions operation returns the SAS definitions\n        that have been deleted for a vault enabled for soft-delete. This\n        operation requires the storage/listsas permission.\n\n        :param vault_base_url: The vault name, for example\n         https://myvault.vault.azure.net.\n        :type vault_base_url: str\n        :param storage_account_name: The name of the storage account.\n        :type storage_account_name: str\n        :param maxresults: Maximum number of results to return in a page. If\n         not specified the service will return up to 25 results.\n        :type maxresults: int\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of DeletedSasDefinitionItem\n        :rtype:\n         ~azure.keyvault.v7_0.models.DeletedSasDefinitionItemPaged[~azure.keyvault.v7_0.models.DeletedSasDefinitionItem]\n        :raises:\n         :class:`KeyVaultErrorException<azure.keyvault.v7_0.models.KeyVaultErrorException>`", "id": "f35772:c1:m72"}
{"signature": "def parse(doc, treebuilder=\"<STR_LIT>\", encoding=None,<EOL>namespaceHTMLElements=True):", "body": "tb = treebuilders.getTreeBuilder(treebuilder)<EOL>p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)<EOL>return p.parse(doc, encoding=encoding)<EOL>", "docstring": "Parse a string or file-like object into a tree", "id": "f17201:m0"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/global/soft_preemption/state (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_state is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_state() directly.\n\n    YANG Description: State parameters relating to RSVP\nsoft preemption support", "id": "f22319:c0:m6"}
{"signature": "def update(<EOL>self, resource_group_name, cluster_name, tags=None, custom_headers=None, raw=False, **operation_config):", "body": "parameters = models.OperationalizationClusterUpdateParameters(tags=tags)<EOL>url = '<STR_LIT>'<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", cluster_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.patch(url, query_parameters)<EOL>response = self._client.send(<EOL>request, header_parameters, body_content, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorResponseWrapperException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "The PATCH operation can be used to update only the tags for a cluster.\n        Use PUT operation to update other properties.\n\n        :param resource_group_name: Name of the resource group in which the\n         cluster is located.\n        :type resource_group_name: str\n        :param cluster_name: The name of the cluster.\n        :type cluster_name: str\n        :param tags: Gets or sets a list of key value pairs that describe the\n         resource. These tags can be used in viewing and grouping this resource\n         (across resource groups). A maximum of 15 tags can be provided for a\n         resource. Each tag must have a key no greater in length than 128\n         characters and a value no greater in length than 256 characters.\n        :type tags: dict[str, str]\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: OperationalizationCluster or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.machinelearningcompute.models.OperationalizationCluster or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseWrapperException<azure.mgmt.machinelearningcompute.models.ErrorResponseWrapperException>`", "id": "f41455:c0:m3"}
{"signature": "def lookup_signum(name):", "body": "uname = name.upper()<EOL>if (uname.startswith('<STR_LIT>') and hasattr(signal, uname)):<EOL><INDENT>return getattr(signal, uname)<EOL><DEDENT>else:<EOL><INDENT>uname = \"<STR_LIT>\"+uname<EOL>if hasattr(signal, uname):<EOL><INDENT>return getattr(signal, uname)<EOL><DEDENT>return None<EOL><DEDENT>return<EOL>", "docstring": "Find the corresponding signal number for 'name'. Return None\n    if 'name' is invalid.", "id": "f7437:m2"}
{"signature": "def size(self):", "body": "return self._multi_graph.order() - <NUM_LIT:2> * len(self.wires)<EOL>", "docstring": "Return the number of operations.", "id": "f10770:c0:m26"}
{"signature": "def _set_flags(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(<EOL>allowed_type=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={\"<STR_LIT>\": {}, \"<STR_LIT>\": {}},<EOL>)<EOL>),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__flags = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for flags, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/is_reachability/neighbors/neighbors/expense_metric/state/flags (isis-metric-flags)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_flags is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_flags() directly.\n\nYANG Description: ISIS Expense Metric Flags.", "id": "f22963:c0:m6"}
{"signature": "def list_by_resource_group(<EOL>self, resource_group_name, top=None, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_resource_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>')<EOL><DEDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ZonePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ZonePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists the DNS zones within a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param top: The maximum number of record sets to return. If not\n         specified, returns up to 100 record sets.\n        :type top: int\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of Zone\n        :rtype:\n         ~azure.mgmt.dns.v2018_05_01.models.ZonePaged[~azure.mgmt.dns.v2018_05_01.models.Zone]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f26189:c0:m6"}
{"signature": "def _get_run_hash(self):", "body": "<EOL>pipeline_path = get_nextflow_filepath(self.log_file)<EOL>pipeline_hash = hashlib.md5()<EOL>with open(pipeline_path, \"<STR_LIT:rb>\") as fh:<EOL><INDENT>for chunk in iter(lambda: fh.read(<NUM_LIT>), b\"<STR_LIT>\"):<EOL><INDENT>pipeline_hash.update(chunk)<EOL><DEDENT><DEDENT>workdir = self.workdir.encode(\"<STR_LIT:utf8>\")<EOL>hostname = socket.gethostname().encode(\"<STR_LIT:utf8>\")<EOL>hardware_addr = str(uuid.getnode()).encode(\"<STR_LIT:utf8>\")<EOL>dir_hash = hashlib.md5(workdir + hostname + hardware_addr)<EOL>return pipeline_hash.hexdigest() + dir_hash.hexdigest()<EOL>", "docstring": "Gets the hash of the nextflow file", "id": "f6626:c0:m37"}
{"signature": "def _get_unreserved_bandwidth(self):", "body": "return self.__unreserved_bandwidth<EOL>", "docstring": "Getter method for unreserved_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/unreserved_bandwidth (container)\n\n    YANG Description: This container defines unreserved-bandwidth. The units are bytes\nper second.", "id": "f22592:c0:m23"}
{"signature": "def startLogging(console=True, filepath=None):", "body": "global logLevelFilterPredicate<EOL>observers = []<EOL>if console:<EOL><INDENT>observers.append( FilteringLogObserver(observer=textFileLogObserver(sys.stdout),  <EOL>predicates=[logLevelFilterPredicate] ))<EOL><DEDENT>if filepath is not None and filepath != \"<STR_LIT>\":<EOL><INDENT>observers.append( FilteringLogObserver(observer=textFileLogObserver(open(filepath,'<STR_LIT:a>')), <EOL>predicates=[logLevelFilterPredicate] ))<EOL><DEDENT>globalLogBeginner.beginLoggingTo(observers)<EOL>", "docstring": "Starts the global Twisted logger subsystem with maybe\nstdout and/or a file specified in the config file", "id": "f12851:m0"}
{"signature": "@property<EOL><INDENT>def disabled(self):<DEDENT>", "body": "raise NotImplementedError()<EOL>", "docstring": "bool: Whether this node is disabled.", "id": "f16550:c0:m25"}
{"signature": "def _get_label_options(self):", "body": "return self.__label_options<EOL>", "docstring": "Getter method for label_options, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af/segment_routing/prefix_sids/prefix_sid/state/label_options (enumeration)\n\n    YANG Description: The options associated with the IGP prefix SID for MPLS. The value\nof this leaf specifies the option that the SID should be advertised\ninto the IGP with.", "id": "f22448:c0:m8"}
{"signature": "def list_all(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_all.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.NetworkProfilePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.NetworkProfilePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all the network profiles in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of NetworkProfile\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.NetworkProfilePaged[~azure.mgmt.network.v2018_11_01.models.NetworkProfile]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32777:c0:m8"}
{"signature": "def _get_processed(self):", "body": "return self.__processed<EOL>", "docstring": "Getter method for processed, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/packet_counters/unknown/state/processed (yang:counter32)\n\n    YANG Description: The number of the specified type of PDU received on the interface\nthat have been processed by the local system.", "id": "f22423:c1:m5"}
{"signature": "def delete(<EOL>self, resource_group_name, azure_firewall_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>azure_firewall_name=azure_firewall_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified Azure Firewall.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param azure_firewall_name: The name of the Azure Firewall.\n        :type azure_firewall_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31659:c0:m2"}
{"signature": "def read_config_file(self, config_file=None, verbose=None):", "body": "helplevel = <NUM_LIT:1><EOL>while helplevel <= self._maxlevel:<EOL><INDENT>opt = \"<STR_LIT:->\".join([\"<STR_LIT>\"] * helplevel) + \"<STR_LIT>\"<EOL>if opt in self._all_options:<EOL><INDENT>break  <EOL><DEDENT>def helpfunc(option, opt, val, p, level=helplevel):<EOL><INDENT>print(self.help(level))<EOL>sys.exit(<NUM_LIT:0>)<EOL><DEDENT>helpmsg = \"<STR_LIT>\" % \"<STR_LIT:U+0020>\".join([\"<STR_LIT>\"] * helplevel)<EOL>optdict = {\"<STR_LIT:action>\": \"<STR_LIT>\", \"<STR_LIT>\": helpfunc, \"<STR_LIT>\": helpmsg}<EOL>provider = self.options_providers[<NUM_LIT:0>]<EOL>self.add_optik_option(provider, self.cmdline_parser, opt, optdict)<EOL>provider.options += ((opt, optdict),)<EOL>helplevel += <NUM_LIT:1><EOL><DEDENT>if config_file is None:<EOL><INDENT>config_file = self.config_file<EOL><DEDENT>if config_file is not None:<EOL><INDENT>config_file = os.path.expanduser(config_file)<EOL>if not os.path.exists(config_file):<EOL><INDENT>raise IOError(\"<STR_LIT>\".format(config_file))<EOL><DEDENT><DEDENT>use_config_file = config_file and os.path.exists(config_file)<EOL>if use_config_file:<EOL><INDENT>parser = self.cfgfile_parser<EOL>with io.open(config_file, \"<STR_LIT:r>\", encoding=\"<STR_LIT>\") as fp:<EOL><INDENT>parser.read_file(fp)<EOL><DEDENT>for sect, values in list(parser._sections.items()):<EOL><INDENT>if not sect.isupper() and values:<EOL><INDENT>parser._sections[sect.upper()] = values<EOL><DEDENT><DEDENT><DEDENT>if not verbose:<EOL><INDENT>return<EOL><DEDENT>if use_config_file:<EOL><INDENT>msg = \"<STR_LIT>\".format(os.path.abspath(config_file))<EOL><DEDENT>else:<EOL><INDENT>msg = \"<STR_LIT>\"<EOL><DEDENT>print(msg, file=sys.stderr)<EOL>", "docstring": "read the configuration file but do not load it (i.e. dispatching\n        values to each options provider)", "id": "f18308:c4:m11"}
{"signature": "def delete(<EOL>self, resource_group_name, circuit_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>circuit_name=circuit_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified express route circuit.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param circuit_name: The name of the express route circuit.\n        :type circuit_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30300:c0:m2"}
{"signature": "def remove(self, task_id):", "body": "try:<EOL><INDENT>self._rwlock.writer_acquire()<EOL>del self._tasks[task_id]<EOL><DEDENT>except KeyError:<EOL><INDENT>raise NotFoundError(element=str(task_id))<EOL><DEDENT>finally:<EOL><INDENT>self._rwlock.writer_release()<EOL><DEDENT>logger.debug(\"<STR_LIT>\", str(task_id))<EOL>", "docstring": "Remove a task from the registry.\n\n        To remove it, pass its identifier with `taks_id` parameter.\n        When the identifier is not found, a `NotFoundError` exception\n        is raised.\n\n        :param task_id: identifier of the task to remove\n\n        :raises NotFoundError: raised when the given task identifier\n            is not found on the registry", "id": "f4341:c1:m2"}
{"signature": "def _get_prefix(self):", "body": "return self.__prefix<EOL>", "docstring": "Getter method for prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/static_routes/static/config/prefix (inet:ip-prefix)\n\n    YANG Description: Destination prefix for the static route, either IPv4 or\nIPv6.", "id": "f22382:c1:m2"}
{"signature": "def get_ms_deploy_status_slot(<EOL>self, resource_group_name, name, slot, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_ms_deploy_status_slot.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT:name>': self._serialize.url(\"<STR_LIT:name>\", name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", slot, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.DefaultErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Get the status of the last MSDeploy operation.\n\n        Get the status of the last MSDeploy operation.\n\n        :param resource_group_name: Name of the resource group to which the\n         resource belongs.\n        :type resource_group_name: str\n        :param name: Name of web app.\n        :type name: str\n        :param slot: Name of web app slot. If not specified then will default\n         to production slot.\n        :type slot: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: MSDeployStatus or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.web.models.MSDeployStatus or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`DefaultErrorResponseException<azure.mgmt.web.models.DefaultErrorResponseException>`", "id": "f44988:c0:m219"}
{"signature": "def _read_reader_macro(ctx: ReaderContext) -> LispReaderForm:", "body": "start = ctx.reader.advance()<EOL>assert start == \"<STR_LIT:#>\"<EOL>token = ctx.reader.peek()<EOL>if token == \"<STR_LIT:{>\":<EOL><INDENT>return _read_set(ctx)<EOL><DEDENT>elif token == \"<STR_LIT:(>\":<EOL><INDENT>return _read_function(ctx)<EOL><DEDENT>elif token == \"<STR_LIT:'>\":<EOL><INDENT>ctx.reader.advance()<EOL>s = _read_sym(ctx)<EOL>return llist.l(_VAR, s)<EOL><DEDENT>elif token == '<STR_LIT:\">':<EOL><INDENT>return _read_regex(ctx)<EOL><DEDENT>elif token == \"<STR_LIT:_>\":<EOL><INDENT>ctx.reader.advance()<EOL>_read_next(ctx)  <EOL>return COMMENT<EOL><DEDENT>elif ns_name_chars.match(token):<EOL><INDENT>s = _read_sym(ctx)<EOL>assert isinstance(s, symbol.Symbol)<EOL>v = _read_next_consuming_comment(ctx)<EOL>if s in ctx.data_readers:<EOL><INDENT>f = ctx.data_readers[s]<EOL>return f(v)<EOL><DEDENT>else:<EOL><INDENT>raise SyntaxError(f\"<STR_LIT>\")<EOL><DEDENT><DEDENT>raise SyntaxError(f\"<STR_LIT>\")<EOL>", "docstring": "Return a data structure evaluated as a reader\n    macro from the input stream.", "id": "f1073:m31"}
{"signature": "def __init__(self,<EOL>power,<EOL>dtype=tf.int32,<EOL>interpolate_nondiscrete=True,<EOL>sample_maximum_iterations=<NUM_LIT:100>,<EOL>validate_args=False,<EOL>allow_nan_stats=False,<EOL>name=\"<STR_LIT>\"):", "body": "parameters = dict(locals())<EOL>with tf.name_scope(name) as name:<EOL><INDENT>power = tf.convert_to_tensor(<EOL>value=power,<EOL>name=\"<STR_LIT>\",<EOL>dtype=dtype_util.common_dtype([power], preferred_dtype=tf.float32))<EOL>if (not dtype_util.is_floating(power.dtype) or<EOL>dtype_util.base_equal(power.dtype, tf.float16)):<EOL><INDENT>raise TypeError(<EOL>\"<STR_LIT>\".format(<EOL>dtype_util.name(power.dtype)))<EOL><DEDENT>runtime_assertions = []<EOL>if validate_args:<EOL><INDENT>runtime_assertions.append(assert_util.assert_greater(<EOL>power, np.ones([], power.dtype.as_numpy_dtype)))<EOL><DEDENT>with tf.control_dependencies(runtime_assertions):<EOL><INDENT>self._power = tf.identity(power, name=\"<STR_LIT>\")<EOL><DEDENT><DEDENT>self._interpolate_nondiscrete = interpolate_nondiscrete<EOL>self._sample_maximum_iterations = sample_maximum_iterations<EOL>super(Zipf, self).__init__(<EOL>dtype=dtype,<EOL>reparameterization_type=reparameterization.NOT_REPARAMETERIZED,<EOL>validate_args=validate_args,<EOL>allow_nan_stats=allow_nan_stats,<EOL>parameters=parameters,<EOL>graph_parents=[self._power],<EOL>name=name)<EOL>", "docstring": "Initialize a batch of Zipf distributions.\n\n        Args:\n          power: `Float` like `Tensor` representing the power parameter. Must be\n            strictly greater than `1`.\n          dtype: The `dtype` of `Tensor` returned by `sample`.\n            Default value: `tf.int32`.\n          interpolate_nondiscrete: Python `bool`. When `False`, `log_prob` returns\n            `-inf` (and `prob` returns `0`) for non-integer inputs. When `True`,\n            `log_prob` evaluates the continuous function `-power log(k) -\n            log(zeta(power))` , which matches the Zipf pmf at integer arguments `k`\n            (note that this function is not itself a normalized probability\n            log-density).\n            Default value: `True`.\n          sample_maximum_iterations: Maximum number of iterations of allowable\n            iterations in `sample`. When `validate_args=True`, samples which fail to\n            reach convergence (subject to this cap) are masked out with\n            `self.dtype.min` or `nan` depending on `self.dtype.is_integer`.\n            Default value: `100`.\n          validate_args: Python `bool`, default `False`. When `True` distribution\n            parameters are checked for validity despite possibly degrading runtime\n            performance. When `False` invalid inputs may silently render incorrect\n            outputs.\n            Default value: `False`.\n          allow_nan_stats: Python `bool`, default `True`. When `True`, statistics\n            (e.g., mean, mode, variance) use the value \"`NaN`\" to indicate the\n            result is undefined. When `False`, an exception is raised if one or more\n            of the statistic's batch members are undefined.\n            Default value: `False`.\n          name: Python `str` name prefixed to Ops created by this class.\n            Default value: `'Zipf'`.\n\n        Raises:\n          TypeError: if `power` is not `float` like.", "id": "f15682:c0:m0"}
{"signature": "def _set_segment_routing_capability(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=segment_routing_capability.segment_routing_capability,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__segment_routing_capability = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for segment_routing_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/router_capabilities/router_capability/subtlvs/subtlvs/segment_routing_capability (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_segment_routing_capability is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_segment_routing_capability() directly.\n\nYANG Description: This container defines SR Capability sub-TLV 2.", "id": "f22564:c0:m12"}
{"signature": "def cloneNode(self):", "body": "raise NotImplementedError<EOL>", "docstring": "Return a shallow copy of the current node i.e. a node with the same\n        name and attributes but with no parent or child nodes", "id": "f9998:c0:m4"}
{"signature": "def list_by_resource_group(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_by_resource_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.ExpressRoutePortPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.ExpressRoutePortPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "List all the ExpressRoutePort resources in the specified resource\n        group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of ExpressRoutePort\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.ExpressRoutePortPaged[~azure.mgmt.network.v2018_11_01.models.ExpressRoutePort]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32770:c0:m8"}
{"signature": "@property<EOL><INDENT>def directives(self):<DEDENT>", "body": "if self._directives is None:<EOL><INDENT>self._directives = list(directive.Directive.extract(self.source))<EOL><DEDENT>return self._directives<EOL>", "docstring": "CommandLine:\n    python -m xdoctest.parser DoctestPart.directives\n\nExample:\n    >>> self = DoctestPart(['# doctest: +SKIP'], None, 0)\n    >>> print(', '.join(list(map(str, self.directives))))\n    <Directive(+SKIP)>", "id": "f2065:c0:m5"}
{"signature": "def _set_traffic_engineering(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__traffic_engineering = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for traffic_engineering, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/router_information/tlvs/tlv/informational_capabilities/state/traffic_engineering (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_traffic_engineering is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_traffic_engineering() directly.\n\n    YANG Description: When this leaf is set to true, the advertising system supports OSPFv2\ntraffic engineering capabilities", "id": "f23071:c0:m12"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, parameters, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_or_update.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>', max_length=<NUM_LIT>, min_length=<NUM_LIT:1>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.put(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>, <NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Create a resource group.\n\n        :param resource_group_name: The name of the resource group to be\n         created or updated.\n        :type resource_group_name: str\n        :param parameters: Parameters supplied to the create or update\n         resource group service operation.\n        :type parameters:\n         ~azure.mgmt.resource.resources.v2016_02_01.models.ResourceGroup\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: ResourceGroup or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.resource.resources.v2016_02_01.models.ResourceGroup or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37686:c0:m3"}
{"signature": "@fluent<EOL><INDENT>def url(self, url):<DEDENT>", "body": "self._request.url = url<EOL>self.add_matcher(matcher('<STR_LIT>', url))<EOL>", "docstring": "Defines the mock URL to match.\nIt can be a full URL with path and query params.\n\nProtocol schema is optional, defaults to ``http://``.\n\nArguments:\n    url (str): mock URL to match. E.g: ``server.com/api``.\n\nReturns:\n    self: current Mock instance.", "id": "f11904:c0:m1"}
{"signature": "def get(<EOL>self, gateway_resource_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", gateway_resource_name, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.FabricErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the Gateway resource with the given name.\n\n        Gets the information about the Gateway resource with the given name.\n        The information include the description and other properties of the\n        Gateway.\n\n        :param gateway_resource_name: The identity of the gateway.\n        :type gateway_resource_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: GatewayResourceDescription or ClientRawResponse if raw=true\n        :rtype: ~azure.servicefabric.models.GatewayResourceDescription or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`FabricErrorException<azure.servicefabric.models.FabricErrorException>`", "id": "f27466:c0:m2"}
{"signature": "@property<EOL><INDENT>def value(self):<DEDENT>", "body": "raise NotImplementedError()<EOL>", "docstring": "str: The value of the node.", "id": "f16550:c0:m5"}
{"signature": "def function12(value=dict([('<STR_LIT:a>', <NUM_LIT:1>), ('<STR_LIT:b>', <NUM_LIT:2>)])): ", "body": "return value<EOL>", "docstring": "dictionaries with items should not output item values in error message", "id": "f18360:m11"}
{"signature": "def set_active_range(self, i1, i2):", "body": "logger.debug(\"<STR_LIT>\", (i1, i2))<EOL>self._active_fraction = (i2 - i1) / float(self.length_original())<EOL>self._index_start = i1<EOL>self._index_end = i2<EOL>self.select(None)<EOL>self.set_current_row(None)<EOL>self._length_unfiltered = i2 - i1<EOL>self.signal_active_fraction_changed.emit(self, self._active_fraction)<EOL>", "docstring": "Sets the active_fraction, set picked row to None, and remove selection.\n\n        TODO: we may be able to keep the selection, if we keep the expression, and also the picked row", "id": "f6914:c0:m161"}
{"signature": "def history_tail(self, n=<NUM_LIT:10>):", "body": "return self._history[-n:]<EOL>", "docstring": "Get the local history list.\n\n        Parameters:\n        -----------\n        n : int\n            The (maximum) number of history items to get.", "id": "f21650:c0:m6"}
{"signature": "def save_as(self, info):", "body": "if not info.initialized:<EOL><INDENT>return<EOL>", "docstring": "Handles saving the current model to file.", "id": "f1988:c0:m6"}
{"signature": "def prerequisite_actions(self):", "body": "self.hide_error_message()<EOL>self.ui.show_all_curves.setDisabled(True)<EOL>self.ui.sens.setDisabled(True)<EOL>self.ui.show_grid.setDisabled(True)<EOL>pathname = os.path.dirname(sys.argv[<NUM_LIT:0>])<EOL>path = os.path.abspath(pathname)<EOL>self.verbose_value = self.ui.verbose_value.setText(\"<STR_LIT>\")<EOL>self.report_parameter_value = self.ui.report_parameter_value.setText(\"<STR_LIT>\")<EOL>self.ui.progressBar.reset()<EOL>", "docstring": "This function does all required actions at the beginning when we run the GUI.", "id": "f15342:c0:m26"}
{"signature": "def _set_version(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>default=RestrictedClassType(<EOL>base_type=int, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}, int_size=<NUM_LIT:8><EOL>)(<EOL><NUM_LIT:4><EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:version>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__version = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for version, mapped from YANG variable /system/ntp/servers/server/state/version (uint8)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_version is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_version() directly.\n\n    YANG Description: [adapted from IETF system model RFC 7317]\n\nVersion number to put in outgoing NTP packets", "id": "f21870:c0:m9"}
{"signature": "def _get_sid(self):", "body": "return self.__sid<EOL>", "docstring": "Getter method for sid, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/adjacency_sid/sid (list)\n\n    YANG Description: Adjacency Segment-IDs List. An IGP-Adjacency Segment is an IGP\nsegment attached to a unidirectional adjacency or a set of\nunidirectional adjacencies. By default, an IGP-Adjacency Segment is\nlocal to the node which advertises it.", "id": "f22833:c0:m2"}
{"signature": "def create_shared_data(self, **kwargs):", "body": "if '<STR_LIT>' not in kwargs:<EOL><INDENT>kwargs['<STR_LIT>'] = self.FLAG<EOL><DEDENT>if '<STR_LIT:data>' in kwargs:<EOL><INDENT>kwargs['<STR_LIT>'] = kwargs.pop('<STR_LIT:data>')<EOL><DEDENT>if '<STR_LIT>' in kwargs:<EOL><INDENT>self.traj = kwargs.pop('<STR_LIT>')<EOL><DEDENT>if '<STR_LIT>' in kwargs:<EOL><INDENT>self.traj = kwargs.pop('<STR_LIT>')<EOL><DEDENT>if '<STR_LIT:name>' in kwargs:<EOL><INDENT>self.name = kwargs.pop['<STR_LIT:name>']<EOL><DEDENT>if '<STR_LIT>' in kwargs:<EOL><INDENT>self.parent = kwargs.pop('<STR_LIT>')<EOL>if self.name is not None:<EOL><INDENT>self.parent[self.name] = self<EOL><DEDENT><DEDENT>return self._request_data('<STR_LIT>', kwargs=kwargs)<EOL>", "docstring": "Creates shared data on disk with a StorageService on disk.\n\n        Needs to be called before shared data can be used later on.\n\n        Actual arguments of ``kwargs`` depend on the type of data to be\n        created. For instance, creating an array one can use the keyword\n        ``obj`` to pass a numpy array (``obj=np.zeros((10,20,30))``).\n        Whereas for a PyTables table may need a description dictionary\n        (``description={'column_1': pt.StringCol(2, pos=0),'column_2': pt.FloatCol( pos=1)}``)\n        Refer to the PyTables documentation on how to create tables.", "id": "f4215:c1:m3"}
{"signature": "def list_available_sizes(<EOL>self, resource_group_name, vm_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_available_sizes.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", vm_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualMachineSizePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualMachineSizePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all available virtual machine sizes to which the specified\n        virtual machine can be resized.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualMachineSize\n        :rtype:\n         ~azure.mgmt.compute.v2018_06_01.models.VirtualMachineSizePaged[~azure.mgmt.compute.v2018_06_01.models.VirtualMachineSize]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24908:c0:m19"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualNetworkPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualNetworkPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all virtual networks in a resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualNetwork\n        :rtype:\n         ~azure.mgmt.network.v2018_11_01.models.VirtualNetworkPaged[~azure.mgmt.network.v2018_11_01.models.VirtualNetwork]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32792:c0:m9"}
{"signature": "def cx_gate_matrix():", "body": "return np.array([[<NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>],<EOL>[<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>],<EOL>[<NUM_LIT:0>, <NUM_LIT:1>, <NUM_LIT:0>, <NUM_LIT:0>]], dtype=complex)<EOL>", "docstring": "Get the matrix for a controlled-NOT gate.", "id": "f10950:m2"}
{"signature": "def _get_dynamic_neighbor_prefix(self):", "body": "return self.__dynamic_neighbor_prefix<EOL>", "docstring": "Getter method for dynamic_neighbor_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/dynamic_neighbor_prefixes/dynamic_neighbor_prefix (list)\n\n    YANG Description: An individual prefix from which dynamic neighbor\nconnections are allowed.", "id": "f23382:c1:m2"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, domain_name, domain_info, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>domain_name=domain_name,<EOL>domain_info=domain_info,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Create or update a domain.\n\n        Asynchronously creates or updates a new domain with the specified\n        parameters.\n\n        :param resource_group_name: The name of the resource group within the\n         user's subscription.\n        :type resource_group_name: str\n        :param domain_name: Name of the domain\n        :type domain_name: str\n        :param domain_info: Domain information\n        :type domain_info: ~azure.mgmt.eventgrid.models.Domain\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns Domain or\n         ClientRawResponse<Domain> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.eventgrid.models.Domain]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.eventgrid.models.Domain]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f27937:c0:m3"}
{"signature": "def get_dict(self, domain=None, path=None):", "body": "dictionary = {}<EOL>for cookie in iter(self):<EOL><INDENT>if (domain is None or cookie.domain == domain) and (path is None<EOL>or cookie.path == path):<EOL><INDENT>dictionary[cookie.name] = cookie.value<EOL><DEDENT><DEDENT>return dictionary<EOL>", "docstring": "Takes as an argument an optional domain and path and returns a plain\n        old Python dict of name-value pairs of cookies that meet the\n        requirements.", "id": "f16925:c3:m11"}
{"signature": "async def logout(self):", "body": "self.websession = None<EOL>self.token = None<EOL>", "docstring": "Cleanup resources.", "id": "f16044:c3:m3"}
{"signature": "def convert_to_single_placement_group(<EOL>self, resource_group_name, vm_scale_set_name, active_placement_group_id=None, custom_headers=None, raw=False, **operation_config):", "body": "parameters = models.VMScaleSetConvertToSinglePlacementGroupInput(active_placement_group_id=active_placement_group_id)<EOL>url = self.convert_to_single_placement_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", vm_scale_set_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT>", "docstring": "Converts SinglePlacementGroup property to false for a existing virtual\n        machine scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_scale_set_name: The name of the virtual machine scale set to\n         create or update.\n        :type vm_scale_set_name: str\n        :param active_placement_group_id: Id of the placement group in which\n         you want future virtual machine instances to be placed. To query\n         placement group Id, please use Virtual Machine Scale Set VMs - Get\n         API. If not provided, the platform will choose one with maximum number\n         of virtual machine instances.\n        :type active_placement_group_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: None or ClientRawResponse if raw=true\n        :rtype: None or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25387:c0:m34"}
{"signature": "def check_type(self, value, attr, data):", "body": "if self.many and not is_collection(value):<EOL><INDENT>raise self._not_expected_type(<EOL>value, Iterable, fields=[self], field_names=attr, data=data)<EOL><DEDENT>_check_type = super().check_type<EOL>errors = []<EOL>values = value if self.many else [value]<EOL>for idx, v in enumerate(values):<EOL><INDENT>try:<EOL><INDENT>_check_type(v, idx, values)<EOL><DEDENT>except ValidationError as err:<EOL><INDENT>errors.append(err.messages)<EOL><DEDENT><DEDENT>if errors:<EOL><INDENT>errors = errors if self.many else errors[<NUM_LIT:0>]<EOL>raise ValidationError(errors)<EOL><DEDENT>return value<EOL>", "docstring": "Validate if the value is of the type of the schema's model.\n\n        Assumes the nested schema is a ``BaseSchema``.", "id": "f10963:c0:m1"}
{"signature": "def _get_restart_timer(self):", "body": "return self.__restart_timer<EOL>", "docstring": "Getter method for restart_timer, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/state/restart_timer (decimal64)\n\n    YANG Description: Time interval in seconds after which the BGP session\nis re-established after being torn down due to exceeding\nthe max-prefix limit.", "id": "f23324:c1:m11"}
{"signature": "def _set_out_path_tear_messages(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:64>,<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__out_path_tear_messages = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for out_path_tear_messages, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/state/counters/out_path_tear_messages (yang:counter64)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_out_path_tear_messages is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_out_path_tear_messages() directly.\n\nYANG Description: Number of sent RSVP Path Tear messages", "id": "f22284:c1:m36"}
{"signature": "def _set_ipv6_interface_address(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(<EOL>allowed_type=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>)<EOL>),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ipv6_interface_address = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ipv6_interface_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/ipv6_interface_address/state/ipv6_interface_address (inet:ipv6-address)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_ipv6_interface_address is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_ipv6_interface_address() directly.\n\n    YANG Description: Contains a 16-octet IPv6 address for the interface described by\nthe containing  Extended IS Reachability TLV. This sub-TLV can\noccur multiple times.", "id": "f22817:c1:m6"}
{"signature": "def visit_if(self, node):", "body": "branches = <NUM_LIT:1><EOL>if node.orelse and len(node.orelse) > <NUM_LIT:1>:<EOL><INDENT>branches += <NUM_LIT:1><EOL><DEDENT>self.inc_branch(branches)<EOL>self.stmts += branches<EOL>", "docstring": "increments the branches counter", "id": "f18764:m1"}
{"signature": "def _get_tag64(self):", "body": "return self.__tag64<EOL>", "docstring": "Getter method for tag64, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_reachability/prefixes/prefixes/subTLVs/subTLVs/tag64/state/tag64 (uint64)\n\n    YANG Description: List of 64-bit tags associated with the prefix. Example uses of\nthese tags include carrying BGP standard (or extended) communities\nand controlling redistribution between levels and areas, different\nrouting protocols, or multiple instances of IS-IS running on the\nsame router.", "id": "f22662:c0:m5"}
{"signature": "def set_humidity(self, index, humidity):", "body": "body = {\"<STR_LIT>\": {\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": self.thermostats[index]['<STR_LIT>']},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": int(humidity)<EOL>}<EOL>}}<EOL>log_msg_action = \"<STR_LIT>\"<EOL>return self.make_request(body, log_msg_action)<EOL>", "docstring": "Set humidity level", "id": "f322:c0:m18"}
{"signature": "def set_traindata(self, training_rdd, batch_size):", "body": "callBigDlFunc(self.bigdl_type, \"<STR_LIT>\", self.value,<EOL>training_rdd, batch_size)<EOL>", "docstring": "Set new training dataset, for optimizer reuse\n\n:param training_rdd: the training dataset\n:param batch_size: training batch size\n:return:", "id": "f13264:c34:m3"}
{"signature": "def mat_to_xyz(foci, mat_dims=None, xyz_dims=None):", "body": "foci = np.hstack((foci, np.ones((foci.shape[<NUM_LIT:0>], <NUM_LIT:1>))))<EOL>mat = np.array([[-<NUM_LIT:2>, <NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT>], [<NUM_LIT:0>, <NUM_LIT:2>, <NUM_LIT:0>, -<NUM_LIT>], [<NUM_LIT:0>, <NUM_LIT:0>, <NUM_LIT:2>, -<NUM_LIT>]]).T<EOL>result = np.dot(foci, mat)[:, ::-<NUM_LIT:1>]  <EOL>return np.round_(result).astype(int)<EOL>", "docstring": "Convert an N x 3 array of matrix indices to XYZ coordinates.", "id": "f5205:m2"}
{"signature": "def findall(self, name, recursive=False):", "body": "if self.children is not None:<EOL><INDENT>for child in self.children:<EOL><INDENT>if child.name == name:<EOL><INDENT>yield child<EOL><DEDENT>if recursive:<EOL><INDENT>for atom in child.findall(name, True):<EOL><INDENT>yield atom<EOL><DEDENT><DEDENT><DEDENT><DEDENT>", "docstring": "Recursively find all child atoms by specified name.", "id": "f2193:c6:m2"}
{"signature": "def sqrt(x):", "body": "x = _fix_real_lt_zero(x)<EOL>return nx.sqrt(x)<EOL>", "docstring": "Compute the square root of x.\n\nFor negative input elements, a complex value is returned\n(unlike `numpy.sqrt` which returns NaN).\n\nParameters\n----------\nx : array_like\n   The input value(s).\n\nReturns\n-------\nout : ndarray or scalar\n   The square root of `x`. If `x` was a scalar, so is `out`,\n   otherwise an array is returned.\n\nSee Also\n--------\nnumpy.sqrt\n\nExamples\n--------\nFor real, non-negative inputs this works just like `numpy.sqrt`:\n\n>>> np.lib.scimath.sqrt(1)\n1.0\n>>> np.lib.scimath.sqrt([1, 4])\narray([ 1.,  2.])\n\nBut it automatically handles negative inputs:\n\n>>> np.lib.scimath.sqrt(-1)\n(0.0+1.0j)\n>>> np.lib.scimath.sqrt([-1,4])\narray([ 0.+1.j,  2.+0.j])", "id": "f19086:m4"}
{"signature": "def price(*args, **kwargs):", "body": "kwargs.setdefault('<STR_LIT:default>', '<STR_LIT>')<EOL>kwargs.setdefault('<STR_LIT>', price_converter)<EOL>if '<STR_LIT>' in kwargs:<EOL><INDENT>validator = kwargs.pop('<STR_LIT>')<EOL>if not isinstance(validator, (tuple, list)):<EOL><INDENT>validator = [validator]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>validator = []<EOL><DEDENT>validator.append(instance_of(PriceClass))<EOL>return attr.ib(validator=validator, *args, **kwargs)<EOL>", "docstring": "Price field for attrs.\n\n    See `help(attr.ib)` for full signature.\n\n    Usage:\n\n        >>> from pricing import fields\n        ... @attr.s\n        ... class Test:\n        ...     price: Price = fields.price(default='USD 5.00')\n        ...\n        ... Test()\n        Test(price=USD 5.00)", "id": "f11378:m1"}
{"signature": "def add_hierarchical_entity(<EOL>self, app_id, version_id, children=None, name=None, custom_headers=None, raw=False, **operation_config):", "body": "hierarchical_model_create_object = models.HierarchicalEntityModel(children=children, name=name)<EOL>url = self.add_hierarchical_entity.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.endpoint, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", app_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", version_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>body_content = self._serialize.body(hierarchical_model_create_object, '<STR_LIT>')<EOL>request = self._client.post(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>raise models.ErrorResponseException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT:str>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Adds a hierarchical entity extractor to a version of the application.\n\n        :param app_id: The application ID.\n        :type app_id: str\n        :param version_id: The version ID.\n        :type version_id: str\n        :param children: Child entities.\n        :type children: list[str]\n        :param name: Entity name.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: str or ClientRawResponse if raw=true\n        :rtype: str or ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`ErrorResponseException<azure.cognitiveservices.language.luis.authoring.models.ErrorResponseException>`", "id": "f43227:c0:m5"}
{"signature": "def _get_adjacency_sid(self):", "body": "return self.__adjacency_sid<EOL>", "docstring": "Getter method for adjacency_sid, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af/segment_routing/adjacency_sids/adjacency_sid (list)\n\n    YANG Description: An Adjacency SID to be advertised for the specified interface.\nThe Adj-SID's identifier (the SID ID) must be unique, with flags\nspecified indicating the parameters that should be set for the SID.\nWhere a SID value is specified that is allocated from the SRGB, the\nglobal flag must be set by the system.", "id": "f22445:c1:m2"}
{"signature": "def _get_subtlv_type(self):", "body": "return self.__subtlv_type<EOL>", "docstring": "Getter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/link_delay_variation/state/subtlv_type (identityref)\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22837:c1:m2"}
{"signature": "@cache(level=<NUM_LIT:10>)<EOL>def cq_to_chroma(n_input, bins_per_octave=<NUM_LIT:12>, n_chroma=<NUM_LIT:12>,<EOL>fmin=None, window=None, base_c=True, dtype=np.float32):", "body": "<EOL>n_merge = float(bins_per_octave) / n_chroma<EOL>if fmin is None:<EOL><INDENT>fmin = note_to_hz('<STR_LIT>')<EOL><DEDENT>if np.mod(n_merge, <NUM_LIT:1>) != <NUM_LIT:0>:<EOL><INDENT>raise ParameterError('<STR_LIT>'<EOL>'<STR_LIT>'<EOL>'<STR_LIT>')<EOL><DEDENT>cq_to_ch = np.repeat(np.eye(n_chroma), n_merge, axis=<NUM_LIT:1>)<EOL>cq_to_ch = np.roll(cq_to_ch, - int(n_merge // <NUM_LIT:2>), axis=<NUM_LIT:1>)<EOL>n_octaves = np.ceil(np.float(n_input) / bins_per_octave)<EOL>cq_to_ch = np.tile(cq_to_ch, int(n_octaves))[:, :n_input]<EOL>midi_0 = np.mod(hz_to_midi(fmin), <NUM_LIT:12>)<EOL>if base_c:<EOL><INDENT>roll = midi_0<EOL><DEDENT>else:<EOL><INDENT>roll = midi_0 - <NUM_LIT:9><EOL><DEDENT>roll = int(np.round(roll * (n_chroma / <NUM_LIT>)))<EOL>cq_to_ch = np.roll(cq_to_ch, roll, axis=<NUM_LIT:0>).astype(dtype)<EOL>if window is not None:<EOL><INDENT>cq_to_ch = scipy.signal.convolve(cq_to_ch,<EOL>np.atleast_2d(window),<EOL>mode='<STR_LIT>')<EOL><DEDENT>return cq_to_ch<EOL>", "docstring": "Convert a Constant-Q basis to Chroma.\n\n\n    Parameters\n    ----------\n    n_input : int > 0 [scalar]\n        Number of input components (CQT bins)\n\n    bins_per_octave : int > 0 [scalar]\n        How many bins per octave in the CQT\n\n    n_chroma : int > 0 [scalar]\n        Number of output bins (per octave) in the chroma\n\n    fmin : None or float > 0\n        Center frequency of the first constant-Q channel.\n        Default: 'C1' ~= 32.7 Hz\n\n    window : None or np.ndarray\n        If provided, the cq_to_chroma filter bank will be\n        convolved with `window`.\n\n    base_c : bool\n        If True, the first chroma bin will start at 'C'\n        If False, the first chroma bin will start at 'A'\n\n    dtype : np.dtype\n        The data type of the output basis.\n        By default, uses 32-bit (single-precision) floating point.\n\n\n    Returns\n    -------\n    cq_to_chroma : np.ndarray [shape=(n_chroma, n_input)]\n        Transformation matrix: `Chroma = np.dot(cq_to_chroma, CQT)`\n\n    Raises\n    ------\n    ParameterError\n        If `n_input` is not an integer multiple of `n_chroma`\n\n    Notes\n    -----\n    This function caches at level 10.\n\n    Examples\n    --------\n    Get a CQT, and wrap bins to chroma\n\n    >>> y, sr = librosa.load(librosa.util.example_audio_file())\n    >>> CQT = np.abs(librosa.cqt(y, sr=sr))\n    >>> chroma_map = librosa.filters.cq_to_chroma(CQT.shape[0])\n    >>> chromagram = chroma_map.dot(CQT)\n    >>> # Max-normalize each time step\n    >>> chromagram = librosa.util.normalize(chromagram, axis=0)\n\n    >>> import matplotlib.pyplot as plt\n    >>> plt.subplot(3, 1, 1)\n    >>> librosa.display.specshow(librosa.amplitude_to_db(CQT,\n    ...                                                  ref=np.max),\n    ...                          y_axis='cqt_note')\n    >>> plt.title('CQT Power')\n    >>> plt.colorbar()\n    >>> plt.subplot(3, 1, 2)\n    >>> librosa.display.specshow(chromagram, y_axis='chroma')\n    >>> plt.title('Chroma (wrapped CQT)')\n    >>> plt.colorbar()\n    >>> plt.subplot(3, 1, 3)\n    >>> chroma = librosa.feature.chroma_stft(y=y, sr=sr)\n    >>> librosa.display.specshow(chroma, y_axis='chroma', x_axis='time')\n    >>> plt.title('librosa.feature.chroma_stft')\n    >>> plt.colorbar()\n    >>> plt.tight_layout()", "id": "f18151:m5"}
{"signature": "@property<EOL><INDENT>def high(self):<DEDENT>", "body": "return self._high<EOL>", "docstring": "Upper boundary of the interval.", "id": "f15625:c0:m3"}
{"signature": "def claim_any_vm(<EOL>self, resource_group_name, name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._claim_any_vm_initial(<EOL>resource_group_name=resource_group_name,<EOL>name=name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Claim a random claimable virtual machine in the lab. This operation can\n        take a while to complete.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param name: The name of the lab.\n        :type name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f45877:c0:m10"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/fdb/mac_table/entries/entry/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration data for MAC table entries", "id": "f22105:c0:m6"}
{"signature": "def next_generation(self, mut_rate=<NUM_LIT:0>, max_mut_amt=<NUM_LIT:0>, log_base=<NUM_LIT:10>):", "body": "if self.__num_processes > <NUM_LIT:1>:<EOL><INDENT>process_pool = Pool(processes=self.__num_processes)<EOL>members = [m.get() for m in self.__members]<EOL><DEDENT>else:<EOL><INDENT>members = self.__members<EOL><DEDENT>if len(members) == <NUM_LIT:0>:<EOL><INDENT>raise Exception(<EOL>'<STR_LIT>'<EOL>)<EOL><DEDENT>selected_members = self.__select_fn(members)<EOL>reproduction_probs = list(reversed(logspace(<NUM_LIT:0.0>, <NUM_LIT:1.0>,<EOL>num=len(selected_members), base=log_base)))<EOL>reproduction_probs = reproduction_probs / sum(reproduction_probs)<EOL>self.__members = []<EOL>for _ in range(self.__pop_size):<EOL><INDENT>parent_1 = nrandom.choice(selected_members, p=reproduction_probs)<EOL>parent_2 = nrandom.choice(selected_members, p=reproduction_probs)<EOL>feed_dict = {}<EOL>for param in self.__parameters:<EOL><INDENT>which_parent = uniform(<NUM_LIT:0>, <NUM_LIT:1>)<EOL>if which_parent < <NUM_LIT:0.5>:<EOL><INDENT>feed_dict[param.name] = parent_1.parameters[param.name]<EOL><DEDENT>else:<EOL><INDENT>feed_dict[param.name] = parent_2.parameters[param.name]<EOL><DEDENT>feed_dict[param.name] = self.__mutate_parameter(<EOL>feed_dict[param.name], param, mut_rate, max_mut_amt<EOL>)<EOL><DEDENT>if self.__num_processes > <NUM_LIT:1>:<EOL><INDENT>self.__members.append(process_pool.apply_async(<EOL>self._start_process,<EOL>[self.__cost_fn, feed_dict, self.__cost_fn_args])<EOL>)<EOL><DEDENT>else:<EOL><INDENT>self.__members.append(<EOL>Member(<EOL>feed_dict,<EOL>self.__cost_fn(feed_dict, self.__cost_fn_args)<EOL>)<EOL>)<EOL><DEDENT><DEDENT>if self.__num_processes > <NUM_LIT:1>:<EOL><INDENT>process_pool.close()<EOL>process_pool.join()<EOL><DEDENT>self.__determine_best_member()<EOL>", "docstring": "Generates the next population from a previously evaluated generation\n\n        Args:\n            mut_rate (float): mutation rate for new members (0.0 - 1.0)\n            max_mut_amt (float): how much the member is allowed to mutate\n                (0.0 - 1.0, proportion change of mutated parameter)\n            log_base (int): the higher this number, the more likely the first\n                Members (chosen with supplied selection function) are chosen\n                as parents for the next generation", "id": "f11657:c2:m12"}
{"signature": "def generate(self, *arg, **kw):", "body": "for p, meth in self.plugins:<EOL><INDENT>result = None<EOL>try:<EOL><INDENT>result = meth(*arg, **kw)<EOL>if result is not None:<EOL><INDENT>for r in result:<EOL><INDENT>yield r<EOL><DEDENT><DEDENT><DEDENT>except (KeyboardInterrupt, SystemExit):<EOL><INDENT>raise<EOL><DEDENT>except:<EOL><INDENT>exc = sys.exc_info()<EOL>yield Failure(*exc)<EOL>continue<EOL><DEDENT><DEDENT>", "docstring": "Call all plugins, yielding each item in each non-None result.", "id": "f21769:c0:m5"}
{"signature": "def get_user_roles(self, user=None):", "body": "if user is None:<EOL><INDENT>user = g.user<EOL><DEDENT>if user.is_anonymous:<EOL><INDENT>public_role = appbuilder.config.get('<STR_LIT>')<EOL>return [appbuilder.security_manager.find_role(public_role)]if public_role else []<EOL><DEDENT>return user.roles<EOL>", "docstring": "Get all the roles associated with the user.\n\n:param user: the ab_user in FAB model.\n:return: a list of roles associated with the user.", "id": "f9435:c0:m2"}
{"signature": "def clinsig_human(variant_obj):", "body": "for clinsig_obj in variant_obj['<STR_LIT>']:<EOL><INDENT>if isinstance(clinsig_obj['<STR_LIT>'], int):<EOL><INDENT>link = \"<STR_LIT>\"<EOL><DEDENT>else:<EOL><INDENT>link = \"<STR_LIT>\"<EOL><DEDENT>human_str = '<STR_LIT>'<EOL>if clinsig_obj.get('<STR_LIT:value>'):<EOL><INDENT>try:<EOL><INDENT>int(clinsig_obj['<STR_LIT:value>'])<EOL>human_str = CLINSIG_MAP.get(clinsig_obj['<STR_LIT:value>'], '<STR_LIT>')<EOL><DEDENT>except ValueError:<EOL><INDENT>human_str = clinsig_obj['<STR_LIT:value>']<EOL><DEDENT><DEDENT>clinsig_obj['<STR_LIT>'] = human_str<EOL>clinsig_obj['<STR_LIT>'] = link.format(clinsig_obj['<STR_LIT>'])<EOL>yield clinsig_obj<EOL><DEDENT>", "docstring": "Convert to human readable version of CLINSIG evaluation.", "id": "f13696:m19"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv4_external_reachability/prefixes/prefixes/delay_metric/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of delay-metric.", "id": "f22558:c0:m3"}
{"signature": "@property<EOL><INDENT>def shift(self):<DEDENT>", "body": "return self._shift<EOL>", "docstring": "Shift of linear function that is exponentiated.", "id": "f15795:c0:m3"}
{"signature": "def estimate_tx_gas_with_web3(self, safe_address: str, to: str, value: int, data: bytes) -> int:", "body": "return self.ethereum_client.estimate_gas(safe_address, to, value, data, block_identifier='<STR_LIT>')<EOL>", "docstring": "Estimate tx gas using web3", "id": "f11263:c3:m18"}
{"signature": "@property<EOL><INDENT>def address(self):<DEDENT>", "body": "return self._address<EOL>", "docstring": "Gets the address of this AuthorizedSignatoryWithCompanies.\n\n\n:return: The address of this AuthorizedSignatoryWithCompanies.\n:rtype: Address", "id": "f16323:c0:m11"}
{"signature": "def function5(value=frozenset()):", "body": "return value<EOL>", "docstring": "frozenset is immutable and safe.", "id": "f18360:m4"}
{"signature": "def spherical_vert(script, radius=<NUM_LIT:1.0>, center_pt=(<NUM_LIT:0.0>, <NUM_LIT:0.0>, <NUM_LIT:0.0>)):", "body": "function = '<STR_LIT>'.format(<EOL>center_pt[<NUM_LIT:0>], center_pt[<NUM_LIT:1>], center_pt[<NUM_LIT:2>], radius)<EOL>vert_function(script, function=function)<EOL>return None<EOL>", "docstring": "Select all vertices within a spherical radius\n\n    Args:\n        radius (float): radius of the sphere\n        center_pt (3 coordinate tuple or list): center point of the sphere\n\n    Layer stack:\n        No impacts\n\n    MeshLab versions:\n        2016.12\n        1.3.4BETA", "id": "f9652:m14"}
{"signature": "def _get_srlg_membership(self):", "body": "return self.__srlg_membership<EOL>", "docstring": "Getter method for srlg_membership, mapped from YANG variable /network_instances/network_instance/mpls/te_interface_attributes/interface/config/srlg_membership (leafref)\n\n    YANG Description: list of references to named shared risk link groups that the\ninterface belongs to.", "id": "f22208:c1:m8"}
{"signature": "def _get_l3vpn_ipv6_multicast(self):", "body": "return self.__l3vpn_ipv6_multicast<EOL>", "docstring": "Getter method for l3vpn_ipv6_multicast, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)\n\nYANG Description: Multicast IPv6 L3VPN configuration options", "id": "f23322:c0:m38"}
{"signature": "def _set_ip_dscp(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=int,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:8>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ip_dscp = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ip_dscp, mapped from YANG variable /network_instances/network_instance/afts/aft/entries/entry/match/state/ip_dscp (inet:dscp)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_ip_dscp is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_ip_dscp() directly.\n\n    YANG Description: The value of the differentiated services code point (DSCP) to\nbe matched for the forwarding entry. The value is specified in\ncases where specific class-based forwarding based on IP is\nimplemented by the device.", "id": "f22122:c0:m15"}
{"signature": "def begin(self, total: int, name=None, message=None):", "body": "self.total = total<EOL>message = message or name or \"<STR_LIT>\"<EOL>self.name = name or \"<STR_LIT>\"<EOL>self.update(<NUM_LIT:0>, message)<EOL>", "docstring": "Call before starting work on a monitor, specifying name and amount of work", "id": "f11665:c0:m1"}
{"signature": "def remove(self, value):", "body": "if value not in self:<EOL><INDENT>raise KeyError(value)<EOL><DEDENT>self.discard(value)<EOL>", "docstring": "Remove an element. If not a member, raise a KeyError.", "id": "f17319:c7:m2"}
{"signature": "@internal<EOL><INDENT>def serialzeValueToTCL(self, val, do_eval=False) -> Tuple[str, str, bool]:<DEDENT>", "body": "if isinstance(val, int):<EOL><INDENT>val = hInt(val)<EOL><DEDENT>if do_eval:<EOL><INDENT>val = val.staticEval()<EOL><DEDENT>if isinstance(val, RtlSignalBase):<EOL><INDENT>ctx = VivadoTclExpressionSerializer.getBaseContext()<EOL>tclVal = VivadoTclExpressionSerializer.asHdl(val, ctx)<EOL>tclValVal = VivadoTclExpressionSerializer.asHdl(<EOL>val.staticEval())<EOL>return tclVal, tclValVal, False<EOL><DEDENT>else:<EOL><INDENT>tclVal = VivadoTclExpressionSerializer.asHdl(val, None)<EOL>return tclVal, tclVal, True<EOL><DEDENT>", "docstring": ":see: doc of method on parent class", "id": "f1386:c1:m16"}
{"signature": "def create_or_update_at_management_group(<EOL>self, policy_definition_name, parameters, management_group_id, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.create_or_update_at_management_group.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", policy_definition_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", management_group_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>body_content = self._serialize.body(parameters, '<STR_LIT>')<EOL>request = self._client.put(url, query_parameters, header_parameters, body_content)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Creates or updates a policy definition at management group level.\n\n        :param policy_definition_name: The name of the policy definition to\n         create.\n        :type policy_definition_name: str\n        :param parameters: The policy definition properties.\n        :type parameters:\n         ~azure.mgmt.resource.policy.v2016_12_01.models.PolicyDefinition\n        :param management_group_id: The ID of the management group.\n        :type management_group_id: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: PolicyDefinition or ClientRawResponse if raw=true\n        :rtype:\n         ~azure.mgmt.resource.policy.v2016_12_01.models.PolicyDefinition or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f37403:c0:m5"}
{"signature": "def unapply_all(self, force=False):", "body": "self._check(force)<EOL>for patch in reversed(self.db.applied_patches()):<EOL><INDENT>self._unapply_patch(patch)<EOL><DEDENT>self.db.save()<EOL>self.unapplied(self.db.top_patch())<EOL>", "docstring": "Unapply all patches", "id": "f14379:c0:m5"}
{"signature": "def delete(<EOL>self, resource_group_name, express_route_gateway_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>express_route_gateway_name=express_route_gateway_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified ExpressRoute gateway in a resource group. An\n        ExpressRoute gateway resource can only be deleted when there are no\n        connection subresources.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param express_route_gateway_name: The name of the ExpressRoute\n         gateway.\n        :type express_route_gateway_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f30271:c0:m7"}
{"signature": "def get_font(family, fallback=None):", "body": "font = QtGui.QFont(family)<EOL>font_info = QtGui.QFontInfo(font)<EOL>if fallback is not None and font_info.family() != family:<EOL><INDENT>font = QtGui.QFont(fallback)<EOL><DEDENT>return font<EOL>", "docstring": "Return a font of the requested family, using fallback as alternative.\n\n    If a fallback is provided, it is used in case the requested family isn't\n    found.  If no fallback is given, no alternative is chosen and Qt's internal\n    algorithms may automatically choose a fallback font.\n\n    Parameters\n    ----------\n    family : str\n      A font name.\n    fallback : str\n      A font name.\n\n    Returns\n    -------\n    font : QFont object", "id": "f21636:m0"}
{"signature": "def tuple_cast(inputs, dst_type):", "body": "return iter_cast(inputs, dst_type, return_type=tuple)<EOL>", "docstring": "Cast elements of an iterable object into a tuple of some type.\n\n    A partial method of :func:`iter_cast`.", "id": "f14501:m3"}
{"signature": "def books(self, pair):", "body": "key = ('<STR_LIT>', pair)<EOL>return self.queue_processor.books[key]<EOL>", "docstring": "Return a queue containing all received book data.\n\n        :param pair:\n        :return: Queue()", "id": "f9862:c0:m7"}
{"signature": "def list_query_results_for_subscription(<EOL>self, subscription_id, query_options=None, custom_headers=None, raw=False, **operation_config):", "body": "top = None<EOL>if query_options is not None:<EOL><INDENT>top = query_options.top<EOL><DEDENT>filter = None<EOL>if query_options is not None:<EOL><INDENT>filter = query_options.filter<EOL><DEDENT>def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_query_results_for_subscription.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.policy_tracked_resources_resource, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if top is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", top, '<STR_LIT:int>', minimum=<NUM_LIT:0>)<EOL><DEDENT>if filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", filter, '<STR_LIT:str>')<EOL><DEDENT><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.QueryFailureException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.PolicyTrackedResourcePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.PolicyTrackedResourcePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Queries policy tracked resources under the subscription.\n\n        :param subscription_id: Microsoft Azure subscription ID.\n        :type subscription_id: str\n        :param query_options: Additional parameters for the operation\n        :type query_options: ~azure.mgmt.policyinsights.models.QueryOptions\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of PolicyTrackedResource\n        :rtype:\n         ~azure.mgmt.policyinsights.models.PolicyTrackedResourcePaged[~azure.mgmt.policyinsights.models.PolicyTrackedResource]\n        :raises:\n         :class:`QueryFailureException<azure.mgmt.policyinsights.models.QueryFailureException>`", "id": "f36918:c0:m2"}
{"signature": "def argsreduce(cond, *args):", "body": "newargs = np.atleast_1d(*args)<EOL>if not isinstance(newargs, list):<EOL><INDENT>newargs = [newargs, ]<EOL><DEDENT>expand_arr = (cond == cond)<EOL>return [np.extract(cond, arr1 * expand_arr) for arr1 in newargs]<EOL>", "docstring": "Return the sequence of ravel(args[i]) where ravel(condition) is\n    True in 1D.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> rand = np.random.random_sample\n    >>> A = rand((4, 5))\n    >>> B = 2\n    >>> C = rand((1, 5))\n    >>> cond = np.ones(A.shape)\n    >>> [A1, B1, C1] = argsreduce(cond, A, B, C)\n    >>> B1.shape\n    (20,)\n    >>> cond[2,:] = 0\n    >>> [A2, B2, C2] = argsreduce(cond, A, B, C)\n    >>> B2.shape\n    (15,)", "id": "f19688:m6"}
{"signature": "def __init__(self, validations=VALIDATIONS, log_format=SIMPLE_FORMAT, level=logging.INFO, stdout=False, raw=False):", "body": "self.raw = raw<EOL>self.log = logging.getLogger(type(self).__name__)<EOL>self.log.setLevel(level)<EOL>self.handler = LogHandler()<EOL>self.handler.setFormatter(logging.Formatter(log_format))<EOL>self.log.addHandler(self.handler)<EOL>if stdout:<EOL><INDENT>strhdlr = logging.StreamHandler(sys.stdout)<EOL>strhdlr.setFormatter(logging.Formatter(log_format))<EOL>self.log.addHandler(strhdlr)<EOL><DEDENT>self.validations = [validation(self.log) for validation in validations]<EOL>", "docstring": "Initialize a Validator with the following parameters:\n\n        :param validations: A list of Validations to apply (default: :data:`~molvs.validations.VALIDATIONS`).\n        :param string log_format: A string format (default: :data:`~molvs.validate.SIMPLE_FORMAT`).\n        :param level: The minimum logging level to output.\n        :param bool stdout: Whether to send log messages to standard output.\n        :param bool raw: Whether to return raw :class:`~logging.LogRecord` objects instead of formatted log strings.", "id": "f16473:c1:m0"}
{"signature": "@property<EOL><INDENT>def ignore_urls(self):<DEDENT>", "body": "return self._ignore_urls<EOL>", "docstring": "Get ignore_urls", "id": "f14591:c1:m13"}
{"signature": "def _set_admin_groups(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=admin_groups.admin_groups,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__admin_groups = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for admin_groups, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_secondary_paths/p2p_secondary_path/admin_groups (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_admin_groups is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_admin_groups() directly.\n\n    YANG Description: Top-level container for include/exclude constraints for\nlink affinities", "id": "f22262:c0:m12"}
{"signature": "def create_invalid_extra_args(self):", "body": "raise NotImplementedError(<EOL>'<STR_LIT>')<EOL>", "docstring": "A value for extra_args that will cause validation errors", "id": "f10169:c10:m3"}
{"signature": "def _get_value(self):", "body": "return self.__value<EOL>", "docstring": "Getter method for value, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/lan_adjacency_sid/sid/state/value (uint32)\n\nYANG Description: LAN Adjacency-SID value.", "id": "f22615:c0:m2"}
{"signature": "@property<EOL><INDENT>def items(self) -> List[str]:<DEDENT>", "body": "items = []  <EOL>append = items.append<EOL>string = self.string<EOL>match = self._match<EOL>ms = match.start()<EOL>for s, e in match.spans('<STR_LIT>'):<EOL><INDENT>append(string[s - ms:e - ms])<EOL><DEDENT>return items<EOL>", "docstring": "Return items as a list of strings.\n\n        Don't include sub-items and the start pattern.", "id": "f8140:c0:m2"}
{"signature": "def _compose_subsystem(self, other, qargs, front=False):", "body": "<EOL>input_dims = list(self.input_dims())<EOL>output_dims = list(self.output_dims())<EOL>if front:<EOL><INDENT>num_indices = len(self.input_dims())<EOL>shift = len(self.output_dims())<EOL>right_mul = True<EOL>for pos, qubit in enumerate(qargs):<EOL><INDENT>input_dims[qubit] = other._input_dims[pos]<EOL><DEDENT><DEDENT>else:<EOL><INDENT>num_indices = len(self.output_dims())<EOL>shift = <NUM_LIT:0><EOL>right_mul = False<EOL>for pos, qubit in enumerate(qargs):<EOL><INDENT>output_dims[qubit] = other._output_dims[pos]<EOL><DEDENT><DEDENT>tensor = np.reshape(self.data, self._shape)<EOL>mat = np.reshape(other.data, other._shape)<EOL>indices = [num_indices - <NUM_LIT:1> - qubit for qubit in qargs]<EOL>final_shape = [np.product(output_dims), np.product(input_dims)]<EOL>data = np.reshape(<EOL>self._einsum_matmul(tensor, mat, indices, shift, right_mul),<EOL>final_shape)<EOL>return Operator(data, input_dims, output_dims)<EOL>", "docstring": "Return the composition channel.", "id": "f10798:c0:m16"}
{"signature": "def _set_identifier(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__identifier = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for identifier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/config/identifier (identityref)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_identifier is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_identifier() directly.\n\nYANG Description: The protocol identifier for the instance", "id": "f22392:c0:m3"}
{"signature": "def _get_undefined_subtlvs(self):", "body": "return self.__undefined_subtlvs<EOL>", "docstring": "Getter method for undefined_subtlvs, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/undefined_subtlvs (container)\n\nYANG Description: This container describes undefined ISIS TLVs.", "id": "f22819:c0:m8"}
{"signature": "def addfield(mrecord, newfield, newfieldname=None):", "body": "_data = mrecord._data<EOL>_mask = mrecord._mask<EOL>if newfieldname is None or newfieldname in reserved_fields:<EOL><INDENT>newfieldname = '<STR_LIT>' % len(_data.dtype)<EOL><DEDENT>newfield = ma.array(newfield)<EOL>newdtype = np.dtype(_data.dtype.descr + [(newfieldname, newfield.dtype)])<EOL>newdata = recarray(_data.shape, newdtype)<EOL>[newdata.setfield(_data.getfield(*f), *f)<EOL>for f in _data.dtype.fields.values()]<EOL>newdata.setfield(newfield._data, *newdata.dtype.fields[newfieldname])<EOL>newdata = newdata.view(MaskedRecords)<EOL>newmdtype = np.dtype([(n, bool_) for n in newdtype.names])<EOL>newmask = recarray(_data.shape, newmdtype)<EOL>[newmask.setfield(_mask.getfield(*f), *f)<EOL>for f in _mask.dtype.fields.values()]<EOL>newmask.setfield(getmaskarray(newfield),<EOL>*newmask.dtype.fields[newfieldname])<EOL>newdata._mask = newmask<EOL>return newdata<EOL>", "docstring": "Adds a new field to the masked record array, using `newfield` as data\nand `newfieldname` as name. If `newfieldname` is None, the new field name is\nset to 'fi', where `i` is the number of existing fields.", "id": "f18990:m9"}
{"signature": "@classmethod<EOL><INDENT>def create_profile_dir_by_name(cls, path, name='<STR_LIT:default>', config=None):<DEDENT>", "body": "if not os.path.isdir(path):<EOL><INDENT>raise ProfileDirError('<STR_LIT>' % path)<EOL><DEDENT>profile_dir = os.path.join(path, '<STR_LIT>' + name)<EOL>return cls(location=profile_dir, config=config)<EOL>", "docstring": "Create a profile dir by profile name and path.\n\n        Parameters\n        ----------\n        path : unicode\n            The path (directory) to put the profile directory in.\n        name : unicode\n            The name of the profile.  The name of the profile directory will\n            be \"profile_<profile>\".", "id": "f21441:c1:m12"}
{"signature": "def parse_matches(patient_id, match_objs):", "body": "LOG.info('<STR_LIT>'.format(patient_id))<EOL>parsed_matches = []<EOL>for match_obj in match_objs:<EOL><INDENT>milliseconds_date = match_obj['<STR_LIT>']['<STR_LIT>']<EOL>mdate = datetime.datetime.fromtimestamp(milliseconds_date/<NUM_LIT>)<EOL>match_type = '<STR_LIT>'<EOL>matching_patients = []<EOL>parsed_match = {<EOL>'<STR_LIT>' : match_obj['<STR_LIT>']['<STR_LIT>'],<EOL>'<STR_LIT>' : mdate<EOL>}<EOL>if match_obj['<STR_LIT:data>']['<STR_LIT>']['<STR_LIT:id>'] == patient_id:<EOL><INDENT>match_results = match_obj['<STR_LIT>'] <EOL>for node_result in match_results:<EOL><INDENT>if match_obj['<STR_LIT>'] == '<STR_LIT>':<EOL><INDENT>match_type = '<STR_LIT>'<EOL><DEDENT>for patient in node_result['<STR_LIT>']:<EOL><INDENT>match_patient = {<EOL>'<STR_LIT>' : patient['<STR_LIT>']['<STR_LIT:id>'],<EOL>'<STR_LIT>' : patient['<STR_LIT>'],<EOL>'<STR_LIT>' : patient['<STR_LIT>'],<EOL>'<STR_LIT>' : node_result['<STR_LIT>']<EOL>}<EOL>matching_patients.append(match_patient)<EOL><DEDENT><DEDENT><DEDENT>else: <EOL><INDENT>m_patient = match_obj['<STR_LIT:data>']['<STR_LIT>']<EOL>contact_institution = m_patient['<STR_LIT>'].get('<STR_LIT>')<EOL>if contact_institution and '<STR_LIT>' in contact_institution:<EOL><INDENT>match_type = '<STR_LIT>'<EOL><DEDENT>score = None<EOL>for res in match_obj['<STR_LIT>']:<EOL><INDENT>for patient in res['<STR_LIT>']:<EOL><INDENT>LOG.info('<STR_LIT>'.format(patient['<STR_LIT>']['<STR_LIT:id>']))<EOL>if patient['<STR_LIT>']['<STR_LIT:id>'] == patient_id:<EOL><INDENT>score = patient['<STR_LIT>']<EOL>match_patient = {<EOL>'<STR_LIT>' : m_patient['<STR_LIT:id>'],<EOL>'<STR_LIT>' : score,<EOL>'<STR_LIT>' : m_patient,<EOL>'<STR_LIT>' : res['<STR_LIT>']<EOL>}<EOL>matching_patients.append(match_patient)<EOL><DEDENT><DEDENT><DEDENT><DEDENT>parsed_match['<STR_LIT>'] = match_type<EOL>parsed_match['<STR_LIT>'] = matching_patients<EOL>parsed_matches.append(parsed_match)<EOL><DEDENT>parsed_matches = sorted(parsed_matches, key=lambda k: k['<STR_LIT>'], reverse=True)<EOL>return parsed_matches<EOL>", "docstring": "Parse a list of matchmaker matches objects and returns\n       a readable list of matches to display in matchmaker matches view.\n\n    Args:\n        patient_id(str): id of a mme patient\n        match_objs(list): list of match objs returned by MME server for the patient\n                # match_objs looks like this:\n                    [\n                        {\n                            'node' : { id : node_id , label: node_label},\n                            'patients' : [\n                                { 'patient': {patient1_data} },\n                                { 'patient': {patient2_data} },\n                                ..\n                            ]\n                        },\n                        ..\n                    ]\n\n    Returns:\n        parsed_matches(list): a list of parsed match objects", "id": "f13845:m3"}
{"signature": "def bessel(N, Wn, btype='<STR_LIT>', analog=False, output='<STR_LIT>'):", "body": "return iirfilter(N, Wn, btype=btype, analog=analog,<EOL>output=output, ftype='<STR_LIT>')<EOL>", "docstring": "Bessel/Thomson digital and analog filter design.\n\n    Design an Nth order digital or analog Bessel filter and return the\n    filter coefficients in (B,A) or (Z,P,K) form.\n\n    Parameters\n    ----------\n    N : int\n        The order of the filter.\n    Wn : array_like\n        A scalar or length-2 sequence giving the critical frequencies.\n        For a Bessel filter, this is defined as the point at which the\n        asymptotes of the response are the same as a Butterworth filter of\n        the same order.\n        For digital filters, `Wn` is normalized from 0 to 1, where 1 is the\n        Nyquist frequency, pi radians/sample.  (`Wn` is thus in\n        half-cycles / sample.)\n        For analog filters, `Wn` is an angular frequency (e.g. rad/s).\n    btype : {'lowpass', 'highpass', 'bandpass', 'bandstop'}, optional\n        The type of filter.  Default is 'lowpass'.\n    analog : bool, optional\n        When True, return an analog filter, otherwise a digital filter is\n        returned.\n    output : {'ba', 'zpk'}, optional\n        Type of output:  numerator/denominator ('ba') or pole-zero ('zpk').\n        Default is 'ba'.\n\n    Returns\n    -------\n    b, a : ndarray, ndarray\n        Numerator (`b`) and denominator (`a`) polynomials of the IIR filter.\n        Only returned if ``output='ba'``.\n    z, p, k : ndarray, ndarray, float\n        Zeros, poles, and system gain of the IIR filter transfer\n        function.  Only returned if ``output='zpk'``.\n\n    Notes\n    -----\n    Also known as a Thomson filter, the analog Bessel filter has maximally\n    flat group delay and maximally linear phase response, with very little\n    ringing in the step response.\n\n    As order increases, the Bessel filter approaches a Gaussian filter.\n\n    The digital Bessel filter is generated using the bilinear\n    transform, which does not preserve the phase response of the analog\n    filter. As such, it is only approximately correct at frequencies\n    below about fs/4.  To get maximally flat group delay at higher\n    frequencies, the analog Bessel filter must be transformed using\n    phase-preserving techniques.\n\n    For a given `Wn`, the lowpass and highpass filter have the same phase vs\n    frequency curves; they are \"phase-matched\".\n\n    Examples\n    --------\n    Plot the filter's frequency response, showing the flat group delay and\n    the relationship to the Butterworth's cutoff frequency:\n\n    >>> from scipy import signal\n    >>> import matplotlib.pyplot as plt\n\n    >>> b, a = signal.butter(4, 100, 'low', analog=True)\n    >>> w, h = signal.freqs(b, a)\n    >>> plt.plot(w, 20 * np.log10(np.abs(h)), color='silver', ls='dashed')\n    >>> b, a = signal.bessel(4, 100, 'low', analog=True)\n    >>> w, h = signal.freqs(b, a)\n    >>> plt.semilogx(w, 20 * np.log10(np.abs(h)))\n    >>> plt.title('Bessel filter frequency response (with Butterworth)')\n    >>> plt.xlabel('Frequency [radians / second]')\n    >>> plt.ylabel('Amplitude [dB]')\n    >>> plt.margins(0, 0.1)\n    >>> plt.grid(which='both', axis='both')\n    >>> plt.axvline(100, color='green') # cutoff frequency\n    >>> plt.show()\n\n    >>> plt.figure()\n    >>> plt.semilogx(w[1:], -np.diff(np.unwrap(np.angle(h)))/np.diff(w))\n    >>> plt.title('Bessel filter group delay')\n    >>> plt.xlabel('Frequency [radians / second]')\n    >>> plt.ylabel('Group delay [seconds]')\n    >>> plt.margins(0, 0.1)\n    >>> plt.grid(which='both', axis='both')\n    >>> plt.show()", "id": "f19255:m23"}
{"signature": "def parse_old_menu(menu_data):", "body": "menu_title = menu_data['<STR_LIT:title>']<EOL>menu = CursesMenu(menu_title)<EOL>for item in menu_data[\"<STR_LIT>\"]:<EOL><INDENT>item_type = item[\"<STR_LIT:type>\"]<EOL>item_title = item[\"<STR_LIT:title>\"]<EOL>if item_type == menuItem.COMMAND:<EOL><INDENT>item_command = item[\"<STR_LIT>\"]<EOL>menu.append_item(CommandItem(item_title, item_command, menu))<EOL><DEDENT>elif item_type == menuItem.FUNCTION:<EOL><INDENT>item_function = item[\"<STR_LIT>\"]<EOL>menu.append_item(FunctionItem(item_title, item_function, menu))<EOL><DEDENT>elif item_type == menuItem.EXITMENU:<EOL><INDENT>menu.append_item(ExitItem(item_title, menu))<EOL><DEDENT>elif item_type == menuItem.NUMBER:<EOL><INDENT>menu.append_item(SelectionItem(item_title, menu))<EOL><DEDENT>elif item_type == menuItem.MENU:<EOL><INDENT>new_menu = parse_old_menu(item)<EOL>menu.append_item(SubmenuItem(item_title, menu, new_menu))<EOL><DEDENT><DEDENT>return menu<EOL>", "docstring": "Take an old-style menuData dictionary and return a CursesMenu\n\n:param dict menu_data:\n:return: A new CursesMenu\n:rtype: CursesMenu", "id": "f15362:m0"}
{"signature": "def _set_igp_ldp_sync(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=igp_ldp_sync.igp_ldp_sync,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__igp_ldp_sync = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for igp_ldp_sync, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls/igp_ldp_sync (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_igp_ldp_sync is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_igp_ldp_sync() directly.\n\n    YANG Description: Configuration and operational state relating to synchronisation\nbetween the LDP and IS-IS", "id": "f22502:c0:m3"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/mpls/signaling_protocols/rsvp_te/interface_attributes/interface/interface_ref/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: Operational state for interface-ref", "id": "f22291:c1:m6"}
{"signature": "def get_components(self):", "body": "result = []<EOL>for i in range(_lib.X509_NAME_entry_count(self._name)):<EOL><INDENT>ent = _lib.X509_NAME_get_entry(self._name, i)<EOL>fname = _lib.X509_NAME_ENTRY_get_object(ent)<EOL>fval = _lib.X509_NAME_ENTRY_get_data(ent)<EOL>nid = _lib.OBJ_obj2nid(fname)<EOL>name = _lib.OBJ_nid2sn(nid)<EOL>value = _ffi.buffer(_lib.ASN1_STRING_data(fval),<EOL>_lib.ASN1_STRING_length(fval))[:]<EOL>result.append((_ffi.string(name), value))<EOL><DEDENT>return result<EOL>", "docstring": "Returns the components of this name, as a sequence of 2-tuples.\n\n:return: The components of this name.\n:rtype: :py:class:`list` of ``name, value`` tuples.", "id": "f4638:c4:m7"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>name=name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Create or update a VM scale set.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param name: The name of the VM scale set to create or update.\n        :type name: str\n        :param parameters: The scale set object.\n        :type parameters:\n         ~azure.mgmt.compute.v2016_03_30.models.VirtualMachineScaleSet\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns VirtualMachineScaleSet\n         or ClientRawResponse<VirtualMachineScaleSet> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2016_03_30.models.VirtualMachineScaleSet]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2016_03_30.models.VirtualMachineScaleSet]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25516:c0:m2"}
{"signature": "def _parse_octet(self, octet_str):", "body": "if not octet_str:<EOL><INDENT>raise ValueError(\"<STR_LIT>\")<EOL><DEDENT>if not self._DECIMAL_DIGITS.issuperset(octet_str):<EOL><INDENT>msg = \"<STR_LIT>\"<EOL>raise ValueError(msg % octet_str)<EOL><DEDENT>if len(octet_str) > <NUM_LIT:3>:<EOL><INDENT>msg = \"<STR_LIT>\"<EOL>raise ValueError(msg % octet_str)<EOL><DEDENT>octet_int = int(octet_str, <NUM_LIT:10>)<EOL>if octet_int > <NUM_LIT:7> and octet_str[<NUM_LIT:0>] == '<STR_LIT:0>':<EOL><INDENT>msg = \"<STR_LIT>\"<EOL>raise ValueError(msg % octet_str)<EOL><DEDENT>if octet_int > <NUM_LIT:255>:<EOL><INDENT>raise ValueError(\"<STR_LIT>\" % octet_int)<EOL><DEDENT>return octet_int<EOL>", "docstring": "Convert a decimal octet into an integer.\n\n        Args:\n            octet_str: A string, the number to parse.\n\n        Returns:\n            The octet as an integer.\n\n        Raises:\n            ValueError: if the octet isn't strictly a decimal from [0..255].", "id": "f17305:c6:m3"}
{"signature": "def get_quota(self):", "body": "return op.itemgetter('<STR_LIT>', '<STR_LIT>')(super(OneDriveAPI, self).get_quota())<EOL>", "docstring": "Return tuple of (bytes_available, bytes_quota).", "id": "f1114:c11:m1"}
{"signature": "def list_build_arguments(<EOL>self, resource_group_name, registry_name, build_task_name, step_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list_build_arguments.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", registry_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", build_task_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", step_name, '<STR_LIT:str>', max_length=<NUM_LIT:50>, min_length=<NUM_LIT:5>, pattern=r'<STR_LIT>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.BuildArgumentPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.BuildArgumentPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "List the build arguments for a step including the secret arguments.\n\n        :param resource_group_name: The name of the resource group to which\n         the container registry belongs.\n        :type resource_group_name: str\n        :param registry_name: The name of the container registry.\n        :type registry_name: str\n        :param build_task_name: The name of the container registry build task.\n        :type build_task_name: str\n        :param step_name: The name of a build step for a container registry\n         build task.\n        :type step_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of BuildArgument\n        :rtype:\n         ~azure.mgmt.containerregistry.v2018_02_01_preview.models.BuildArgumentPaged[~azure.mgmt.containerregistry.v2018_02_01_preview.models.BuildArgument]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f24087:c0:m9"}
{"signature": "def _api_url(self, path, **context):", "body": "if self.host == '<STR_LIT>':<EOL><INDENT>baseurl = \"<STR_LIT>\"<EOL><DEDENT>else:<EOL><INDENT>baseurl = \"<STR_LIT>\".format(self.host)<EOL><DEDENT>return baseurl + path.format(**context)<EOL>", "docstring": "Build the full url to the API endpoint", "id": "f5482:c0:m1"}
{"signature": "def _set_local_(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=local_.local_,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__local_ = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for local_, mapped from YANG variable /network_instances/network_instance/connection_points/connection_point/endpoints/endpoint/local (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_local_ is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_local_() directly.\n\n    YANG Description: Configuration and operational state parameters\nrelating to a local interface", "id": "f22352:c1:m12"}
{"signature": "def __init__(self, version=None, cookies = None):", "body": "self.version = version<EOL>self._infoset = None<EOL>self.cookies = cookies<EOL>", "docstring": "Initialize\n        @type version: string\n        @param version: WCS Version parameter e.g '1.0.0'", "id": "f4787:c2:m0"}
{"signature": "def __init__(self, api_key, domain, start_month, end_month,<EOL>time_granularity=\"<STR_LIT>\", main_domain_only=False):", "body": "self.domain = utils.domain_from_url(domain)<EOL>self.start_month = start_month<EOL>self.end_month = end_month<EOL>self.time_granularity = time_granularity<EOL>self.main_domain_only = main_domain_only<EOL>super(TrafficAPI, self).__init__(api_key)<EOL>", "docstring": "Parameters\n----------\napi_key: string\n    SimilarWeb API key\n\ndomain: string\n    Domain to query.\n\nstart_month: string\n    Start Month in (M-YYYY) format\n\nend_month: string\n    End Month in (M-YYYY) format\n\ntime_granularity: string\n    Time granularity of report. Can be: Daily, Weekly, Monthly\n\nmain_domain_only: boolean\n    Get metrics on the Main Domain only (i.e. not including subdomains)", "id": "f4346:c1:m0"}
{"signature": "def _check_format_string(self, node, format_arg):", "body": "num_args = _count_supplied_tokens(node.args[format_arg + <NUM_LIT:1> :])<EOL>if not num_args:<EOL><INDENT>return<EOL><DEDENT>format_string = node.args[format_arg].value<EOL>if not isinstance(format_string, str):<EOL><INDENT>required_num_args = <NUM_LIT:0><EOL><DEDENT>else:<EOL><INDENT>try:<EOL><INDENT>if self._format_style == \"<STR_LIT>\":<EOL><INDENT>keyword_args, required_num_args, _, _ = utils.parse_format_string(<EOL>format_string<EOL>)<EOL>if keyword_args:<EOL><INDENT>return<EOL><DEDENT><DEDENT>elif self._format_style == \"<STR_LIT>\":<EOL><INDENT>keyword_arguments, implicit_pos_args, explicit_pos_args = utils.parse_format_method_string(<EOL>format_string<EOL>)<EOL>keyword_args_cnt = len(<EOL>set(k for k, l in keyword_arguments if not isinstance(k, int))<EOL>)<EOL>required_num_args = (<EOL>keyword_args_cnt + implicit_pos_args + explicit_pos_args<EOL>)<EOL><DEDENT><DEDENT>except utils.UnsupportedFormatCharacter as ex:<EOL><INDENT>char = format_string[ex.index]<EOL>self.add_message(<EOL>\"<STR_LIT>\",<EOL>node=node,<EOL>args=(char, ord(char), ex.index),<EOL>)<EOL>return<EOL><DEDENT>except utils.IncompleteFormatString:<EOL><INDENT>self.add_message(\"<STR_LIT>\", node=node)<EOL>return<EOL><DEDENT><DEDENT>if num_args > required_num_args:<EOL><INDENT>self.add_message(\"<STR_LIT>\", node=node)<EOL><DEDENT>elif num_args < required_num_args:<EOL><INDENT>self.add_message(\"<STR_LIT>\", node=node)<EOL><DEDENT>", "docstring": "Checks that format string tokens match the supplied arguments.\n\n        Args:\n          node (astroid.node_classes.NodeNG): AST node to be checked.\n          format_arg (int): Index of the format string in the node arguments.", "id": "f18863:c0:m7"}
{"signature": "@abstractmethod<EOL><INDENT>def get_output_types(self):<DEDENT>", "body": "", "docstring": ":return: Return an array of the types of outputs this notification produces. This is used to check the\ndisplay that's been configured can handle all the types of outputs the notification could produce.", "id": "f18102:c0:m5"}
{"signature": "def _set_state(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=state.state,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT:state>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__state = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_reachability/prefixes/prefixes/subTLVs/subTLVs/ipv4_source_router_id/state (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_state is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_state() directly.\n\nYANG Description: State parameters of sub-TLV 11.", "id": "f22665:c0:m3"}
{"signature": "def delete(<EOL>self, resource_group_name, route_table_name, route_name, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._delete_initial(<EOL>resource_group_name=resource_group_name,<EOL>route_table_name=route_table_name,<EOL>route_name=route_name,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(None, response)<EOL>return client_raw_response<EOL><DEDENT><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Deletes the specified route from a route table.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param route_table_name: The name of the route table.\n        :type route_table_name: str\n        :param route_name: The name of the route.\n        :type route_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns None or\n         ClientRawResponse<None> if raw==True\n        :rtype: ~msrestazure.azure_operation.AzureOperationPoller[None] or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[None]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32305:c0:m2"}
{"signature": "def __init__(self, nonce_id=None, nonce_value=None):", "body": "super(Nonce, self).__init__(tag=enums.Tags.NONCE)<EOL>self._nonce_id = None<EOL>self._nonce_value = None<EOL>self.nonce_id = nonce_id<EOL>self.nonce_value = nonce_value<EOL>", "docstring": "Construct a Nonce struct.\n\nArgs:\n    nonce_id (bytes): A binary string representing the ID of the nonce\n        value. Optional, defaults to None. Required for encoding and\n        decoding.\n    nonce_value (bytes): A binary string representing a random value.\n        Optional, defaults to None. Required for encoding and decoding.", "id": "f15080:c3:m0"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualNetworkGatewayPaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualNetworkGatewayPaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets all virtual network gateways by resource group.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualNetworkGateway\n        :rtype:\n         ~azure.mgmt.network.v2018_08_01.models.VirtualNetworkGatewayPaged[~azure.mgmt.network.v2018_08_01.models.VirtualNetworkGateway]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f31705:c0:m8"}
{"signature": "def backwards(self, orm):", "body": "", "docstring": "Write your backwards methods here.", "id": "f11707:c0:m1"}
{"signature": "def __missing__(self,  key):", "body": "self[key] = load(key, self.namespace)<EOL>return self[key]<EOL>", "docstring": "If not already loaded, attempt to load the reference.", "id": "f4533:c0:m1"}
{"signature": "def _get_peer_group(self):", "body": "return self.__peer_group<EOL>", "docstring": "Getter method for peer_group, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/state/peer_group (leafref)\n\nYANG Description: The peer-group with which this neighbor is associated", "id": "f23273:c1:m2"}
{"signature": "@line_magic<EOL><INDENT>def page(self, parameter_s='<STR_LIT>'):<DEDENT>", "body": "<EOL>opts, args = self.parse_options(parameter_s, '<STR_LIT:r>')<EOL>raw = '<STR_LIT:r>' in opts<EOL>oname = args and args or '<STR_LIT:_>'<EOL>info = self.shell._ofind(oname)<EOL>if info['<STR_LIT>']:<EOL><INDENT>txt = (raw and str or pformat)( info['<STR_LIT>'] )<EOL>page.page(txt)<EOL><DEDENT>else:<EOL><INDENT>print('<STR_LIT>' % oname)<EOL><DEDENT>", "docstring": "Pretty print the object and display it through a pager.\n\n        %page [options] OBJECT\n\n        If no object is given, use _ (last output).\n\n        Options:\n\n          -r: page str(object), don't pretty-print it.", "id": "f21428:c0:m5"}
{"signature": "def declare_set(self, name, sep=os.pathsep):", "body": "self._declare_special(name, sep, SetVariable)<EOL>", "docstring": "Declare an environment variable as a set-like special variable.\nThis can be used even if the environment variable is not\npresent.\n\n:param name: The name of the environment variable that should\n             be considered set-like.\n:param sep: The separator to be used.  Defaults to the value\n            of ``os.pathsep``.", "id": "f1150:c3:m7"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /interfaces/interface/routed_vlan/ipv4/unnumbered/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration data for unnumbered interface", "id": "f22028:c0:m3"}
{"signature": "def clbits(self):", "body": "return [cbit for creg in self.cregs for cbit in creg]<EOL>", "docstring": "Returns a list of classical bits in the order that the registers had been added.", "id": "f10739:c0:m12"}
{"signature": "def _set_mtu(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=RestrictedClassType(<EOL>base_type=long,<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>int_size=<NUM_LIT:32>,<EOL>),<EOL>restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__mtu = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for mtu, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/state/mtu (uint32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_mtu is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_mtu() directly.\n\n    YANG Description: [adapted from IETF IP model RFC 7277]\n\nThe size, in octets, of the largest IPv6 packet that the\ninterface will send and receive.\n\nThe server may restrict the allowed values for this leaf,\ndepending on the interface's type.\n\nIf this leaf is not configured, the operationally used MTU\ndepends on the interface's type.", "id": "f21972:c0:m6"}
{"signature": "def rotate(image, **kwargs):", "body": "image.rotate(**kwargs)<EOL>return image<EOL>", "docstring": "Rotates an argument by X degrees.", "id": "f11832:m1"}
{"signature": "def _get_multi_topology_identifier(self):", "body": "return self.__multi_topology_identifier<EOL>", "docstring": "Getter method for multi_topology_identifier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa_types/lsa_type/lsas/lsa/opaque_lsa/extended_link/tlvs/tlv/adjacency_sid/state/multi_topology_identifier (uint8)\n\n    YANG Description: The multi-topology identifier with which the adjacency SID is\nassociated", "id": "f23034:c1:m17"}
{"signature": "def _set_ipv6_neighbor_address(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=TypedListType(<EOL>allowed_type=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>)<EOL>),<EOL>is_leaf=False,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ipv6_neighbor_address = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ipv6_neighbor_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/ipv6_neighbor_address/state/ipv6_neighbor_address (inet:ipv6-address)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_ipv6_neighbor_address is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_ipv6_neighbor_address() directly.\n\n    YANG Description: Contains a 16-octet IPv6 address for a neighboring router on\nthe link described by the (main) TLV. This sub-TLV can occur\nmultiple times.", "id": "f22588:c1:m6"}
{"signature": "def is_compiled_py(filename):", "body": "return True if filename[-<NUM_LIT:4>:].lower() in ('<STR_LIT>', '<STR_LIT>') else False<EOL>", "docstring": "Given a file name, return True if the suffix is pyo or pyc (an\noptimized bytecode file).", "id": "f7434:m1"}
{"signature": "@classmethod<EOL><INDENT>def has_resuming(cls):<DEDENT>", "body": "return True<EOL>", "docstring": "Returns whether it supports to resume the fetch process.\n\n        :returns: this backend supports items resuming", "id": "f13176:c0:m4"}
{"signature": "@profile<EOL>def error_statistics(target_scores, decoy_scores, parametric, pfdr, pi0_lambda, pi0_method = \"<STR_LIT>\", pi0_smooth_df = <NUM_LIT:3>, pi0_smooth_log_pi0 = False, compute_lfdr = False, lfdr_trunc = True, lfdr_monotone = True, lfdr_transf = \"<STR_LIT>\", lfdr_adj = <NUM_LIT>, lfdr_eps = np.power(<NUM_LIT>,-<NUM_LIT:8>)):", "body": "target_scores = to_one_dim_array(target_scores)<EOL>target_scores = np.sort(target_scores[~np.isnan(target_scores)])<EOL>decoy_scores = to_one_dim_array(decoy_scores)<EOL>decoy_scores = np.sort(decoy_scores[~np.isnan(decoy_scores)])<EOL>if parametric:<EOL><INDENT>target_pvalues = pnorm(target_scores, decoy_scores)<EOL><DEDENT>else:<EOL><INDENT>target_pvalues = pemp(target_scores, decoy_scores)<EOL><DEDENT>pi0 = pi0est(target_pvalues, pi0_lambda, pi0_method, pi0_smooth_df, pi0_smooth_log_pi0)<EOL>target_qvalues = qvalue(target_pvalues, pi0['<STR_LIT>'], pfdr)<EOL>metrics = stat_metrics(target_pvalues, pi0['<STR_LIT>'], pfdr)<EOL>error_stat = pd.DataFrame({'<STR_LIT>': target_scores, '<STR_LIT>': target_pvalues, '<STR_LIT>': target_qvalues, '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>'], '<STR_LIT>': metrics['<STR_LIT>']})<EOL>if compute_lfdr:<EOL><INDENT>error_stat['<STR_LIT>'] = lfdr(target_pvalues, pi0['<STR_LIT>'], lfdr_trunc, lfdr_monotone, lfdr_transf, lfdr_adj, lfdr_eps)<EOL><DEDENT>return error_stat, pi0<EOL>", "docstring": "Takes list of decoy and target scores and creates error statistics for target values", "id": "f5157:m15"}
{"signature": "def _get_prefix(self):", "body": "return self.__prefix<EOL>", "docstring": "Getter method for prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/afi_safi/af/segment_routing/prefix_sids/prefix_sid/config/prefix (inet:ip-prefix)\n\n    YANG Description: The IP prefix for which the IGP prefix SID should be advertised. The\nvalue specified is a local prefix on the interface which is advertised\ninto the IGP.", "id": "f22449:c0:m2"}
{"signature": "@pexdoc.pcontracts.contract(<EOL>wave=Waveform,<EOL>dep_var=\"<STR_LIT>\",<EOL>der=\"<STR_LIT>\",<EOL>inst=\"<STR_LIT>\",<EOL>indep_min=\"<STR_LIT>\",<EOL>indep_max=\"<STR_LIT>\",<EOL>)<EOL>def find(wave, dep_var, der=None, inst=<NUM_LIT:1>, indep_min=None, indep_max=None):", "body": "<EOL>ret = copy.copy(wave)<EOL>_bound_waveform(ret, indep_min, indep_max)<EOL>close_min = np.isclose(min(ret._dep_vector), dep_var, FP_RTOL, FP_ATOL)<EOL>close_max = np.isclose(max(ret._dep_vector), dep_var, FP_RTOL, FP_ATOL)<EOL>if ((np.amin(ret._dep_vector) > dep_var) and (not close_min)) or (<EOL>(np.amax(ret._dep_vector) < dep_var) and (not close_max)<EOL>):<EOL><INDENT>return None<EOL><DEDENT>cross_wave = ret._dep_vector - dep_var<EOL>sign_wave = np.sign(cross_wave)<EOL>exact_idx = np.where(np.isclose(ret._dep_vector, dep_var, FP_RTOL, FP_ATOL))[<NUM_LIT:0>]<EOL>left_idx = np.where(np.diff(sign_wave))[<NUM_LIT:0>]<EOL>left_idx = np.setdiff1d(left_idx, exact_idx)<EOL>left_idx = np.setdiff1d(left_idx, exact_idx - <NUM_LIT:1>)<EOL>right_idx = left_idx + <NUM_LIT:1> if left_idx.size else np.array([])<EOL>indep_var = ret._indep_vector[exact_idx] if exact_idx.size else np.array([])<EOL>dvector = np.zeros(exact_idx.size).astype(int) if exact_idx.size else np.array([])<EOL>if left_idx.size and (ret.interp == \"<STR_LIT>\"):<EOL><INDENT>idvector = (<EOL><NUM_LIT> * (ret._dep_vector[right_idx] > ret._dep_vector[left_idx]).astype(int)<EOL>- <NUM_LIT:1><EOL>)<EOL>if indep_var.size:<EOL><INDENT>indep_var = np.concatenate((indep_var, ret._indep_vector[right_idx]))<EOL>dvector = np.concatenate((dvector, idvector))<EOL>sidx = np.argsort(indep_var)<EOL>indep_var = indep_var[sidx]<EOL>dvector = dvector[sidx]<EOL><DEDENT>else:<EOL><INDENT>indep_var = ret._indep_vector[right_idx]<EOL>dvector = idvector<EOL><DEDENT><DEDENT>elif left_idx.size:<EOL><INDENT>y_left = ret._dep_vector[left_idx]<EOL>y_right = ret._dep_vector[right_idx]<EOL>x_left = ret._indep_vector[left_idx]<EOL>x_right = ret._indep_vector[right_idx]<EOL>slope = ((y_left - y_right) / (x_left - x_right)).astype(float)<EOL>if indep_var.size:<EOL><INDENT>indep_var = np.concatenate(<EOL>(indep_var, x_left + ((dep_var - y_left) / slope))<EOL>)<EOL>dvector = np.concatenate((dvector, np.where(slope > <NUM_LIT:0>, <NUM_LIT:1>, -<NUM_LIT:1>)))<EOL>sidx = np.argsort(indep_var)<EOL>indep_var = indep_var[sidx]<EOL>dvector = dvector[sidx]<EOL><DEDENT>else:<EOL><INDENT>indep_var = x_left + ((dep_var - y_left) / slope)<EOL>dvector = np.where(slope > <NUM_LIT:0>, +<NUM_LIT:1>, -<NUM_LIT:1>)<EOL><DEDENT><DEDENT>if der is not None:<EOL><INDENT>indep_var = np.extract(dvector == der, indep_var)<EOL><DEDENT>return indep_var[inst - <NUM_LIT:1>] if inst <= indep_var.size else None<EOL>", "docstring": "r\"\"\"\n    Return the independent variable point associated with a dependent variable point.\n\n    If the dependent variable point is not in the dependent variable vector the\n    independent variable vector point is obtained by linear interpolation\n\n    :param wave: Waveform\n    :type  wave: :py:class:`peng.eng.Waveform`\n\n    :param dep_var: Dependent vector value to search for\n    :type  dep_var: integer, float or complex\n\n    :param der: Dependent vector derivative filter. If +1 only independent\n                vector points that have positive derivatives when crossing\n                the requested dependent vector point are returned; if -1 only\n                independent vector points that have negative derivatives when\n                crossing the requested dependent vector point are returned;\n                if 0 only independent vector points that have null derivatives\n                when crossing the requested dependent vector point are\n                returned; otherwise if None all independent vector points are\n                returned regardless of the dependent vector derivative. The\n                derivative of the first and last point of the waveform is\n                assumed to be null\n    :type  der: integer, float or complex\n\n    :param inst: Instance number filter. If, for example, **inst** equals 3,\n                 then the independent variable vector point at which the\n                 dependent variable vector equals the requested value for the\n                 third time is returned\n    :type  inst: positive integer\n\n    :param indep_min: Independent vector start point of computation\n    :type  indep_min: integer or float\n\n    :param indep_max: Independent vector stop point of computation\n    :type  indep_max: integer or float\n\n    :rtype: integer, float or None if the dependent variable point is not found\n\n    .. [[[cog cog.out(exobj_eng.get_sphinx_autodoc(raised=True)) ]]]\n    .. Auto-generated exceptions documentation for\n    .. peng.wave_functions.find\n\n    :raises:\n     * RuntimeError (Argument \\`dep_var\\` is not valid)\n\n     * RuntimeError (Argument \\`der\\` is not valid)\n\n     * RuntimeError (Argument \\`indep_max\\` is not valid)\n\n     * RuntimeError (Argument \\`indep_min\\` is not valid)\n\n     * RuntimeError (Argument \\`inst\\` is not valid)\n\n     * RuntimeError (Argument \\`wave\\` is not valid)\n\n     * RuntimeError (Incongruent \\`indep_min\\` and \\`indep_max\\`\n       arguments)\n\n    .. [[[end]]]", "id": "f6752:m25"}
{"signature": "def ask_exit(self):", "body": "self.exit_now = True<EOL>", "docstring": "Ask the shell to exit. Can be overiden and used as a callback.", "id": "f21620:c1:m17"}
{"signature": "def find_temp_dir(prefix, tmp_dir=None):", "body": "matches = []<EOL>tmp_dir = tmp_dir or tempfile.gettempdir()<EOL>for tmp_file in os.listdir(tmp_dir):<EOL><INDENT>if tmp_file.startswith(prefix):<EOL><INDENT>matches.append(os.path.join(tmp_dir, tmp_file))<EOL><DEDENT><DEDENT>return matches<EOL>", "docstring": "Find temp dirs in 'tmp_dir' starting with 'prefix", "id": "f19666:m12"}
{"signature": "def _evolve(self, state, qargs=None):", "body": "return SuperOp(self)._evolve(state, qargs)<EOL>", "docstring": "Evolve a quantum state by the QuantumChannel.\n\n        Args:\n            state (QuantumState): The input statevector or density matrix.\n            qargs (list): a list of QuantumState subsystem positions to apply\n                           the operator on.\n\n        Returns:\n            DensityMatrix: the output quantum state as a density matrix.", "id": "f10807:c0:m11"}
{"signature": "@internal<EOL><INDENT>def getTypeWidth(self, dtype: HdlType, do_eval=False) -> Tuple[int, Union[int, RtlSignal], bool]:<DEDENT>", "body": "width = dtype.width<EOL>if isinstance(width, int):<EOL><INDENT>widthStr = str(width)<EOL><DEDENT>else:<EOL><INDENT>widthStr = self.getExprVal(width, do_eval=do_eval)<EOL><DEDENT>return width, widthStr, False<EOL>", "docstring": ":see: doc of method on parent class", "id": "f1386:c1:m14"}
{"signature": "@validate(addr=int, cmd=int)<EOL><INDENT>def read_byte_data(self, addr, cmd):<DEDENT>", "body": "self._set_addr(addr)<EOL>res = SMBUS.i2c_smbus_read_byte_data(self._fd, ffi.cast(\"<STR_LIT>\", cmd))<EOL>if res == -<NUM_LIT:1>:<EOL><INDENT>raise IOError(ffi.errno)<EOL><DEDENT>return res<EOL>", "docstring": "read_byte_data(addr, cmd) -> result\n\n        Perform SMBus Read Byte Data transaction.", "id": "f16062:c0:m8"}
{"signature": "@flat_injector<EOL>def n8NHZqiZN43Q():", "body": "Injector.let(foo=this.foo).foo<EOL>", "docstring": "Let notation.  Link to self.", "id": "f5024:m2"}
{"signature": "@property<EOL><INDENT>def personId(self):<DEDENT>", "body": "return self._json_data.get('<STR_LIT>')<EOL>", "docstring": "The ID of the person.", "id": "f10506:c0:m2"}
{"signature": "def get(<EOL>self, resource_group_name, load_balancer_name, inbound_nat_rule_name, expand=None, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", load_balancer_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", inbound_nat_rule_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>if expand is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", expand, '<STR_LIT:str>')<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the specified load balancer inbound nat rule.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param load_balancer_name: The name of the load balancer.\n        :type load_balancer_name: str\n        :param inbound_nat_rule_name: The name of the inbound nat rule.\n        :type inbound_nat_rule_name: str\n        :param expand: Expands referenced resources.\n        :type expand: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: InboundNatRule or ClientRawResponse if raw=true\n        :rtype: ~azure.mgmt.network.v2017_09_01.models.InboundNatRule or\n         ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f29804:c0:m4"}
{"signature": "def _get_mt_isn(self):", "body": "return self.__mt_isn<EOL>", "docstring": "Getter method for mt_isn, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn (container)\n\n    YANG Description: This container defines list of ISIS multi-topology\nneighbors.", "id": "f22825:c0:m77"}
{"signature": "def report(self, reporter, template):", "body": "return<EOL>", "docstring": "Call reporter with information about the checker (hash name)\nsubstituted into the template.", "id": "f17034:c0:m2"}
{"signature": "def clone(self, instance):", "body": "metaclass = get_metaclass(instance)<EOL>metaclass = self.find_metaclass(metaclass.kind)<EOL>return metaclass.clone(instance)<EOL>", "docstring": "Create a shallow clone of an *instance*.\n\n**Note:** the clone and the original instance **does not** have to be\npart of the same metaclass.", "id": "f14739:c16:m6"}
{"signature": "def call(self, inputs):", "body": "<EOL>features, static_sample = inputs<EOL>length = tf.shape(input=features)[-<NUM_LIT:2>]<EOL>static_sample = static_sample[..., tf.newaxis, :] + tf.zeros([length, <NUM_LIT:1>])<EOL>sample_shape_static = tf.shape(input=static_sample)[:-<NUM_LIT:3>]<EOL>sample_shape_inputs = tf.shape(input=features)[:-<NUM_LIT:3>]<EOL>broadcast_shape_inputs = tf.concat((sample_shape_static, [<NUM_LIT:1>, <NUM_LIT:1>, <NUM_LIT:1>]), <NUM_LIT:0>)<EOL>broadcast_shape_static = tf.concat((sample_shape_inputs, [<NUM_LIT:1>, <NUM_LIT:1>, <NUM_LIT:1>]), <NUM_LIT:0>)<EOL>features = features + tf.zeros(broadcast_shape_inputs)<EOL>static_sample = static_sample + tf.zeros(broadcast_shape_static)<EOL>combined = tf.concat((features, static_sample), axis=-<NUM_LIT:1>)<EOL>collapsed_shape = tf.concat(([-<NUM_LIT:1>], tf.shape(input=combined)[-<NUM_LIT:2>:]), axis=<NUM_LIT:0>)<EOL>out = tf.reshape(combined, collapsed_shape)<EOL>out = self.bilstm(out)  <EOL>out = self.rnn(out)  <EOL>expanded_shape = tf.concat(<EOL>(tf.shape(input=combined)[:-<NUM_LIT:2>], tf.shape(input=out)[<NUM_LIT:1>:]), axis=<NUM_LIT:0>)<EOL>out = tf.reshape(out, expanded_shape)  <EOL>out = self.output_layer(out)  <EOL>loc = out[..., :self.latent_size]<EOL>scale_diag = tf.nn.softplus(out[..., self.latent_size:]) + <NUM_LIT>  <EOL>return tfd.MultivariateNormalDiag(loc=loc, scale_diag=scale_diag)<EOL>", "docstring": "Runs the model to generate a distribution `q(z_{1:T} | x_{1:T}, f)`.\n\n        This generates a list of batched MultivariateNormalDiag\n        distributions using the output of the recurrent model at each\n        timestep to parameterize each distribution.\n\n        Args:\n          inputs: A tuple of a batch of intermediate representations of\n            image frames across all timesteps of shape [..., batch_size,\n            timesteps, dimensions], and a sample of the static latent\n            variable `f` of shape [..., batch_size, latent_size].\n\n        Returns:\n          A batch of MultivariateNormalDiag distributions with event shape\n          [latent_size], batch shape [broadcasted_shape, batch_size,\n          timesteps], and sample shape [sample_shape, broadcasted_shape,\n          batch_size, timesteps, latent_size], where `broadcasted_shape` is\n          the broadcasted sampled shape between the inputs and static\n          sample.", "id": "f15869:c6:m1"}
{"signature": "def run():", "body": "control_loop()<EOL>", "docstring": "Start the capture agent state process.", "id": "f11780:m1"}
{"signature": "def description(self, options):", "body": "return \"<STR_LIT>\".join([describe(options) for describe in self.descriptions])<EOL>", "docstring": "Returns a description of the given filter options relevant to this selector.\n\nArgs:\n    options (Dict[str, Any]): The filter options to describe.\n\nReturns:\n    str: A description of the filter options.", "id": "f16551:c0:m2"}
{"signature": "@staticmethod<EOL><INDENT>def should_analyze_file(modname, path, is_argument=False):<DEDENT>", "body": "if is_argument:<EOL><INDENT>return True<EOL><DEDENT>return path.endswith(\"<STR_LIT>\")<EOL>", "docstring": "Returns whether or not a module should be checked.\n\n        This implementation returns True for all python source file, indicating\n        that all files should be linted.\n\n        Subclasses may override this method to indicate that modules satisfying\n        certain conditions should not be linted.\n\n        :param str modname: The name of the module to be checked.\n        :param str path: The full path to the source code of the module.\n        :param bool is_argument: Whetter the file is an argument to pylint or not.\n                                 Files which respect this property are always\n                                 checked, since the user requested it explicitly.\n        :returns: True if the module should be checked.\n        :rtype: bool", "id": "f18861:c0:m20"}
{"signature": "def __getattr__(self, item):", "body": "return self.points_data[item]<EOL>", "docstring": "Automatically called by Python when the attribute\n        named 'item' is no found. We use this function to forward the call the\n        point record. This is the mechanism used to allow the users to access\n        the points dimensions directly through a LasData.\n\n        Parameters\n        ----------\n        item: str\n            name of the attribute, should be a dimension name\n\n        Returns\n        -------\n        The requested dimension if it exists", "id": "f5974:c0:m10"}
{"signature": "@main.command('<STR_LIT>')<EOL>@click.argument('<STR_LIT>', cls=SectionArgument)<EOL>@click.argument('<STR_LIT:value>',<EOL>required=False)<EOL>@click.option('<STR_LIT>',<EOL>'<STR_LIT:-c>',<EOL>is_flag=True,<EOL>help='<STR_LIT>')<EOL>def set_variable(section, value, create):", "body": "if not value:<EOL><INDENT>value = section<EOL>section = None<EOL><DEDENT>try:<EOL><INDENT>logger.debug('<STR_LIT>')<EOL>settings = config.Settings(section=section)<EOL>conf = s3conf.S3Conf(settings=settings)<EOL>env_vars = conf.get_envfile()<EOL>env_vars.set(value, create=create)<EOL><DEDENT>except exceptions.EnvfilePathNotDefinedError:<EOL><INDENT>raise exceptions.EnvfilePathNotDefinedUsageError()<EOL><DEDENT>", "docstring": "Set value of a variable in an environment file for the given section.\nIf the variable is already defined, its value is replaced, otherwise, it is added to the end of the file.\nThe value is given as \"ENV_VAR_NAME=env_var_value\", e.g.:\n\ns3conf set test ENV_VAR_NAME=env_var_value", "id": "f82:m8"}
{"signature": "def _set_bandwidth_constraints(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=bandwidth_constraints.bandwidth_constraints,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__bandwidth_constraints = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for bandwidth_constraints, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/bandwidth_constraints (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_bandwidth_constraints is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_bandwidth_constraints() directly.\n\n    YANG Description: This container defines bandwidth-constraints. For DS-TE, the\nexisting Maximum Reservable link bandwidth parameter is retained,\nbut its semantics is generalized and interpreted as the aggregate\nbandwidth constraint across all Class-Types", "id": "f22782:c1:m45"}
{"signature": "def _get_igp_shortcuts(self):", "body": "return self.__igp_shortcuts<EOL>", "docstring": "Getter method for igp_shortcuts, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/igp_shortcuts (container)\n\n    YANG Description: This container defines IGP shortcuts configuration and state\ninformation.", "id": "f22506:c0:m29"}
{"signature": "def _get_passive_mode(self):", "body": "return self.__passive_mode<EOL>", "docstring": "Getter method for passive_mode, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/neighbors/neighbor/transport/config/passive_mode (boolean)\n\n    YANG Description: Wait for peers to issue requests to open a BGP session,\nrather than initiating sessions from the local router.", "id": "f23368:c0:m8"}
{"signature": "def add_data(self, data):", "body": "super(Plot, self).add_data(data)<EOL>", "docstring": "Add data to the plot::\n\n        # A data set with 1 point: (\"12:30\", 2)\n        d1 = [\"12:30\", 2]\n\n        # A data set with 2 points: (\"01:00\", 2) and\n        #                           (\"14:20\", 6)\n        d2 = [\"01:00\", 2, \"14:20\", 6]\n\n        graph.add_data(\n                data = d1,\n                title = 'One',\n        )\n        graph.add_data(\n                data = d2,\n                title = 'Two',\n        )\n\nNote that the data must be in (time, value) pairs, and\nthe date format\nmay be any date that is parseable by dateutil.", "id": "f2372:c0:m0"}
{"signature": "def prepare_metadata(metadata):", "body": "pairs = {<EOL>'<STR_LIT>': {<EOL>'<STR_LIT>': [{<EOL>'<STR_LIT:key>': '<STR_LIT>',<EOL>'<STR_LIT:value>': '<STR_LIT>'<EOL>}<EOL>]<EOL>}<EOL>}<EOL>for key,val in metadata.items():<EOL><INDENT>if not isinstance(val,dict) and not isinstance(val,list):<EOL><INDENT>pairs['<STR_LIT>']['<STR_LIT>'].append({'<STR_LIT:key>':key,'<STR_LIT:value>':val})<EOL><DEDENT>elif isinstance(val,dict):            <EOL><INDENT>for k,v in val.items():<EOL><INDENT>if not isinstance(v,dict) and not isinstance(v,list):<EOL><INDENT>pairs['<STR_LIT>']['<STR_LIT>'].append({'<STR_LIT:key>':k,'<STR_LIT:value>':v})<EOL><DEDENT><DEDENT><DEDENT><DEDENT>return pairs<EOL>", "docstring": "prepare a key/value list of metadata for the request. The metadata\n       object that comes in is only parsed one level.", "id": "f9975:m0"}
{"signature": "def INPLACE_ADD(self,pc):", "body": "raise NotImplementedError<EOL>", "docstring": "Implements in-place TOS = TOS1 + TOS.", "id": "f19667:c3:m31"}
{"signature": "def _get_edited_history(self, index):", "body": "if index in self._history_edits:<EOL><INDENT>return self._history_edits[index]<EOL><DEDENT>elif index == len(self._history):<EOL><INDENT>return unicode()<EOL><DEDENT>return self._history[index]<EOL>", "docstring": "Retrieves a history item, possibly with temporary edits.", "id": "f21650:c0:m11"}
{"signature": "def setup_scout(adapter, institute_id='<STR_LIT>', user_name='<STR_LIT>',<EOL>user_mail='<STR_LIT>', api_key=None, demo=False):", "body": "<EOL>LOG.info(\"<STR_LIT>\")<EOL>for collection_name in adapter.db.collection_names():<EOL><INDENT>if not collection_name.startswith('<STR_LIT>'):<EOL><INDENT>LOG.info(\"<STR_LIT>\", collection_name)<EOL>adapter.db.drop_collection(collection_name)<EOL><DEDENT><DEDENT>LOG.info(\"<STR_LIT>\")<EOL>institute_obj = build_institute(<EOL>internal_id=institute_id,<EOL>display_name=institute_id,<EOL>sanger_recipients=[user_mail]<EOL>)<EOL>adapter.add_institute(institute_obj)<EOL>user_obj = dict(<EOL>_id=user_mail,<EOL>email=user_mail,<EOL>name=user_name,<EOL>roles=['<STR_LIT>'],<EOL>institutes=[institute_id]<EOL>)<EOL>adapter.add_user(user_obj)<EOL>if not demo:<EOL><INDENT>try:<EOL><INDENT>mim_files = fetch_mim_files(api_key, mim2genes=True, morbidmap=True, genemap2=True)<EOL><DEDENT>except Exception as err:<EOL><INDENT>LOG.warning(err)<EOL>raise err<EOL><DEDENT>mim2gene_lines = mim_files['<STR_LIT>']<EOL>genemap_lines = mim_files['<STR_LIT>']<EOL>hpo_gene_lines = fetch_hpo_genes()<EOL>hgnc_lines = fetch_hgnc()<EOL>exac_lines = fetch_exac_constraint()<EOL><DEDENT>else:<EOL><INDENT>mim2gene_lines = [line for line in get_file_handle(mim2gene_reduced_path)]<EOL>genemap_lines = [line for line in get_file_handle(genemap2_reduced_path)]<EOL>hpo_gene_lines = [line for line in get_file_handle(hpogenes_reduced_path)]<EOL>hgnc_lines = [line for line in get_file_handle(hgnc_reduced_path)]<EOL>exac_lines = [line for line in get_file_handle(exac_reduced_path)]<EOL><DEDENT>builds = ['<STR_LIT>', '<STR_LIT>']<EOL>for build in builds:<EOL><INDENT>if not demo:<EOL><INDENT>ensembl_genes = fetch_ensembl_genes(build=build)<EOL><DEDENT>else:<EOL><INDENT>ensembl_genes = get_file_handle(genes37_reduced_path)<EOL><DEDENT>hgnc_genes = load_hgnc_genes(<EOL>adapter=adapter,<EOL>ensembl_lines=ensembl_genes,<EOL>hgnc_lines=hgnc_lines,<EOL>exac_lines=exac_lines,<EOL>mim2gene_lines=mim2gene_lines,<EOL>genemap_lines=genemap_lines,<EOL>hpo_lines=hpo_gene_lines,<EOL>build=build,<EOL>)<EOL>ensembl_genes = {}<EOL>for gene_obj in hgnc_genes:<EOL><INDENT>ensembl_id = gene_obj['<STR_LIT>']<EOL>ensembl_genes[ensembl_id] = gene_obj<EOL><DEDENT>if not demo:<EOL><INDENT>ensembl_transcripts = fetch_ensembl_transcripts(build=build)<EOL><DEDENT>else:<EOL><INDENT>ensembl_transcripts = get_file_handle(transcripts37_reduced_path)<EOL><DEDENT>transcripts = load_transcripts(adapter, ensembl_transcripts, build, ensembl_genes)<EOL><DEDENT>hpo_terms_handle = None<EOL>hpo_to_genes_handle = None<EOL>hpo_disease_handle = None<EOL>if demo:<EOL><INDENT>hpo_terms_handle = get_file_handle(hpoterms_reduced_path)<EOL>hpo_to_genes_handle = get_file_handle(hpo_to_genes_reduced_path)<EOL>hpo_disease_handle = get_file_handle(hpo_phenotype_to_terms_reduced_path)<EOL><DEDENT>load_hpo(<EOL>adapter=adapter,<EOL>hpo_lines=hpo_terms_handle,<EOL>hpo_gene_lines=hpo_to_genes_handle,<EOL>disease_lines=genemap_lines,<EOL>hpo_disease_lines=hpo_disease_handle<EOL>)<EOL>if demo:<EOL><INDENT>parsed_panel = parse_gene_panel(<EOL>path=panel_path,<EOL>institute='<STR_LIT>',<EOL>panel_id='<STR_LIT>',<EOL>version=<NUM_LIT:1.0>,<EOL>display_name='<STR_LIT>'<EOL>)<EOL>adapter.load_panel(parsed_panel)<EOL>case_handle = get_file_handle(load_path)<EOL>case_data = yaml.load(case_handle)<EOL>adapter.load_case(case_data)<EOL><DEDENT>LOG.info(\"<STR_LIT>\")<EOL>adapter.load_indexes()<EOL>LOG.info(\"<STR_LIT>\")<EOL>", "docstring": "docstring for setup_scout", "id": "f13812:m0"}
{"signature": "@property<EOL><INDENT>def spread(self):<DEDENT>", "body": "return (self.ask_price - self.bid_price)<EOL>", "docstring": "Compute the difference between bid and ask prices", "id": "f5625:c2:m3"}
{"signature": "def _get_shutdown_threshold_pct(self):", "body": "return self.__shutdown_threshold_pct<EOL>", "docstring": "Getter method for shutdown_threshold_pct, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/config/shutdown_threshold_pct (oc-types:percentage)\n\n    YANG Description: Threshold on number of prefixes that can be received\nfrom a neighbour before generation of warning messages\nor log entries. Expressed as a percentage of\nmax-prefixes", "id": "f23221:c0:m8"}
{"signature": "def _collect_section(self, section):", "body": "kwargs = {}<EOL>try:<EOL><INDENT>if self.parser.has_section(section):<EOL><INDENT>options = self.parser.options(section)<EOL>for option in options:<EOL><INDENT>str_val = self.parser.get(section, option)<EOL>val = ast.literal_eval(str_val)<EOL>kwargs[option] = val<EOL><DEDENT><DEDENT>return kwargs<EOL><DEDENT>except:<EOL><INDENT>raise<EOL><DEDENT>", "docstring": "Collects all settings within a section", "id": "f4226:c0:m1"}
{"signature": "def file_info(self, file_id):", "body": "return self._get('<STR_LIT>', params={'<STR_LIT:file>': file_id})<EOL>", "docstring": "Used to request info for a specific file, info like size, name, .....\n\n        Args:\n            file_id (str): File-ID(s), single file or comma-separated (max. 50)\n\n        Returns:\n            dict: dictionary containing file(s) info, each key represents a file_id. ::\n\n                  {\n                     \"72fA-_Lq8Ak3\": {\n                        \"id\": \"72fA-_Lq8Ak3\",\n                        \"status\": 200,\n                        \"name\": \"The quick brown fox.txt\",\n                        \"size\": 123456789012,\n                        \"sha1\": \"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n                        \"content_type\": \"plain/text\",\n                     },\n                     \"72fA-_Lq8Ak4\": {\n                        \"id\": \"72fA-_Lq8Ak4\",\n                        \"status\": 500,\n                        \"name\": \"The quick brown fox.txt\",\n                        \"size\": false,\n                        \"sha1\": \"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n                        \"content_type\": \"plain/text\",\n                     },\n                     ...\n                   }", "id": "f5237:c0:m7"}
{"signature": "def _set_mpls(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=mpls.mpls,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__mpls = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for mpls, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/global/mpls (container)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_mpls is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_mpls() directly.\n\n    YANG Description: Configuration and operational state relating to MPLS-related\nfeatures in IS-IS", "id": "f22506:c0:m27"}
{"signature": "@property<EOL><INDENT>def is_deprecated(self):<DEDENT>", "body": "return self._metadata['<STR_LIT>']<EOL>", "docstring": "TODO.", "id": "f13017:c2:m31"}
{"signature": "def navigate(self, inst, kind, rel_id, phrase='<STR_LIT>'):", "body": "key = (kind.upper(), rel_id, phrase)<EOL>if key in self.links:<EOL><INDENT>link = self.links[key]<EOL>return link.navigate(inst)<EOL><DEDENT>link1, link2 = self._find_assoc_links(kind, rel_id, phrase)<EOL>inst_set = xtuml.OrderedSet()<EOL>for inst in link1.navigate(inst):<EOL><INDENT>inst_set |= link2.navigate(inst)<EOL><DEDENT>return inst_set<EOL>", "docstring": "Navigate across a link with some *rel_id* and *phrase* that yields\ninstances of some *kind*.", "id": "f14739:c11:m15"}
{"signature": "@classmethod<EOL><INDENT>def setup_cmd_parser(cls):<DEDENT>", "body": "parser = BackendCommandArgumentParser(cls.BACKEND.CATEGORIES,<EOL>from_date=True,<EOL>token_auth=True,<EOL>archive=True)<EOL>group = parser.parser.add_argument_group('<STR_LIT>')<EOL>group.add_argument('<STR_LIT>', dest='<STR_LIT>',<EOL>default=MAX_RETRIES, type=int,<EOL>help=\"<STR_LIT>\")<EOL>group.add_argument('<STR_LIT>', dest='<STR_LIT>',<EOL>default=DEFAULT_SLEEP_TIME, type=int,<EOL>help=\"<STR_LIT>\")<EOL>parser.parser.add_argument('<STR_LIT:url>',<EOL>help=\"<STR_LIT>\")<EOL>return parser<EOL>", "docstring": "Returns the Phabricator argument parser.", "id": "f13168:c3:m0"}
{"signature": "def _set_adjacency_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={\"<STR_LIT>\": {}, \"<STR_LIT>\": {}, \"<STR_LIT>\": {}},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__adjacency_type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for adjacency_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency_type (oc-isis-types:level-type)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_adjacency_type is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_adjacency_type() directly.\n\nYANG Description: Formed ISIS adjacency type(level-1, level-2, level-1-2).", "id": "f22419:c1:m30"}
{"signature": "def get_issuer(self):", "body": "_issuer = _lib.X509_NAME_dup(_lib.X509_CRL_get_issuer(self._crl))<EOL>_openssl_assert(_issuer != _ffi.NULL)<EOL>_issuer = _ffi.gc(_issuer, _lib.X509_NAME_free)<EOL>issuer = X509Name.__new__(X509Name)<EOL>issuer._name = _issuer<EOL>return issuer<EOL>", "docstring": "Get the CRL's issuer.\n\n.. versionadded:: 16.1.0\n\n:rtype: X509Name", "id": "f4638:c13:m5"}
{"signature": "def onlyif(condition, msg):", "body": "if callable(condition):<EOL><INDENT>skip_condition = lambda : not condition()<EOL><DEDENT>else:<EOL><INDENT>skip_condition = lambda : not condition<EOL><DEDENT>return skipif(skip_condition, msg)<EOL>", "docstring": "The reverse from skipif, see skipif for details.", "id": "f21384:m5"}
{"signature": "def _get_dead_time(self):", "body": "return self.__dead_time<EOL>", "docstring": "Getter method for dead_time, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv2/areas/area/virtual_links/virtual_link/state/dead_time (oc-types:timeticks64)\n\n    YANG Description: The time at which this neighbor's adjacency will be\nconsidered dead. This value is expressed as a number of\nseconds since the Unix Epoch", "id": "f23127:c0:m8"}
{"signature": "@cell_magic<EOL><INDENT>@magic_arguments.magic_arguments()<EOL>@magic_arguments.argument(<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>type=str,<EOL>default='<STR_LIT:html>',<EOL>help=\"<STR_LIT>\"<EOL>)<EOL>def qiskit_progress_bar(self, line='<STR_LIT>', cell=None):  <DEDENT>", "body": "args = magic_arguments.parse_argstring(self.qiskit_progress_bar, line)<EOL>if args.type == '<STR_LIT:html>':<EOL><INDENT>HTMLProgressBar()<EOL><DEDENT>elif args.type == '<STR_LIT:text>':<EOL><INDENT>TextProgressBar()<EOL><DEDENT>else:<EOL><INDENT>raise qiskit.QiskitError('<STR_LIT>')<EOL><DEDENT>self.shell.ex(cell)<EOL>", "docstring": "A Jupyter magic function to generate progressbar.", "id": "f10717:c1:m0"}
{"signature": "def update(<EOL>self, resource_group_name, account_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_initial(<EOL>resource_group_name=resource_group_name,<EOL>account_name=account_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Updates the specified Data Lake Store account information.\n\n        :param resource_group_name: The name of the Azure resource group.\n        :type resource_group_name: str\n        :param account_name: The name of the Data Lake Store account.\n        :type account_name: str\n        :param parameters: Parameters supplied to update the Data Lake Store\n         account.\n        :type parameters:\n         ~azure.mgmt.datalake.store.models.UpdateDataLakeStoreAccountParameters\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns DataLakeStoreAccount or\n         ClientRawResponse<DataLakeStoreAccount> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.datalake.store.models.DataLakeStoreAccount]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.datalake.store.models.DataLakeStoreAccount]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f36703:c0:m7"}
{"signature": "def _set_enabled(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__enabled = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/state/enabled (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_enabled is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_enabled() directly.\n\n    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is\nenabled for the neighbour or group", "id": "f23171:c0:m6"}
{"signature": "def get_deployed_service_package_health(<EOL>self, node_name, application_id, service_package_name, events_health_state_filter=<NUM_LIT:0>, timeout=<NUM_LIT>, custom_headers=None, raw=False, **operation_config):", "body": "api_version = \"<STR_LIT>\"<EOL>url = self.get_deployed_service_package_health.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", node_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", application_id, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", service_package_name, '<STR_LIT:str>', skip_quote=True)<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", api_version, '<STR_LIT:str>')<EOL>if events_health_state_filter is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", events_health_state_filter, '<STR_LIT:int>')<EOL><DEDENT>if timeout is not None:<EOL><INDENT>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", timeout, '<STR_LIT>', maximum=<NUM_LIT>, minimum=<NUM_LIT:1>)<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.FabricErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the information about health of a service package for a specific\n        application deployed for a Service Fabric node and application.\n\n        Gets the information about health of a service package for a specific\n        application deployed on a Service Fabric node. Use\n        EventsHealthStateFilter to optionally filter for the collection of\n        HealthEvent objects reported on the deployed service package based on\n        health state.\n\n        :param node_name: The name of the node.\n        :type node_name: str\n        :param application_id: The identity of the application. This is\n         typically the full name of the application without the 'fabric:' URI\n         scheme.\n         Starting from version 6.0, hierarchical names are delimited with the\n         \"~\" character.\n         For example, if the application name is \"fabric:/myapp/app1\", the\n         application identity would be \"myapp~app1\" in 6.0+ and \"myapp/app1\" in\n         previous versions.\n        :type application_id: str\n        :param service_package_name: The name of the service package.\n        :type service_package_name: str\n        :param events_health_state_filter: Allows filtering the collection of\n         HealthEvent objects returned based on health state.\n         The possible values for this parameter include integer value of one of\n         the following health states.\n         Only events that match the filter are returned. All events are used to\n         evaluate the aggregated health state.\n         If not specified, all entries are returned. The state values are\n         flag-based enumeration, so the value could be a combination of these\n         values, obtained using the bitwise 'OR' operator. For example, If the\n         provided value is 6 then all of the events with HealthState value of\n         OK (2) and Warning (4) are returned.\n         - Default - Default value. Matches any HealthState. The value is zero.\n         - None - Filter that doesn't match any HealthState value. Used in\n         order to return no results on a given collection of states. The value\n         is 1.\n         - Ok - Filter that matches input with HealthState value Ok. The value\n         is 2.\n         - Warning - Filter that matches input with HealthState value Warning.\n         The value is 4.\n         - Error - Filter that matches input with HealthState value Error. The\n         value is 8.\n         - All - Filter that matches input with any HealthState value. The\n         value is 65535.\n        :type events_health_state_filter: int\n        :param timeout: The server timeout for performing the operation in\n         seconds. This timeout specifies the time duration that the client is\n         willing to wait for the requested operation to complete. The default\n         value for this parameter is 60 seconds.\n        :type timeout: long\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: DeployedServicePackageHealth or ClientRawResponse if raw=true\n        :rtype: ~azure.servicefabric.models.DeployedServicePackageHealth or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`FabricErrorException<azure.servicefabric.models.FabricErrorException>`", "id": "f27460:c1:m104"}
{"signature": "@Transmit.responder<EOL><INDENT>def receiveData(self, connection, data):<DEDENT>", "body": "try:<EOL><INDENT>protocol = self._protocols[connection]<EOL><DEDENT>except KeyError:<EOL><INDENT>raise NoSuchConnection()<EOL><DEDENT>protocol.dataReceived(data)<EOL>return {}<EOL>", "docstring": "Receives some data for the given protocol.", "id": "f14300:c6:m5"}
{"signature": "def list(<EOL>self, resource_group_name, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VirtualMachinePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VirtualMachinePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all of the virtual machines in the specified resource group. Use\n        the nextLink property in the response to get the next page of virtual\n        machines.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VirtualMachine\n        :rtype:\n         ~azure.mgmt.compute.v2017_03_30.models.VirtualMachinePaged[~azure.mgmt.compute.v2017_03_30.models.VirtualMachine]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f26067:c0:m16"}
{"signature": "@staticmethod<EOL><INDENT>def doc_from_xml(document_element_name, inner_xml,<EOL>xmlns='<STR_LIT>'):<DEDENT>", "body": "xml = '<STR_LIT>'.join(['<STR_LIT:<>', document_element_name,<EOL>'<STR_LIT>'.format(xmlns)])<EOL>xml += inner_xml<EOL>xml += '<STR_LIT>'.join(['<STR_LIT>', document_element_name, '<STR_LIT:>>'])<EOL>return xml<EOL>", "docstring": "Wraps the specified xml in an xml root element with default azure\n        namespaces", "id": "f41516:c3:m8"}
{"signature": "def function16():", "body": "class TupleTest(tuple):<EOL><INDENT>\"\"\"<STR_LIT>\"\"\"<EOL>pass<EOL><DEDENT>return TupleTest()[<NUM_LIT:0>]<EOL>", "docstring": "Index of subclass of tuple is an int constant", "id": "f18452:m15"}
{"signature": "def load(self):", "body": "try:<EOL><INDENT>self.__openlib()<EOL>return self.lib is not None<EOL><DEDENT>except OSError:<EOL><INDENT>return False<EOL><DEDENT>", "docstring": "Returns-->boolean: whether library could be loaded\nWhen this is called, the library would have been loaded if possible\nIf this is not called, the first invocation of a method in lib\nCAN raise OSError if shared library cannot be loaded", "id": "f2386:c0:m1"}
{"signature": "def _set_ipv6_interface_address(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_dict={<EOL>\"<STR_LIT>\": \"<STR_LIT>\"<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ipv6_interface_address = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ipv6_interface_address, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/ipv6_srlg/state/ipv6_interface_address (inet:ipv6-address)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_ipv6_interface_address is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_ipv6_interface_address() directly.\n\nYANG Description: IPv6 interface address or Link Local Identifier.", "id": "f22899:c1:m15"}
{"signature": "def _set_config(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=config.config,<EOL>is_container=\"<STR_LIT>\",<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>extensions=None,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__config = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for config, mapped from YANG variable /network_instances/network_instance/mpls/lsps/static_lsps/static_lsp/ingress/config (container)\nIf this variable is read-only (config: false) in the\nsource YANG file, then _set_config is considered as a private\nmethod. Backends looking to populate this variable should\ndo so via calling thisObj._set_config() directly.\n\nYANG Description: Configuration data for ingress LSPs", "id": "f22223:c1:m3"}
{"signature": "def main():", "body": "height, width = <NUM_LIT>, <NUM_LIT><EOL>inputs = tf.Variable(tf.random_uniform((<NUM_LIT:1>, height, width, <NUM_LIT:3>)), name='<STR_LIT:input>')<EOL>inputs = tf.identity(inputs, \"<STR_LIT>\")<EOL>net, end_points  = vgg.vgg_19(inputs, is_training = False)<EOL>print(\"<STR_LIT>\")<EOL>for n in end_points:<EOL><INDENT>print(n + \"<STR_LIT>\" + str(end_points[n]))<EOL><DEDENT>net_outputs = map(lambda x: tf.get_default_graph().get_tensor_by_name(x), argv[<NUM_LIT:2>].split('<STR_LIT:U+002C>'))<EOL>run_model(net_outputs, argv[<NUM_LIT:1>], '<STR_LIT>', argv[<NUM_LIT:3>] == '<STR_LIT:True>')<EOL>", "docstring": "You can also run these commands manually to generate the pb file\n1. git clone https://github.com/tensorflow/models.git\n2. export PYTHONPATH=Path_to_your_model_folder\n3. python alexnet.py", "id": "f13201:m0"}
{"signature": "def _set_ignore_next_hop_igp_metric(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__ignore_next_hop_igp_metric = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for ignore_next_hop_igp_metric, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/global/afi_safis/afi_safi/route_selection_options/state/ignore_next_hop_igp_metric (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_ignore_next_hop_igp_metric is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_ignore_next_hop_igp_metric() directly.\n\n    YANG Description: Ignore the IGP metric to the next-hop when calculating\nBGP best-path. The default is to select the route for\nwhich the metric to the next-hop is lowest", "id": "f23404:c1:m18"}
{"signature": "def _set_available_bandwidth(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=bitarray, restriction_dict={\"<STR_LIT>\": [\"<STR_LIT>\"]}<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__available_bandwidth = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for available_bandwidth, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/extended_is_reachability/neighbors/neighbors/subTLVs/subTLVs/available_bandwidth/state/available_bandwidth (oc-types:ieeefloat32)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_available_bandwidth is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_available_bandwidth() directly.\n\n    YANG Description: The available bandwidth on a link, forwarding adjacency, or\nbundled link in IEEE floating-point format with units of bytes\nper second. For a link or forwarding adjacency, available\nbandwidth is defined to be residual bandwidth minus the measured\nbandwidth used for the actual forwarding of non-RSVP-TE label\nswitched path packets.  For a bundled link, available bandwidth\nis defined to be the sum of the component link available\nbandwidths minus the measured bandwidth used for the actual\nforwarding of non-RSVP-TE label switched path packets.  For a\nbundled link, available bandwidth is defined to be the sum of\nthe component link available bandwidths.", "id": "f22578:c0:m6"}
{"signature": "def _get_setup_priority(self):", "body": "return self.__setup_priority<EOL>", "docstring": "Getter method for setup_priority, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/unreserved_bandwidth/setup_priority/state/setup_priority (uint8)\n\n    YANG Description: Setup priority level of 0 through 7 to be used by Unreserved Bandwidth\nsub-TLV 11.", "id": "f22725:c1:m2"}
{"signature": "def create_blob_sas_defintion(self, storage_account_name, vault_url):", "body": "from azure.storage.blob import BlockBlobService, ContainerPermissions<EOL>from azure.keyvault.models import SasTokenType, SasDefinitionAttributes<EOL>from azure.keyvault import SecretId<EOL>service = BlockBlobService(account_name=storage_account_name,<EOL>account_key='<STR_LIT>')<EOL>permissions = ContainerPermissions(read=True, write=True, delete=True, list=True)<EOL>temp_token = service.generate_container_shared_access_signature(container_name='<STR_LIT>',<EOL>permission=permissions,<EOL>expiry='<STR_LIT>')<EOL>blob_sas_template_uri = service.make_container_url(container_name='<STR_LIT>',<EOL>protocol='<STR_LIT>',<EOL>sas_token=temp_token)<EOL>attributes = SasDefinitionAttributes(enabled=True)<EOL>blob_sas_def = self.client.set_sas_definition(vault_base_url=vault_url,<EOL>storage_account_name=storage_account_name,<EOL>sas_definition_name='<STR_LIT>',<EOL>template_uri=blob_sas_template_uri,<EOL>sas_type=SasTokenType.service,<EOL>validity_period='<STR_LIT>',<EOL>sas_definition_attributes=attributes)<EOL>sas_secret_id = SecretId(uri=blob_sas_def.secret_id)<EOL>blob_sas_token = self.client.get_secret(vault_base_url=sas_secret_id.vault,<EOL>secret_name=sas_secret_id.name,<EOL>secret_version=sas_secret_id.version).value<EOL>service = BlockBlobService(account_name=storage_account_name,<EOL>sas_token=blob_sas_token)<EOL>service.create_blob_from_text(container_name='<STR_LIT>',<EOL>blob_name='<STR_LIT>',<EOL>text=u'<STR_LIT>')<EOL>blobs = list(service.list_blobs(container_name='<STR_LIT>'))<EOL>for blob in blobs:<EOL><INDENT>service.delete_blob(container_name='<STR_LIT>',<EOL>blob_name=blob.name)<EOL><DEDENT>", "docstring": "Creates a service SAS definition with access to a blob container.", "id": "f35602:c0:m2"}
{"signature": "@property<EOL><INDENT>def remote_container(self):<DEDENT>", "body": "return self._pn_connection.remote_container<EOL>", "docstring": "Return the name of the remote container. Should be present once the\n        connection is active.", "id": "f4879:c2:m6"}
{"signature": "def refresh(self, force=False, soon=<NUM_LIT>):", "body": "if hasattr(self.provider_class, '<STR_LIT>'):<EOL><INDENT>if force or self.expire_soon(soon):<EOL><INDENT>logging.info('<STR_LIT>'.format(self.provider_name))<EOL>return self.provider_class(<EOL>self, None, self.provider_name).refresh_credentials(self)<EOL><DEDENT><DEDENT>", "docstring": "Refreshes the credentials only if the **provider** supports it and if\nit will expire in less than one day. It does nothing in other cases.\n\n.. note::\n\n    The credentials will be refreshed only if it gives sense\n    i.e. only |oauth2|_ has the notion of credentials\n    *refreshment/extension*.\n    And there are also differences across providers e.g. Google\n    supports refreshment only if there is a ``refresh_token`` in\n    the credentials and that in turn is present only if the\n    ``access_type`` parameter was set to ``offline`` in the\n    **user authorization request**.\n\n:param bool force:\n    If ``True`` the credentials will be refreshed even if they\n    won't expire soon.\n\n:param int soon:\n    Number of seconds specifying what means *soon*.", "id": "f5366:c6:m8"}
{"signature": "def _get_default_export_policy(self):", "body": "return self.__default_export_policy<EOL>", "docstring": "Getter method for default_export_policy, mapped from YANG variable /network_instances/network_instance/inter_instance_policies/apply_policy/config/default_export_policy (default-policy-type)\n\n    YANG Description: explicitly set a default policy if no policy definition\nin the export policy chain is satisfied.", "id": "f22093:c0:m11"}
{"signature": "def getname(f):", "body": "try:<EOL><INDENT>return f.__name__<EOL><DEDENT>except:<EOL><INDENT>pass<EOL><DEDENT>try:<EOL><INDENT>return f.name<EOL><DEDENT>except:<EOL><INDENT>pass<EOL><DEDENT>return str(f)<EOL>", "docstring": "Get the name of an object.\n\n    For use in case of callables that are not functions, and\n    thus may not have __name__ defined.\n\n    Order: f.__name__ >  f.name > str(f)", "id": "f21696:m2"}
{"signature": "def extend(self, *args, **kwargs):", "body": "if len(args) > <NUM_LIT:1>:<EOL><INDENT>raise TypeError(\"<STR_LIT>\"<EOL>\"<STR_LIT>\".format(len(args)))<EOL><DEDENT>other = args[<NUM_LIT:0>] if len(args) >= <NUM_LIT:1> else ()<EOL>if isinstance(other, HTTPHeaderDict):<EOL><INDENT>for key, val in other.iteritems():<EOL><INDENT>self.add(key, val)<EOL><DEDENT><DEDENT>elif isinstance(other, Mapping):<EOL><INDENT>for key in other:<EOL><INDENT>self.add(key, other[key])<EOL><DEDENT><DEDENT>elif hasattr(other, \"<STR_LIT>\"):<EOL><INDENT>for key in other.keys():<EOL><INDENT>self.add(key, other[key])<EOL><DEDENT><DEDENT>else:<EOL><INDENT>for key, value in other:<EOL><INDENT>self.add(key, value)<EOL><DEDENT><DEDENT>for key, value in kwargs.items():<EOL><INDENT>self.add(key, value)<EOL><DEDENT>", "docstring": "Generic import function for any type of header-like object.\nAdapted version of MutableMapping.update in order to insert items\nwith self.add instead of self.__setitem__", "id": "f11878:c0:m13"}
{"signature": "def gatk_combine_variants(job, vcfs, ref_fasta, ref_fai, ref_dict, merge_option='<STR_LIT>'):", "body": "job.fileStore.logToMaster('<STR_LIT>')<EOL>inputs = {'<STR_LIT>': ref_fasta,<EOL>'<STR_LIT>': ref_fai,<EOL>'<STR_LIT>': ref_dict}<EOL>inputs.update(vcfs)<EOL>work_dir = job.fileStore.getLocalTempDir()<EOL>for name, file_store_id in inputs.iteritems():<EOL><INDENT>job.fileStore.readGlobalFile(file_store_id, os.path.join(work_dir, name))<EOL><DEDENT>command = ['<STR_LIT>', '<STR_LIT>',<EOL>'<STR_LIT>', '<STR_LIT>',<EOL>'<STR_LIT>', '<STR_LIT>',<EOL>'<STR_LIT>', merge_option]<EOL>for uuid, vcf_id in vcfs.iteritems():<EOL><INDENT>command.extend(['<STR_LIT>', os.path.join('<STR_LIT>', uuid)])<EOL><DEDENT>docker_parameters = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT:none>',<EOL>'<STR_LIT>', '<STR_LIT>'.format(job.memory)]<EOL>dockerCall(job=job, workDir=work_dir,<EOL>parameters=command,<EOL>tool='<STR_LIT>',<EOL>dockerParameters=docker_parameters)<EOL>return job.fileStore.writeGlobalFile(os.path.join(work_dir, '<STR_LIT>'))<EOL>", "docstring": "Merges VCF files using GATK CombineVariants\n\n:param JobFunctionWrappingJob job: Toil Job instance\n:param dict vcfs: Dictionary of VCF FileStoreIDs {sample identifier: FileStoreID}\n:param str ref_fasta: FileStoreID for reference genome fasta\n:param str ref_fai: FileStoreID for reference genome index file\n:param str ref_dict: FileStoreID for reference genome sequence dictionary file\n:param str merge_option: Value for --genotypemergeoption flag (Default: 'UNIQUIFY')\n                        'UNIQUIFY': Multiple variants at a single site are merged into a\n                                    single variant record.\n                        'UNSORTED': Used to merge VCFs from the same sample\n:return: FileStoreID for merged VCF file\n:rtype: str", "id": "f3313:m4"}
{"signature": "def signal_kernel(self, kernel_id, signum):", "body": "return self.get_kernel(kernel_id).signal_kernel(signum)<EOL>", "docstring": "Sends a signal to the kernel by its uuid.\n\n        Note that since only SIGTERM is supported on Windows, this function\n        is only useful on Unix systems.\n\n        Parameters\n        ==========\n        kernel_id : uuid\n            The id of the kernel to signal.", "id": "f21627:c1:m10"}
{"signature": "def parse_args():", "body": "usage = \"<STR_LIT>\"<EOL>description = \"<STR_LIT>\"<EOL>argparser = argparse.ArgumentParser(<EOL>usage=usage, description=description)<EOL>argparser.add_argument(<EOL>'<STR_LIT>', type=argparse.FileType('<STR_LIT:r>'),<EOL>help=\"<STR_LIT>\")<EOL>argparser.add_argument(<EOL>'<STR_LIT>', nargs='<STR_LIT:?>', type=argparse.FileType('<STR_LIT:w>'),<EOL>default=sys.stdout, help=\"<STR_LIT>\"<EOL>\"<STR_LIT>\")<EOL>argparser.add_argument(<EOL>'<STR_LIT>', nargs=\"<STR_LIT:?>\", const=str, help=\"<STR_LIT>\")<EOL>args = argparser.parse_args()<EOL>return args<EOL>", "docstring": "Parses command line args using argparse library", "id": "f9793:m1"}
{"signature": "def solve_sylvester(a,b,q):", "body": "<EOL>r,u = schur(a, output='<STR_LIT>')<EOL>s,v = schur(b.conj().transpose(), output='<STR_LIT>')<EOL>f = np.dot(np.dot(u.conj().transpose(), q), v)<EOL>trsyl, = get_lapack_funcs(('<STR_LIT>',), (r,s,f))<EOL>if trsyl is None:<EOL><INDENT>raise RuntimeError('<STR_LIT>')<EOL><DEDENT>y, scale, info = trsyl(r, s, f, tranb='<STR_LIT:C>')<EOL>y = scale*y<EOL>if info < <NUM_LIT:0>:<EOL><INDENT>raise LinAlgError(\"<STR_LIT>\" % (-info,))<EOL><DEDENT>return np.dot(np.dot(u, y), v.conj().transpose())<EOL>", "docstring": "Computes a solution (X) to the Sylvester equation (AX + XB = Q).\n\nParameters\n----------\na : (M, M) array_like\n    Leading matrix of the Sylvester equation\nb : (N, N) array_like\n    Trailing matrix of the Sylvester equation\nq : (M, N) array_like\n    Right-hand side\n\nReturns\n-------\nx : (M, N) ndarray\n    The solution to the Sylvester equation.\n\nRaises\n------\nLinAlgError\n    If solution was not found\n\nNotes\n-----\nComputes a solution to the Sylvester matrix equation via the Bartels-\nStewart algorithm.  The A and B matrices first undergo Schur\ndecompositions.  The resulting matrices are used to construct an\nalternative Sylvester equation (``RY + YS^T = F``) where the R and S\nmatrices are in quasi-triangular form (or, when R, S or F are complex,\ntriangular form).  The simplified equation is then solved using\n``*TRSYL`` from LAPACK directly.\n\n.. versionadded:: 0.11.0", "id": "f19327:m0"}
{"signature": "@nox.session(python=['<STR_LIT>'])<EOL>def type_check(session):", "body": "session.install('<STR_LIT>', '<STR_LIT>')<EOL>session.install('<STR_LIT>')<EOL>session.run(<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>',<EOL>'<STR_LIT>')<EOL>", "docstring": "Run type checking using pytype.", "id": "f12321:m4"}
{"signature": "@MainWrapper<EOL>def main(mash_output, hash_cutoff, sample_id, assembly_file):", "body": "input_f = open(mash_output, \"<STR_LIT:r>\")<EOL>master_dict = {}<EOL>for line in input_f:<EOL><INDENT>tab_split = line.split(\"<STR_LIT:\\t>\")<EOL>current_seq = tab_split[<NUM_LIT:1>].strip()<EOL>ref_accession = \"<STR_LIT:_>\".join(tab_split[<NUM_LIT:0>].strip().split(\"<STR_LIT:_>\")[<NUM_LIT:0>:<NUM_LIT:3>])<EOL>mash_dist = tab_split[<NUM_LIT:2>].strip()<EOL>hashes_list = tab_split[-<NUM_LIT:1>].strip().split(\"<STR_LIT:/>\")<EOL>perc_hashes = float(hashes_list[<NUM_LIT:0>]) / float(hashes_list[<NUM_LIT:1>])<EOL>if ref_accession in master_dict.keys():<EOL><INDENT>current_seq += \"<STR_LIT>\".format(master_dict[ref_accession][-<NUM_LIT:1>])<EOL><DEDENT>if perc_hashes > float(hash_cutoff):<EOL><INDENT>master_dict[ref_accession] = [<EOL>round(<NUM_LIT:1> - float(mash_dist), <NUM_LIT:2>),<EOL>round(perc_hashes, <NUM_LIT:2>),<EOL>current_seq<EOL>]<EOL><DEDENT><DEDENT>send_to_output(master_dict, mash_output, sample_id, assembly_file)<EOL>", "docstring": "Main function that allows to dump a mash dist txt file to a json file\n\nParameters\n----------\nmash_output: str\n    A string with the input file.\nhash_cutoff: str\n    the percentage cutoff for the percentage of shared hashes between query\n    and plasmid in database that is allowed for the plasmid to be reported\n    to the results outputs\nsample_id: str\n    The name of the sample.", "id": "f6599:m1"}
{"signature": "@property<EOL><INDENT>def deny_assignments(self):<DEDENT>", "body": "api_version = self._get_api_version('<STR_LIT>')<EOL>if api_version == '<STR_LIT>':<EOL><INDENT>from .v2018_07_01_preview.operations import DenyAssignmentsOperations as OperationClass<EOL><DEDENT>else:<EOL><INDENT>raise NotImplementedError(\"<STR_LIT>\".format(api_version))<EOL><DEDENT>return OperationClass(self._client, self.config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))<EOL>", "docstring": "Instance depends on the API version:\n\n           * 2018-07-01-preview: :class:`DenyAssignmentsOperations<azure.mgmt.authorization.v2018_07_01_preview.operations.DenyAssignmentsOperations>`", "id": "f45538:c1:m4"}
{"signature": "def chebcompanion(c):", "body": "<EOL>[c] = pu.as_series([c])<EOL>if len(c) < <NUM_LIT:2>:<EOL><INDENT>raise ValueError('<STR_LIT>')<EOL><DEDENT>if len(c) == <NUM_LIT:2>:<EOL><INDENT>return np.array([[-c[<NUM_LIT:0>]/c[<NUM_LIT:1>]]])<EOL><DEDENT>n = len(c) - <NUM_LIT:1><EOL>mat = np.zeros((n, n), dtype=c.dtype)<EOL>scl = np.array([<NUM_LIT:1.>] + [np.sqrt(<NUM_LIT>)]*(n-<NUM_LIT:1>))<EOL>top = mat.reshape(-<NUM_LIT:1>)[<NUM_LIT:1>::n+<NUM_LIT:1>]<EOL>bot = mat.reshape(-<NUM_LIT:1>)[n::n+<NUM_LIT:1>]<EOL>top[<NUM_LIT:0>] = np.sqrt(<NUM_LIT>)<EOL>top[<NUM_LIT:1>:] = <NUM_LIT:1>/<NUM_LIT:2><EOL>bot[...] = top<EOL>mat[:, -<NUM_LIT:1>] -= (c[:-<NUM_LIT:1>]/c[-<NUM_LIT:1>])*(scl/scl[-<NUM_LIT:1>])*<NUM_LIT><EOL>return mat<EOL>", "docstring": "Return the scaled companion matrix of c.\n\n    The basis polynomials are scaled so that the companion matrix is\n    symmetric when `c` is aa Chebyshev basis polynomial. This provides\n    better eigenvalue estimates than the unscaled case and for basis\n    polynomials the eigenvalues are guaranteed to be real if\n    `numpy.linalg.eigvalsh` is used to obtain them.\n\n    Parameters\n    ----------\n    c : array_like\n        1-D array of Chebyshev series coefficients ordered from low to high\n        degree.\n\n    Returns\n    -------\n    mat : ndarray\n        Scaled companion matrix of dimensions (deg, deg).\n\n    Notes\n    -----\n\n    .. versionadded::1.7.0", "id": "f18918:m27"}
{"signature": "def __trim_beats(localscore, beats, trim):", "body": "smooth_boe = scipy.signal.convolve(localscore[beats],<EOL>scipy.signal.hann(<NUM_LIT:5>),<EOL>'<STR_LIT>')<EOL>if trim:<EOL><INDENT>threshold = <NUM_LIT:0.5> * ((smooth_boe**<NUM_LIT:2>).mean()**<NUM_LIT:0.5>)<EOL><DEDENT>else:<EOL><INDENT>threshold = <NUM_LIT:0.0><EOL><DEDENT>valid = np.argwhere(smooth_boe > threshold)<EOL>return beats[valid.min():valid.max()]<EOL>", "docstring": "Final post-processing: throw out spurious leading/trailing beats", "id": "f18150:m7"}
{"signature": "def _get_length(self):", "body": "return self.__length<EOL>", "docstring": "Getter method for length, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/undefined_tlvs/undefined_tlv/state/length (uint8)\n\nYANG Description: TLV length.", "id": "f22536:c1:m5"}
{"signature": "def _set_name(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=six.text_type,<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:name>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT:string>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT:string>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__name = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for name, mapped from YANG variable /interfaces/interface/config/name (string)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_name is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_name() directly.\n\n    YANG Description: [adapted from IETF interfaces model (RFC 7223)]\n\nThe name of the interface.\n\nA device MAY restrict the allowed values for this leaf,\npossibly depending on the type of the interface.\nFor system-controlled interfaces, this leaf is the\ndevice-specific name of the interface.  The 'config false'\nlist interfaces/interface[name]/state contains the currently\nexisting interfaces on the device.\n\nIf a client tries to create configuration for a\nsystem-controlled interface that is not present in the\ncorresponding state list, the server MAY reject\nthe request if the implementation does not support\npre-provisioning of interfaces or if the name refers to\nan interface that can never exist in the system.  A\nNETCONF server MUST reply with an rpc-error with the\nerror-tag 'invalid-value' in this case.\n\nThe IETF model in RFC 7223 provides YANG features for the\nfollowing (i.e., pre-provisioning and arbitrary-names),\nhowever they are omitted here:\n\n If the device supports pre-provisioning of interface\n configuration, the 'pre-provisioning' feature is\n advertised.\n\n If the device allows arbitrarily named user-controlled\n interfaces, the 'arbitrary-names' feature is advertised.\n\nWhen a configured user-controlled interface is created by\nthe system, it is instantiated with the same name in the\n/interfaces/interface[name]/state list.", "id": "f22056:c0:m9"}
{"signature": "def positionMinError(G, vmini, extension=<NUM_LIT:0.0>):", "body": "parallaxError = parallaxErrorSkyAvg(G, vmini, extension=extension)<EOL>return _astrometricErrorFactors['<STR_LIT>'].min()*parallaxError,_astrometricErrorFactors['<STR_LIT>'].min()*parallaxError<EOL>", "docstring": "Calculate the minimum position errors from G and (V-I). These correspond to the sky regions with the\nsmallest astrometric errors.\n\nNOTE! THE ERRORS ARE FOR SKY POSITIONS IN THE ICRS (I.E., RIGHT ASCENSION, DECLINATION). MAKE SURE YOUR\nSIMULATED ASTROMETRY IS ALSO ON THE ICRS.\n\nParameters\n----------\n\nG     - Value(s) of G-band magnitude.\nvmini - Value(s) of (V-I) colour.\n\nKeywords\n--------\n\nextension - Add this amount of years to the mission lifetime and scale the errors accordingly.\n\nReturns\n-------\n\nThe minimum error in alpha* and the error in delta, in that order, in micro-arcsecond.", "id": "f239:m8"}
{"signature": "def _get_delay(self):", "body": "return self.__delay<EOL>", "docstring": "Getter method for delay, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_neighbor_attribute/neighbors/neighbor/subTLVs/subTLVs/link_delay_variation/state/delay (uint32)\n\n    YANG Description: Average link delay between two directly connected IS-IS\nneighbors over a configurable interval.", "id": "f22712:c1:m5"}
{"signature": "def safe_repr(obj, short=False):", "body": "try:<EOL><INDENT>result = repr(obj)<EOL><DEDENT>except Exception:<EOL><INDENT>result = object.__repr__(obj)<EOL><DEDENT>if not short or len(result) < pkg_resources._MAX_LENGTH:<EOL><INDENT>return result<EOL><DEDENT>return result[:pkg_resources._MAX_LENGTH] + '<STR_LIT>'<EOL>", "docstring": "copied from Python2.7", "id": "f16915:m0"}
{"signature": "def get_certificate_operation(<EOL>self, vault_base_url, certificate_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.get_certificate_operation.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", vault_base_url, '<STR_LIT:str>', skip_quote=True),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", certificate_name, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT:Content-Type>'] = '<STR_LIT>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters)<EOL>response = self._client.send(request, header_parameters, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.KeyVaultErrorException(self._deserialize, response)<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets the creation operation of a certificate.\n\n        Gets the creation operation associated with a specified certificate.\n        This operation requires the certificates/get permission.\n\n        :param vault_base_url: The vault name, for example\n         https://myvault.vault.azure.net.\n        :type vault_base_url: str\n        :param certificate_name: The name of the certificate.\n        :type certificate_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: CertificateOperation or ClientRawResponse if raw=true\n        :rtype: ~azure.keyvault.v7_0.models.CertificateOperation or\n         ~msrest.pipeline.ClientRawResponse\n        :raises:\n         :class:`KeyVaultErrorException<azure.keyvault.v7_0.models.KeyVaultErrorException>`", "id": "f35772:c1:m50"}
{"signature": "def get_query_includes(tokenized_terms, search_fields):", "body": "query = None<EOL>for term in tokenized_terms:<EOL><INDENT>or_query = None<EOL>for field_name in search_fields:<EOL><INDENT>q = Q(**{\"<STR_LIT>\" % field_name: term})<EOL>if or_query is None:<EOL><INDENT>or_query = q<EOL><DEDENT>else:<EOL><INDENT>or_query = or_query | q<EOL><DEDENT><DEDENT>if query is None:<EOL><INDENT>query = or_query<EOL><DEDENT>else:<EOL><INDENT>query = query & or_query<EOL><DEDENT><DEDENT>return query<EOL>", "docstring": "Builds a query for included terms in a text search.", "id": "f14864:m3"}
{"signature": "def cloneNode(self):", "body": "raise NotImplementedError<EOL>", "docstring": "Return a shallow copy of the current node i.e. a node with the same\n        name and attributes but with no parent or child nodes", "id": "f17205:c0:m8"}
{"signature": "@staticmethod<EOL><INDENT>def check_input(input):<DEDENT>", "body": "def to_jtensor(i):<EOL><INDENT>if isinstance(i, np.ndarray):<EOL><INDENT>return JTensor.from_ndarray(i)<EOL><DEDENT>elif isinstance(i, JTensor):<EOL><INDENT>return i<EOL><DEDENT>else:<EOL><INDENT>raise Exception(\"<STR_LIT>\" % type(i))<EOL><DEDENT><DEDENT>if type(input) is list:<EOL><INDENT>if len(input) == <NUM_LIT:0>:<EOL><INDENT>raise Exception('<STR_LIT>')<EOL><DEDENT>return list(map(lambda i: to_jtensor(i), input)), True<EOL><DEDENT>else:<EOL><INDENT>return [to_jtensor(input)], False<EOL><DEDENT>", "docstring": ":param input: ndarray or list of ndarray or JTensor or list of JTensor.\n:return: (list of JTensor, isTable)", "id": "f13262:c2:m10"}
{"signature": "def supported_vpn_devices(<EOL>self, resource_group_name, virtual_network_gateway_name, custom_headers=None, raw=False, **operation_config):", "body": "<EOL>url = self.supported_vpn_devices.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", resource_group_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", virtual_network_gateway_name, '<STR_LIT:str>'),<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.post(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>exp = CloudError(response)<EOL>exp.request_id = response.headers.get('<STR_LIT>')<EOL>raise exp<EOL><DEDENT>deserialized = None<EOL>if response.status_code == <NUM_LIT:200>:<EOL><INDENT>deserialized = self._deserialize('<STR_LIT:str>', response)<EOL><DEDENT>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Gets a xml format representation for supported vpn devices.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param virtual_network_gateway_name: The name of the virtual network\n         gateway.\n        :type virtual_network_gateway_name: str\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: str or ClientRawResponse if raw=true\n        :rtype: str or ~msrest.pipeline.ClientRawResponse\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f32026:c0:m19"}
{"signature": "def _get_ipv4_unicast(self):", "body": "return self.__ipv4_unicast<EOL>", "docstring": "Getter method for ipv4_unicast, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast (container)\n\nYANG Description: IPv4 unicast configuration options", "id": "f23214:c0:m23"}
{"signature": "def put(self, segment):", "body": "if self.closed:<EOL><INDENT>return<EOL><DEDENT>if segment is not None:<EOL><INDENT>future = self.executor.submit(self.fetch, segment,<EOL>retries=self.retries)<EOL><DEDENT>else:<EOL><INDENT>future = None<EOL><DEDENT>self.queue(self.futures, (segment, future))<EOL>", "docstring": "Adds a segment to the download pool and write queue.", "id": "f7850:c1:m2"}
{"signature": "def create_or_update(<EOL>self, resource_group_name, server_name, job_agent_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._create_or_update_initial(<EOL>resource_group_name=resource_group_name,<EOL>server_name=server_name,<EOL>job_agent_name=job_agent_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "Creates or updates a job agent.\n\n        :param resource_group_name: The name of the resource group that\n         contains the resource. You can obtain this value from the Azure\n         Resource Manager API or the portal.\n        :type resource_group_name: str\n        :param server_name: The name of the server.\n        :type server_name: str\n        :param job_agent_name: The name of the job agent to be created or\n         updated.\n        :type job_agent_name: str\n        :param parameters: The requested job agent resource state.\n        :type parameters: ~azure.mgmt.sql.models.JobAgent\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns JobAgent or\n         ClientRawResponse<JobAgent> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.sql.models.JobAgent]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.sql.models.JobAgent]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f38410:c0:m4"}
{"signature": "def list(<EOL>self, custom_headers=None, raw=False, **operation_config):", "body": "def internal_paging(next_link=None, raw=False):<EOL><INDENT>if not next_link:<EOL><INDENT>url = self.list.metadata['<STR_LIT:url>']<EOL>path_format_arguments = {<EOL>'<STR_LIT>': self._serialize.url(\"<STR_LIT>\", self.config.subscription_id, '<STR_LIT:str>')<EOL>}<EOL>url = self._client.format_url(url, **path_format_arguments)<EOL>query_parameters = {}<EOL>query_parameters['<STR_LIT>'] = self._serialize.query(\"<STR_LIT>\", self.api_version, '<STR_LIT:str>')<EOL><DEDENT>else:<EOL><INDENT>url = next_link<EOL>query_parameters = {}<EOL><DEDENT>header_parameters = {}<EOL>header_parameters['<STR_LIT>'] = '<STR_LIT:application/json>'<EOL>if self.config.generate_client_request_id:<EOL><INDENT>header_parameters['<STR_LIT>'] = str(uuid.uuid1())<EOL><DEDENT>if custom_headers:<EOL><INDENT>header_parameters.update(custom_headers)<EOL><DEDENT>if self.config.accept_language is not None:<EOL><INDENT>header_parameters['<STR_LIT>'] = self._serialize.header(\"<STR_LIT>\", self.config.accept_language, '<STR_LIT:str>')<EOL><DEDENT>request = self._client.get(url, query_parameters, header_parameters)<EOL>response = self._client.send(request, stream=False, **operation_config)<EOL>if response.status_code not in [<NUM_LIT:200>]:<EOL><INDENT>raise models.ErrorException(self._deserialize, response)<EOL><DEDENT>return response<EOL><DEDENT>deserialized = models.VpnSitePaged(internal_paging, self._deserialize.dependencies)<EOL>if raw:<EOL><INDENT>header_dict = {}<EOL>client_raw_response = models.VpnSitePaged(internal_paging, self._deserialize.dependencies, header_dict)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL>", "docstring": "Lists all the VpnSites in a subscription.\n\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: returns the direct response alongside the\n         deserialized response\n        :param operation_config: :ref:`Operation configuration\n         overrides<msrest:optionsforoperations>`.\n        :return: An iterator like instance of VpnSite\n        :rtype:\n         ~azure.mgmt.network.v2018_04_01.models.VpnSitePaged[~azure.mgmt.network.v2018_04_01.models.VpnSite]\n        :raises:\n         :class:`ErrorException<azure.mgmt.network.v2018_04_01.models.ErrorException>`", "id": "f33806:c0:m9"}
{"signature": "def _get_bit_position(self):", "body": "return self.__bit_position<EOL>", "docstring": "Getter method for bit_position, mapped from YANG variable /network_instances/network_instance/mpls/te_global_attributes/mpls_admin_groups/admin_group/config/bit_position (uint32)\n\n    YANG Description: bit-position value for mpls admin-group. The value\nfor the admin group is an integer that represents one\nof the bit positions in the admin-group bitmask. Values\nbetween 0 and 31 are interpreted as the original limit\nof 32 admin groups. Values >=32 are interpreted as\nextended admin group values as per RFC7308.", "id": "f22187:c1:m5"}
{"signature": "def export(self, metadata, **kwargs):", "body": "raise NotImplementedError<EOL>", "docstring": "Turn metadata back into text", "id": "f4321:c0:m4"}
{"signature": "@classmethod<EOL><INDENT>def from_name(cls, name):<DEDENT>", "body": "filename = os.path.join(package_dir, '<STR_LIT:data>', name + '<STR_LIT>')<EOL>return cls.from_file(filename, name)<EOL>", "docstring": "Imports a mass table from a file", "id": "f5263:c0:m2"}
{"signature": "def cross_origin(app, *args, **kwargs):", "body": "_options = kwargs<EOL>_real_decorator = cors.decorate(app, *args, run_middleware=False, with_context=False, **kwargs)<EOL>def wrapped_decorator(f):<EOL><INDENT>spf = SanicPluginsFramework(app)  <EOL>try:<EOL><INDENT>plugin = spf.register_plugin(cors, skip_reg=True)<EOL><DEDENT>except ValueError as e:<EOL><INDENT>assert e.args and len(e.args) > <NUM_LIT:1><EOL>plugin = e.args[<NUM_LIT:1>]<EOL><DEDENT>context = cors.get_context_from_spf(spf)<EOL>log = context.log<EOL>log(logging.DEBUG, \"<STR_LIT>\".format(str(f), str(_options)))<EOL>return _real_decorator(f)<EOL><DEDENT>return wrapped_decorator<EOL>", "docstring": "This function is the decorator which is used to wrap a Sanic route with.\nIn the simplest case, simply use the default parameters to allow all\norigins in what is the most permissive configuration. If this method\nmodifies state or performs authentication which may be brute-forced, you\nshould add some degree of protection, such as Cross Site Forgery\nRequest protection.\n\n:param origins:\n    The origin, or list of origins to allow requests from.\n    The origin(s) may be regular expressions, case-sensitive strings,\n    or else an asterisk\n\n    Default : '*'\n:type origins: list, string or regex\n\n:param methods:\n    The method or list of methods which the allowed origins are allowed to\n    access for non-simple requests.\n\n    Default : [GET, HEAD, POST, OPTIONS, PUT, PATCH, DELETE]\n:type methods: list or string\n\n:param expose_headers:\n    The header or list which are safe to expose to the API of a CORS API\n    specification.\n\n    Default : None\n:type expose_headers: list or string\n\n:param allow_headers:\n    The header or list of header field names which can be used when this\n    resource is accessed by allowed origins. The header(s) may be regular\n    expressions, case-sensitive strings, or else an asterisk.\n\n    Default : '*', allow all headers\n:type allow_headers: list, string or regex\n\n:param supports_credentials:\n    Allows users to make authenticated requests. If true, injects the\n    `Access-Control-Allow-Credentials` header in responses. This allows\n    cookies and credentials to be submitted across domains.\n\n    :note: This option cannot be used in conjuction with a '*' origin\n\n    Default : False\n:type supports_credentials: bool\n\n:param max_age:\n    The maximum time for which this CORS request maybe cached. This value\n    is set as the `Access-Control-Max-Age` header.\n\n    Default : None\n:type max_age: timedelta, integer, string or None\n\n:param send_wildcard: If True, and the origins parameter is `*`, a wildcard\n    `Access-Control-Allow-Origin` header is sent, rather than the\n    request's `Origin` header.\n\n    Default : False\n:type send_wildcard: bool\n\n:param vary_header:\n    If True, the header Vary: Origin will be returned as per the W3\n    implementation guidelines.\n\n    Setting this header when the `Access-Control-Allow-Origin` is\n    dynamically generated (e.g. when there is more than one allowed\n    origin, and an Origin than '*' is returned) informs CDNs and other\n    caches that the CORS headers are dynamic, and cannot be cached.\n\n    If False, the Vary header will never be injected or altered.\n\n    Default : True\n:type vary_header: bool\n\n:param automatic_options:\n    Only applies to the `cross_origin` decorator. If True, Sanic-CORS will\n    override Sanic's default OPTIONS handling to return CORS headers for\n    OPTIONS requests.\n\n    Default : True\n:type automatic_options: bool", "id": "f3866:m0"}
{"signature": "def base_value(self):", "body": "return self.value*self.PREFIXES[self.prefix]<EOL>", "docstring": "gives value without prefix", "id": "f4115:c0:m3"}
{"signature": "def transform_multidim_to_1d_ref(aref, dimension_dict):", "body": "dims = []<EOL>name = aref<EOL>while type(name) is c_ast.ArrayRef:<EOL><INDENT>dims.append(name.subscript)<EOL>name = name.name<EOL><DEDENT>subscript_list = []<EOL>for i, d in enumerate(dims):<EOL><INDENT>if i == <NUM_LIT:0>:<EOL><INDENT>subscript_list.append(d)<EOL><DEDENT>else:<EOL><INDENT>subscript_list.append(c_ast.BinaryOp('<STR_LIT:*>', d, reduce(<EOL>lambda l, r: c_ast.BinaryOp('<STR_LIT:*>', l, r),<EOL>dimension_dict[name.name][-<NUM_LIT:1>:-i-<NUM_LIT:1>:-<NUM_LIT:1>])))<EOL><DEDENT><DEDENT>aref.subscript = reduce(<EOL>lambda l, r: c_ast.BinaryOp('<STR_LIT:+>', l, r), subscript_list)<EOL>aref.name = name<EOL>", "docstring": "Transform ast of multidimensional reference to a single dimension reference.\n\nIn-place operation!", "id": "f4116:m3"}
{"signature": "@myattr.setter<EOL><INDENT>def myattr(self, value):<DEDENT>", "body": "self._thing = value<EOL>", "docstring": "Setter for myattr.", "id": "f18733:c0:m2"}
{"signature": "def _repr_html_(self):", "body": "all_keys = list(set(itertools.chain(*[d.keys for d in self])))<EOL>rows = '<STR_LIT>'<EOL>for decor in self:<EOL><INDENT>th, tr = decor._repr_html_row_(keys=all_keys)<EOL>rows += '<STR_LIT>'.format(tr)<EOL><DEDENT>header = '<STR_LIT>'.format(th)<EOL>html = '<STR_LIT>'.format(header, rows)<EOL>return html<EOL>", "docstring": "Jupyter Notebook magic repr function.", "id": "f7569:c2:m11"}
{"signature": "def _get_signaled_bandwidth(self):", "body": "return self.__signaled_bandwidth<EOL>", "docstring": "Getter method for signaled_bandwidth, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/bandwidth/state/signaled_bandwidth (oc-mplst:bandwidth-kbps)\n\n    YANG Description: The currently signaled bandwidth of the LSP. In the case where\nthe bandwidth is specified explicitly, then this will match the\nvalue of the set-bandwidth leaf; in cases where the bandwidth is\ndynamically computed by the system, the current value of the\nbandwidth should be reflected.", "id": "f22241:c0:m8"}
{"signature": "def update(<EOL>self, resource_group_name, vm_name, parameters, custom_headers=None, raw=False, polling=True, **operation_config):", "body": "raw_result = self._update_initial(<EOL>resource_group_name=resource_group_name,<EOL>vm_name=vm_name,<EOL>parameters=parameters,<EOL>custom_headers=custom_headers,<EOL>raw=True,<EOL>**operation_config<EOL>)<EOL>def get_long_running_output(response):<EOL><INDENT>deserialized = self._deserialize('<STR_LIT>', response)<EOL>if raw:<EOL><INDENT>client_raw_response = ClientRawResponse(deserialized, response)<EOL>return client_raw_response<EOL><DEDENT>return deserialized<EOL><DEDENT>lro_delay = operation_config.get(<EOL>'<STR_LIT>',<EOL>self.config.long_running_operation_timeout)<EOL>if polling is True: polling_method = ARMPolling(lro_delay, **operation_config)<EOL>elif polling is False: polling_method = NoPolling()<EOL>else: polling_method = polling<EOL>return LROPoller(self._client, raw_result, get_long_running_output, polling_method)<EOL>", "docstring": "The operation to update a virtual machine.\n\n        :param resource_group_name: The name of the resource group.\n        :type resource_group_name: str\n        :param vm_name: The name of the virtual machine.\n        :type vm_name: str\n        :param parameters: Parameters supplied to the Update Virtual Machine\n         operation.\n        :type parameters:\n         ~azure.mgmt.compute.v2019_03_01.models.VirtualMachineUpdate\n        :param dict custom_headers: headers that will be added to the request\n        :param bool raw: The poller return type is ClientRawResponse, the\n         direct response alongside the deserialized response\n        :param polling: True for ARMPolling, False for no polling, or a\n         polling object for personal polling strategy\n        :return: An instance of LROPoller that returns VirtualMachine or\n         ClientRawResponse<VirtualMachine> if raw==True\n        :rtype:\n         ~msrestazure.azure_operation.AzureOperationPoller[~azure.mgmt.compute.v2019_03_01.models.VirtualMachine]\n         or\n         ~msrestazure.azure_operation.AzureOperationPoller[~msrest.pipeline.ClientRawResponse[~azure.mgmt.compute.v2019_03_01.models.VirtualMachine]]\n        :raises: :class:`CloudError<msrestazure.azure_exceptions.CloudError>`", "id": "f25374:c0:m7"}
{"signature": "def good(self, msg, *args):", "body": "if WARN >= self.threshold:<EOL><INDENT>if args:<EOL><INDENT>print(green_text(msg % _fix_args(args)))<EOL><DEDENT>else:<EOL><INDENT>print(green_text(msg))<EOL><DEDENT>sys.stdout.flush()<EOL><DEDENT>", "docstring": "If we log WARN messages, log this message as a 'nice' anti-warn\nmessage.", "id": "f19167:c0:m1"}
{"signature": "def _get_subtlv_type(self):", "body": "return self.__subtlv_type<EOL>", "docstring": "Getter method for subtlv_type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/mt_isn/neighbors/neighbor/subTLVs/subTLVs/min_max_link_delay/state/subtlv_type (identityref)\n\n    YANG Description: The type of subTLV being described. The type of subTLV is\nexpressed as a canonical name.", "id": "f22780:c0:m2"}
{"signature": "def _get_endpoint(self):", "body": "return self.__endpoint<EOL>", "docstring": "Getter method for endpoint, mapped from YANG variable /network_instances/network_instance/connection_points/connection_point/endpoints/endpoint (list)\n\n    YANG Description: A list of the endpoints (interfaces or remote\nconnection points that can be used for this\nconnection point). The active endpoint is selected\nbased on the precedence that it is configured\nwith", "id": "f22356:c0:m2"}
{"signature": "def _set_type(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=RestrictedClassType(<EOL>base_type=six.text_type,<EOL>restriction_type=\"<STR_LIT>\",<EOL>restriction_arg={<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>\"<STR_LIT>\": {<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>},<EOL>},<EOL>),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT:type>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=False,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__type = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for type, mapped from YANG variable /network_instances/network_instance/protocols/protocol/isis/levels/level/link_state_database/lsp/tlvs/tlv/isis_alias_id/state/type (identityref)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_type is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_type() directly.\n\n    YANG Description: The type of TLV being described. The type of TLV is\nexpressed as a canonical name.", "id": "f22826:c1:m3"}
{"signature": "def calculate(directory):", "body": "<EOL>if sys.platform == '<STR_LIT>':<EOL><INDENT>slash = '<STR_LIT:\\\\>'<EOL><DEDENT>elif sys.platform == '<STR_LIT>':<EOL><INDENT>slash = '<STR_LIT:/>'<EOL><DEDENT>else:<EOL><INDENT>print('<STR_LIT>')<EOL>return<EOL><DEDENT>print('<STR_LIT>')<EOL>for i in range(len(directory[<NUM_LIT:2>])):  <EOL><INDENT>full_path = directory[<NUM_LIT:0>]+slash+directory[<NUM_LIT:2>][i]<EOL>print(full_path)  <EOL>size(full_path)<EOL>print(md5(full_path))<EOL><DEDENT>", "docstring": "Split the tuple (obtained from scan) to separate files.\n       Alternately send full paths to the files in md5 and call it.\n       :param directory: tuple of files in the directory.", "id": "f16523:m2"}
{"signature": "def _get_config(self):", "body": "return self.__config<EOL>", "docstring": "Getter method for config, mapped from YANG variable /network_instances/network_instance/mpls/lsps/constrained_path/tunnels/tunnel/p2p_tunnel_attributes/p2p_primary_path/p2p_primary_path/config (container)\n\nYANG Description: Configuration parameters related to paths", "id": "f22272:c0:m5"}
{"signature": "def _set_prevent_teardown(self, v, load=False):", "body": "if hasattr(v, \"<STR_LIT>\"):<EOL><INDENT>v = v._utype(v)<EOL><DEDENT>try:<EOL><INDENT>t = YANGDynClass(<EOL>v,<EOL>base=YANGBool,<EOL>default=YANGBool(\"<STR_LIT:false>\"),<EOL>is_leaf=True,<EOL>yang_name=\"<STR_LIT>\",<EOL>parent=self,<EOL>path_helper=self._path_helper,<EOL>extmethods=self._extmethods,<EOL>register_paths=True,<EOL>namespace=\"<STR_LIT>\",<EOL>defining_module=\"<STR_LIT>\",<EOL>yang_type=\"<STR_LIT>\",<EOL>is_config=True,<EOL>)<EOL><DEDENT>except (TypeError, ValueError):<EOL><INDENT>raise ValueError(<EOL>{<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>\"<STR_LIT>\": \"<STR_LIT>\",<EOL>\"<STR_LIT>\": \"\"\"<STR_LIT>\"\"\",<EOL>}<EOL>)<EOL><DEDENT>self.__prevent_teardown = t<EOL>if hasattr(self, \"<STR_LIT>\"):<EOL><INDENT>self._set()<EOL><DEDENT>", "docstring": "Setter method for prevent_teardown, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/config/prevent_teardown (boolean)\n    If this variable is read-only (config: false) in the\n    source YANG file, then _set_prevent_teardown is considered as a private\n    method. Backends looking to populate this variable should\n    do so via calling thisObj._set_prevent_teardown() directly.\n\n    YANG Description: Do not tear down the BGP session when the maximum\nprefix limit is exceeded, but rather only log a\nwarning. The default of this leaf is false, such\nthat when it is not specified, the session is torn\ndown.", "id": "f23217:c0:m6"}
{"signature": "def _get_value(self, key, func=None, split_val=None, as_boolean=False,<EOL>exception_default=None):", "body": "try:<EOL><INDENT>if as_boolean:<EOL><INDENT>return self.config.getboolean(key[<NUM_LIT:0>], key[<NUM_LIT:1>])<EOL><DEDENT>value = self.config.get(key[<NUM_LIT:0>], key[<NUM_LIT:1>])<EOL>if split_val is not None:<EOL><INDENT>value = value.split(split_val)<EOL><DEDENT>if func is not None:<EOL><INDENT>return func(value)<EOL><DEDENT>return value<EOL><DEDENT>except (KeyError, configparser.NoSectionError, configparser.NoOptionError) as e:<EOL><INDENT>if exception_default is not None:<EOL><INDENT>return exception_default<EOL><DEDENT>raise KeyError(e)<EOL><DEDENT>", "docstring": "Helper method to get a value from the config", "id": "f7138:c1:m3"}
{"signature": "def find_texture_files(fbasename, log=None):", "body": "fext = os.path.splitext(fbasename)[<NUM_LIT:1>][<NUM_LIT:1>:].strip().lower()<EOL>material_file = None<EOL>texture_files = []<EOL>vert_colors = False<EOL>face_colors = False<EOL>if fext == '<STR_LIT>':<EOL><INDENT>with open(fbasename, '<STR_LIT:r>') as fread:<EOL><INDENT>for line in fread:<EOL><INDENT>if '<STR_LIT>' in line:<EOL><INDENT>material_file = os.path.basename(line.split()[<NUM_LIT:1>])<EOL>break<EOL><DEDENT><DEDENT><DEDENT>if material_file is not None:<EOL><INDENT>with open(material_file, '<STR_LIT:r>') as fread:<EOL><INDENT>for line in fread:<EOL><INDENT>if '<STR_LIT>' in line:<EOL><INDENT>texture_files.append(os.path.basename(line.split()[<NUM_LIT:1>]))<EOL><DEDENT><DEDENT><DEDENT><DEDENT><DEDENT>elif fext == '<STR_LIT>':<EOL><INDENT>face_element = False<EOL>with open(fbasename, '<STR_LIT:rb>') as fread:<EOL><INDENT>while True:<EOL><INDENT>line = fread.readline().strip().decode('<STR_LIT:ascii>')<EOL>if '<STR_LIT>' in line:<EOL><INDENT>face_element = True<EOL><DEDENT>if '<STR_LIT>' in line:<EOL><INDENT>if face_element:<EOL><INDENT>face_colors = True<EOL><DEDENT>else:<EOL><INDENT>vert_colors = True<EOL><DEDENT><DEDENT>if '<STR_LIT>' in line:<EOL><INDENT>texture_files.append(os.path.basename(line.split()[<NUM_LIT:2>]))<EOL><DEDENT>if '<STR_LIT>' in line:<EOL><INDENT>break<EOL><DEDENT><DEDENT><DEDENT><DEDENT>elif fext == '<STR_LIT>':  <EOL><INDENT>namespace = '<STR_LIT>'<EOL>tree = ET.parse(fbasename)<EOL>for elem in tree.findall(<EOL>'<STR_LIT>' % (namespace, namespace, namespace)):<EOL><INDENT>texture_files.append(elem.text)<EOL><DEDENT><DEDENT>elif fext == '<STR_LIT>':<EOL><INDENT>tree = ET.parse(fbasename)<EOL>for elem in tree.iter(tag='<STR_LIT>'):<EOL><INDENT>texture_files.append(elem.attrib['<STR_LIT:url>'])<EOL><DEDENT><DEDENT>elif fext == '<STR_LIT>':<EOL><INDENT>with open(fbasename, '<STR_LIT:r>') as fread:<EOL><INDENT>for line in fread:<EOL><INDENT>if '<STR_LIT>' in line:<EOL><INDENT>texture_files.append(os.path.basename(line.split('<STR_LIT:\">')[<NUM_LIT:1>]))<EOL><DEDENT><DEDENT><DEDENT><DEDENT>elif fext != '<STR_LIT>':  <EOL><INDENT>print('<STR_LIT>' % fext)<EOL><DEDENT>texture_files_unique = list(set(texture_files))<EOL>if log is not None:<EOL><INDENT>log_file = open(log, '<STR_LIT:a>')<EOL>log_file.write('<STR_LIT>')<EOL>log_file.write('<STR_LIT>' % fbasename)<EOL>log_file.write('<STR_LIT>' % texture_files)<EOL>log_file.write('<STR_LIT>' % texture_files_unique)<EOL>log_file.write('<STR_LIT>' % len(texture_files))<EOL>log_file.write(<EOL>'<STR_LIT>' %<EOL>len(texture_files_unique))<EOL>log_file.write('<STR_LIT>' % vert_colors)<EOL>log_file.write('<STR_LIT>' % face_colors)<EOL>log_file.close()<EOL><DEDENT>colors = {'<STR_LIT>':bool(texture_files), '<STR_LIT>':vert_colors, '<STR_LIT>':face_colors}<EOL>return texture_files, texture_files_unique, material_file, colors<EOL>", "docstring": "Finds the filenames of the referenced texture file(s) (and material\n    file for obj) for the mesh.\n\n    Args:\n        fbasename (str): input filename. Supported file extensions:\n            obj\n            ply\n            dae\n            x3d\n            wrl\n        log (str): filename to log output\n\n    Returns:\n        list: list of all of the texture filenames referenced by the input file.\n            May contain duplicates if the texture files are referenced more\n            than once. List is empty if no texture files are found.\n        list: list of all of the unique texture filenames, also empty if no\n            texture files are found.\n        str: for obj files only, returns the name of the referenced material file.\n            Returns None if no material file is found.", "id": "f9661:m2"}
{"signature": "def _maybe_assert_valid_sample(self, x):", "body": "if not self.validate_args:<EOL><INDENT>return x<EOL><DEDENT>return distribution_util.with_dependencies([<EOL>assert_util.assert_positive(x, message=\"<STR_LIT>\"),<EOL>assert_util.assert_near(<EOL>tf.ones([], dtype=self.dtype),<EOL>tf.reduce_sum(input_tensor=x, axis=-<NUM_LIT:1>),<EOL>message=\"<STR_LIT>\"),<EOL>], x)<EOL>", "docstring": "Checks the validity of a sample.", "id": "f15740:c0:m20"}
